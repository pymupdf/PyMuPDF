# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015-2025, Artifex
# This file is distributed under the same license as the PyMuPDF package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyMuPDF 1.26.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-25 23:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ko\n"
"Language-Team: ko <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../header.rst:-1 1f5ba5d56ddc4a2fa55079bc44f7d2c1
msgid "Artifex"
msgstr "Artifex"

#: ../../header.rst:-1 03f8222493784e3ca314d8d7abdaff0a
msgid ""
"PyMuPDF is a high-performance Python library for data extraction, "
"analysis, conversion & manipulation of PDF (and other) documents."
msgstr "PyMuPDF는 PDF 및 기타 문서의 데이터 추출, 분석, 변환, 조작을 위한 고성능 Python 라이브러리입니다."

#: ../../header.rst:-1 e6cbb920023f4b0992f996b108924b94
msgid ""
"PDF Text Extraction, PDF Image Extraction, PDF Conversion, PDF Tables, "
"PDF Splitting, PDF Creation, Pyodide, PyScript"
msgstr "PDF 텍스트 추출, PDF 이미지 추출, PDF 변환, PDF 테이블, PDF 분할, PDF 생성, Pyodide, PyScript"

#: ../../algebra.rst:6 920754cf16444314b9c46d86f31b0f00
msgid "Operator Algebra for Geometry Objects"
msgstr "기하 객체를 위한 연산자 대수"

#: ../../algebra.rst:10 dec854bb55b9478eb8cc515d6eaca329
msgid ""
"Instances of classes :ref:`Point`, :ref:`IRect`, :ref:`Rect`, :ref:`Quad`"
" and :ref:`Matrix` are collectively also called \"geometry\" objects."
msgstr ":ref:`Point`, :ref:`IRect`, :ref:`Rect`, :ref:`Quad`, :ref:`Matrix` 클래스의 인스턴스는 집합적으로 \"geometry\" 객체라고도 합니다."

#: ../../algebra.rst:12 d199f8882c174dcea71374e8d9993b56
msgid ""
"They all are special cases of Python sequences, see :ref:`SequenceTypes` "
"for more background."
msgstr "모두 Python 시퀀스의 특수한 경우입니다. 자세한 내용은 :ref:`SequenceTypes` 를 참조하세요."

#: ../../algebra.rst:14 122aaf19e93244b3a259c46eacf945b1
msgid ""
"We have defined operators for these classes that allow dealing with them "
"(almost) like ordinary numbers in terms of addition, subtraction, "
"multiplication, division, and some others."
msgstr "이 클래스들에 대해 덧셈, 뺄셈, 곱셈, 나눗셈 및 기타 연산에서 일반 숫자처럼(거의) 다룰 수 있도록 연산자를 정의했습니다."

#: ../../algebra.rst:16 84183cdd392441e182408f158d85ab50
msgid "This chapter is a synopsis of what is possible."
msgstr "이 장은 가능한 작업의 요약입니다."

#: ../../algebra.rst:19 e8894b34cabf472ea53483bffb05e53d
msgid "General Remarks"
msgstr "일반적인 설명"

#: ../../algebra.rst:20 0934454c0329461698c27169858d0afb
msgid ""
"Operators can be either **binary** (i.e. involving two objects) or "
"**unary**."
msgstr "연산자는 **이항** (즉, 두 객체를 포함) 또는 **단항** 일 수 있습니다."

#: ../../algebra.rst:22 68b04e12599f4ce6a527b3d5f4d358aa
msgid ""
"The resulting type of **binary** operations is either a **new object of "
"the left operand's class,** a bool or (for dot products) a float."
msgstr "**이항** 연산의 결과 유형은 **왼쪽 피연산자 클래스의 새 객체**, bool 또는(내적의 경우) float입니다."

#: ../../algebra.rst:24 b5bdf8532fed412092362d18eeb3dbcd
msgid ""
"The result of **unary** operations is either a **new object** of the same"
" class, a bool or a float."
msgstr "**단항** 연산의 결과는 동일한 클래스의 **새 객체**, bool 또는 float입니다."

#: ../../algebra.rst:26 c6550b01d863415293570f3c92bcab4f
msgid ""
"The binary operators `+, -, *, /` are defined for all classes. They "
"*roughly* do what you would expect -- **except, that the second operand "
"...**"
msgstr "이항 연산자 `+, -, *, /` 는 모든 클래스에 대해 정의됩니다. 대략 예상대로 동작합니다 -- **단, 두 번째 피연산자는 ...**"

#: ../../algebra.rst:28 55195cd58e234294875781acefaa545e
msgid ""
"may always be a number which then performs the operation on every "
"component of the first one,"
msgstr "항상 숫자일 수 있으며, 그러면 첫 번째 피연산자의 모든 구성 요소에 대해 연산을 수행합니다,"

#: ../../algebra.rst:29 128012698aa343409977ea7e41b35276
msgid ""
"may always be a numeric sequence of the same length (2, 4 or 6) -- we "
"call such sequences :data:`point_like`, :data:`rect_like`, "
":data:`quad_like` or :data:`matrix_like`, respectively."
msgstr "항상 동일한 길이(2, 4 또는 6)의 숫자 시퀀스일 수 있습니다 -- 이러한 시퀀스를 각각 :data:`point_like`, :data:`rect_like`, :data:`quad_like` 또는 :data:`matrix_like` 라고 합니다."

#: ../../algebra.rst:31 c34b1b77d5ad43c7adc65443468f835d
msgid ""
"Rectangles support **additional binary** operations: **intersection** "
"(operator `\"&\"`), **union** (operator `\"|\"`) and **containment** "
"checking."
msgstr "사각형은 **추가 이항** 연산을 지원합니다: **교집합** (연산자 `\"&\"`), **합집합** (연산자 `\"|\"`) 및 **포함** 확인."

#: ../../algebra.rst:33 25ac1658fe1042febe1cabd928b67c0c
msgid ""
"Binary operators fully support in-place operations. So if \"°\" is a "
"binary operator then the expression `a °= b` is always valid and the same"
" as `a = a ° b`. Therefore, be careful and do **not** do `p1 *= p2` for "
"two points, because thereafter \"p1\" is a **float**."
msgstr "이항 연산자는 제자리 연산을 완전히 지원합니다. 따라서 \"°\"가 이항 연산자이면 표현식 `a °= b` 는 항상 유효하며 `a = a ° b` 와 동일합니다. 따라서 두 점에 대해 `p1 *= p2` 를 **하지 마세요**. 그 후 \"p1\"은 **float** 가 됩니다."

#: ../../algebra.rst:37 a3178a19dae843a2a0d880ab3d29b924
msgid "Unary Operations"
msgstr "단항 연산"

#: ../../algebra.rst:40 ../../algebra.rst:59 49cce5653ff84ecd9e947c39e0d07c87
#: c3820b716a6d44b1be18f6133e3b4589
msgid "Oper."
msgstr "연산"

#: ../../algebra.rst:40 ../../algebra.rst:59 69b612ab28c5403698b26e70c7342e08
#: a4d6a4f7e8074daf86d9c71f76c15e3c
msgid "Result"
msgstr "결과"

#: ../../algebra.rst:42 bd8aa928700f4d6da33517c5c44f92d1
msgid "bool(OBJ)"
msgstr "bool(OBJ)"

#: ../../algebra.rst:42 3944ae985d32466ba96b36a9d164d059
msgid "is false exactly if all components of OBJ are zero"
msgstr "OBJ의 모든 구성 요소가 0인 경우에만 false"

#: ../../algebra.rst:43 77ef179dc26548b3afe5aab5973b1ad3
msgid "abs(OBJ)"
msgstr "abs(OBJ)"

#: ../../algebra.rst:43 c040cb90c08c4c24ab34fca940e7a5d3
msgid "the rectangle area -- equal to norm(OBJ) for the other types"
msgstr "사각형 영역 -- 다른 유형의 경우 norm(OBJ)와 동일"

#: ../../algebra.rst:44 8e3b6dc21657411cb9b9aec339f7b58b
msgid "norm(OBJ)"
msgstr "norm(OBJ)"

#: ../../algebra.rst:44 101cabdb07cc4340a520f882a1412565
msgid "square root of the component squares (Euclidean norm)"
msgstr "구성 요소 제곱의 제곱근(유클리드 노름)"

#: ../../algebra.rst:45 7dcf68ad8af544e4ab89a8fb9b2e127f
msgid "+OBJ"
msgstr "+OBJ"

#: ../../algebra.rst:45 bb51eef23c134b9abcde315903ab5fa9
msgid "new copy of OBJ"
msgstr "OBJ의 새 복사본"

#: ../../algebra.rst:46 fbe1c96a611b41cdbdd3c8fd57b6cffd
msgid "-OBJ"
msgstr "-OBJ"

#: ../../algebra.rst:46 bf0e072e4b3b4682b53d14c5d564d191
msgid "new copy of OBJ with negated components"
msgstr "부정된 구성 요소를 가진 OBJ의 새 복사본"

#: ../../algebra.rst:47 41d625338bff4d5bba38dc17591c1cd4
msgid "~m"
msgstr "~m"

#: ../../algebra.rst:47 e461d45306e940efa0e6c12f0b3a0001
msgid "inverse of matrix \"m\", or the null matrix if not invertible"
msgstr "행렬 \"m\"의 역행렬, 또는 역행렬이 없으면 null 행렬"

#: ../../algebra.rst:52 6dee1ec3dcbd4abfb2a10eb496fd0db8
msgid "Binary Operations"
msgstr "이항 연산"

#: ../../algebra.rst:53 77bb8041546c4d36b40997f8dc509039
msgid ""
"These are expressions like `a ° b` where \"°\" is any of the operators "
"`+, -, *, /`. Also binary operations are expressions of the form `a == b`"
" and `b in a`."
msgstr "이것들은 \"°\"가 연산자 `+, -, *, /` 중 하나인 `a ° b` 와 같은 표현식입니다. 또한 이항 연산은 `a == b` 및 `b in a` 형식의 표현식입니다."

#: ../../algebra.rst:55 665cd59a262c4131b350a1640ca2f42c
msgid ""
"If \"b\" is a number, then the respective operation is executed for each "
"component of \"a\". Otherwise, if \"b\" is **not a number,** then the "
"following happens:"
msgstr "\"b\"가 숫자이면 각 구성 요소에 대해 해당 연산이 실행됩니다. 그렇지 않고 \"b\"가 **숫자가 아니면** 다음이 발생합니다:"

#: ../../algebra.rst:61 b25c4a3c6bc2413ea4202520e62172d8
msgid "a+b, a-b"
msgstr "a+b, a-b"

#: ../../algebra.rst:61 bf714007cfab424dbe07b769f64b1915
msgid "component-wise execution, \"b\" must be \"a-like\"."
msgstr "구성 요소별 실행, \"b\"는 \"a-like\"여야 합니다."

#: ../../algebra.rst:62 80c4437403a149669f5a019a372b05a9
msgid "a*m, a/m"
msgstr "a*m, a/m"

#: ../../algebra.rst:62 9c7dff332f5a488587e7031c72f8a13a
msgid ""
"\"a\" can be a point, rectangle or matrix and \"m\" is a "
":data:`matrix_like`. *\"a/m\"* is treated as *\"a*~m\"* (see note below "
"for non-invertible matrices). If \"a\" is a **point** or a **rectangle**,"
" then *\"a.transform(m)\"* is executed. If \"a\" is a matrix, then matrix"
" concatenation takes place."
msgstr "\"a\"는 점, 사각형 또는 행렬일 수 있으며 \"m\"은 :data:`matrix_like` 입니다. *\"a/m\"* 은 *\"a*~m\"* 로 처리됩니다(역행렬이 없는 행렬에 대한 참고 사항은 아래 참조). \"a\"가 **점** 또는 **사각형** 이면 *\"a.transform(m)\"* 이 실행됩니다. \"a\"가 행렬이면 행렬 연결이 수행됩니다."

#: ../../algebra.rst:67 d01766d058d54714bc45e5e76968d4ea
msgid "a*b"
msgstr "a*b"

#: ../../algebra.rst:67 d18a927d83d845ddbd20845807b09e1f
msgid "returns the **vector dot product** for a point \"a\" and point-like \"b\"."
msgstr "점 \"a\"와 점과 유사한 \"b\"에 대한 **벡터 내적** 을 반환합니다."

#: ../../algebra.rst:68 a49b407604184c13b57152c45ddb58ae
msgid "a&b"
msgstr "a&b"

#: ../../algebra.rst:68 7550c08ef54244859c5a00ebed58448c
msgid ""
"**intersection rectangle:** \"a\" must be a rectangle and \"b\" "
":data:`rect_like`. Delivers the **largest rectangle** contained in both "
"operands."
msgstr "**교집합 사각형:** \"a\"는 사각형이어야 하며 \"b\"는 :data:`rect_like` 여야 합니다. 두 피연산자에 모두 포함된 **가장 큰 사각형** 을 제공합니다."

#: ../../algebra.rst:71 a60662c06b0643b0a08f75afa24efb29
msgid "a|b"
msgstr "a|b"

#: ../../algebra.rst:71 79243f4be19046db9091a2f54eb4b815
msgid ""
"**union rectangle:** \"a\" must be a rectangle, and \"b\" may be "
":data:`point_like` or :data:`rect_like`. Delivers the **smallest "
"rectangle** containing both operands."
msgstr "**합집합 사각형:** \"a\"는 사각형이어야 하며 \"b\"는 :data:`point_like` 또는 :data:`rect_like` 일 수 있습니다. 두 피연산자를 모두 포함하는 **가장 작은 사각형** 을 제공합니다."

#: ../../algebra.rst:74 f48f56c4ee6547259acb882e87de433c
msgid "b in a"
msgstr "b in a"

#: ../../algebra.rst:74 8f22ca12cfa44a898823836324a3ed99
msgid ""
"if \"b\" is a number, then `b in tuple(a)` is returned. If \"b\" is "
":data:`point_like`, :data:`rect_like` or :data:`quad_like`, then \"a\" "
"must be a rectangle, and `a.contains(b)` is returned."
msgstr "\"b\"가 숫자이면 `b in tuple(a)` 가 반환됩니다. \"b\"가 :data:`point_like`, :data:`rect_like` 또는 :data:`quad_like` 이면 \"a\"는 사각형이어야 하며 `a.contains(b)` 가 반환됩니다."

#: ../../algebra.rst:77 686725c716014188a79169f7cf3fd1e6
msgid "a == b"
msgstr "a == b"

#: ../../algebra.rst:77 634c54d1d21d471fabf558849def45e4
msgid "``True`` if *bool(a-b)* is ``False`` (\"b\" may be \"a-like\")."
msgstr "*bool(a-b)* 가 ``False`` 이면 ``True`` (\"b\"는 \"a-like\"일 수 있음)."

#: ../../algebra.rst:81 d34c2f644c4b4e6090e0e70255dd2ac5
msgid "Please note an important difference to usual arithmetic:"
msgstr "일반적인 산술과의 중요한 차이점을 참고하세요:"

#: ../../algebra.rst:83 ed3c97cc627d48b394819eb13306021a
msgid ""
"Matrix multiplication is **not commutative**, i.e. in general we have "
"`m*n != n*m` for two matrices. Also, there are non-zero matrices which "
"have no inverse, for example `m = Matrix(1, 0, 1, 0, 1, 0)`. If you try "
"to divide by any of these, you will receive a `ZeroDivisionError` "
"exception using operator *\"/\"*, e.g. for the expression "
"`pymupdf.Identity / m`. But if you formulate `pymupdf.Identity * ~m`, the"
" result will be `pymupdf.Matrix()` (the null matrix)."
msgstr "행렬 곱셈은 **가환적이지 않습니다**. 즉, 일반적으로 두 행렬에 대해 `m*n != n*m` 입니다. 또한 역행렬이 없는 0이 아닌 행렬도 있습니다. 예를 들어 `m = Matrix(1, 0, 1, 0, 1, 0)` 입니다. 이것들 중 하나로 나누려고 하면 연산자 *\"/\"* 를 사용하여 `ZeroDivisionError` 예외를 받게 됩니다. 예를 들어 표현식 `pymupdf.Identity / m` 의 경우입니다. 하지만 `pymupdf.Identity * ~m` 으로 작성하면 결과는 `pymupdf.Matrix()` (null 행렬)가 됩니다."

#: ../../algebra.rst:85 34a95a9718a64ff1a3bea139455bb7f8
msgid ""
"Admittedly, this represents an inconsistency, and we are considering to "
"remove it. For the time being, you can choose to avoid an exception and "
"check whether ~m is the null matrix, or accept a potential "
"*ZeroDivisionError* by using `pymupdf.Identity / m`."
msgstr "인정하건대, 이것은 불일치를 나타내며, 우리는 이를 제거하는 것을 고려하고 있습니다. 당분간 예외를 피하고 ~m이 null 행렬인지 확인하거나, `pymupdf.Identity / m` 을 사용하여 잠재적인 *ZeroDivisionError* 를 받아들일 수 있습니다."

#: ../../algebra.rst:89 be97480da28d4d4190b9207839fe11f4
msgid ""
"With these conventions, all the usual algebra rules apply. For example, "
"arbitrarily using brackets **(among objects of the same class!)** is "
"possible: if r1, r2 are rectangles and m1, m2 are matrices, you can do "
"this `(r1 + r2) * m1 * m2`."
msgstr "이러한 규칙으로 모든 일반적인 대수 규칙이 적용됩니다. 예를 들어, 괄호를 임의로 사용하는 것**(동일한 클래스의 객체 중에서!)** 이 가능합니다: r1, r2가 사각형이고 m1, m2가 행렬이면 `(r1 + r2) * m1 * m2` 를 수행할 수 있습니다."

#: ../../algebra.rst:90 511b54d905464bb8ad95bc07423f1ac2
msgid ""
"For all objects of the same class, `a + b + c == (a + b) + c == a + (b + "
"c)` is true."
msgstr "동일한 클래스의 모든 객체에 대해 `a + b + c == (a + b) + c == a + (b + c)` 가 참입니다."

#: ../../algebra.rst:91 c33b3f88dde84396a57cd45693269bce
msgid ""
"For matrices in addition the following is true: `(m1 + m2) * m3 == m1 * "
"m3 + m2 * m3` (distributivity property)."
msgstr "행렬의 경우 다음이 참입니다: `(m1 + m2) * m3 == m1 * m3 + m2 * m3` (분배 법칙)."

#: ../../algebra.rst:92 78e8741acecb42b284d4923e4453fb4d
msgid ""
"**But the sequence of applying matrices is important:** If r is a "
"rectangle and m1, m2 are matrices, then -- **caution!:**"
msgstr "**하지만 행렬을 적용하는 순서가 중요합니다:** r이 사각형이고 m1, m2가 행렬이면 -- **주의!:**"

#: ../../algebra.rst:93 f0abf06e26414aa19a371baa59b462f2
msgid "`r * m1 * m2 == (r * m1) * m2 != r * (m1 * m2)`"
msgstr "`r * m1 * m2 == (r * m1) * m2 != r * (m1 * m2)`"

#: ../../algebra.rst:96 f4a7e127cb3b40d6bfb3847510e2f35c
msgid "Some Examples"
msgstr "일부 예제"

#: ../../algebra.rst:99 15d4cd12242a495384b94b9fc6c95502
msgid "Manipulation with numbers"
msgstr "숫자로 조작"

#: ../../algebra.rst:100 fcede45c56364a49abff9441c752c928
msgid ""
"For the usual arithmetic operations, numbers are always allowed as second"
" operand. In addition, you can formulate `\"x in OBJ\"`, where x is a "
"number. It is implemented as `\"x in tuple(OBJ)\"`::"
msgstr "일반적인 산술 연산의 경우 숫자는 항상 두 번째 피연산자로 허용됩니다. 또한 x가 숫자인 경우 `\"x in OBJ\"` 를 작성할 수 있습니다. 이것은 `\"x in tuple(OBJ)\"` 로 구현됩니다::"

#: ../../algebra.rst:108 45094f3eda93464f8d0c9fa9f96154a4
msgid ""
"The following will create the upper left quarter of a document page "
"rectangle::"
msgstr "다음은 문서 페이지 사각형의 왼쪽 위 사분면을 생성합니다::"

#: ../../algebra.rst:116 fccb6e938aa14f8c823d2a27fb71bb4e
msgid ""
"The following will deliver the **middle point of a line** that connects "
"two points **p1** and **p2**::"
msgstr "다음은 두 점 **p1** 과 **p2** 를 연결하는 **선의 중점** 을 제공합니다::"

#: ../../algebra.rst:125 0c7572c7661544739337b8dcd633678e
msgid ""
"Compute the **vector dot product** of two points. You can compute the "
"**cosine of angles** and check orthogonality."
msgstr "두 점의 **벡터 내적** 을 계산합니다. **각도의 코사인** 을 계산하고 직교성을 확인할 수 있습니다."

#: ../../algebra.rst:149 9659faf69acb47fd94f2c4d7dbcfd358
msgid "Manipulation with \"like\" Objects"
msgstr "\"like\" 객체로 조작"

#: ../../algebra.rst:151 f7a23c3a7065470aa9f9ae634cfa4521
msgid ""
"The second operand of a binary operation can always be \"like\" the left "
"operand. \"Like\" in this context means \"a sequence of numbers of the "
"same length\". With the above examples::"
msgstr "이항 연산의 두 번째 피연산자는 항상 왼쪽 피연산자와 \"like\"일 수 있습니다. 이 맥락에서 \"Like\"는 \"동일한 길이의 숫자 시퀀스\"를 의미합니다. 위의 예제와 함께::"

#: ../../algebra.rst:162 d40766627f0645a4a9b0f043c79f8df5
msgid "To shift a rectangle for 5 pixels to the right, do this::"
msgstr "사각형을 오른쪽으로 5픽셀 이동하려면 다음을 수행하세요::"

#: ../../algebra.rst:168 40356e8f087b4678a490620822d72405
msgid ""
"Points, rectangles and matrices can be *transformed* with matrices. In "
"PyMuPDF, we treat this like a **\"multiplication\"** (or resp. "
"**\"division\"**), where the second operand may be \"like\" a matrix. "
"Division in this context means \"multiplication with the inverted "
"matrix\"::"
msgstr "점, 사각형 및 행렬은 행렬로 *변환* 될 수 있습니다. PyMuPDF에서는 이를 **\"곱셈\"** (또는 각각 **\"나눗셈\"** )처럼 취급하며, 두 번째 피연산자는 행렬과 \"like\"일 수 있습니다. 이 맥락에서 나눗셈은 \"역행렬과의 곱셈\"을 의미합니다::"

#: ../../algebra.rst:208 ca50582bfe28428c82f4ac0277e2d5be
msgid "As a specialty, rectangles support additional binary operations:"
msgstr "특수 기능으로, 사각형은 추가 이항 연산을 지원합니다:"

#: ../../algebra.rst:210 59df6332d27249a28c44c9d4c7278be7
msgid "**intersection** -- the common area of rectangle-likes, operator *\"&\"*"
msgstr "**교집합** -- 사각형과 유사한 것들의 공통 영역, 연산자 *\"&\"*"

#: ../../algebra.rst:211 de5939af58234aa2be504334193d66d4
msgid ""
"**inclusion** -- enlarge to include a point-like or rect-like, operator "
"*\"|\"*"
msgstr "**포함** -- 점과 유사하거나 사각형과 유사한 것을 포함하도록 확대, 연산자 *\"|\"*"

#: ../../algebra.rst:212 7c511b27c11240cf9d09ca3e172cf9d2
msgid "**containment** check -- whether a point-like or rect-like is inside"
msgstr "**포함** 확인 -- 점과 유사하거나 사각형과 유사한 것이 내부에 있는지 여부"

#: ../../algebra.rst:214 901c1c4b81ce485fa4de1ef6f505e7e3
msgid ""
"Here is an example for creating the smallest rectangle enclosing given "
"points::"
msgstr "주어진 점을 둘러싸는 가장 작은 사각형을 만드는 예제입니다::"

#: ../../footer.rst:46 d8841960d4f44b93825542b2759973e3
msgid "This documentation covers all versions up to |version|."
msgstr "이 문서는 |version| 버전까지의 모든 버전을 다룹니다."

