/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif

#define SWIG_PYTHON_DIRECTOR_NO_VTABLE

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG
#else
# include <Python.h>
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *cstr;
  char *newstr;
  Py_ssize_t len;
  str = PyUnicode_AsUTF8String(str);
  PyBytes_AsStringAndSize(str, &cstr, &len);
  newstr = (char *) malloc(len+1);
  memcpy(newstr, cstr, len+1);
  Py_XDECREF(str);
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

/* Add PyOS_snprintf for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
#  define PyOS_snprintf _snprintf
# else
#  define PyOS_snprintf snprintf
# endif
#endif

/* A crude PyString_FromFormat implementation for old Pythons */
#if PY_VERSION_HEX < 0x02020000

#ifndef SWIG_PYBUFFER_SIZE
# define SWIG_PYBUFFER_SIZE 1024
#endif

static PyObject *
PyString_FromFormat(const char *fmt, ...) {
  va_list ap;
  char buf[SWIG_PYBUFFER_SIZE * 2];
  int res;
  va_start(ap, fmt);
  res = vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
}
#endif

#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

/* A crude PyExc_StopIteration exception for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# ifndef PyExc_StopIteration
#  define PyExc_StopIteration PyExc_RuntimeError
# endif
# ifndef PyObject_GenericGetAttr
#  define PyObject_GenericGetAttr 0
# endif
#endif

/* Py_NotImplemented is defined in 2.1 and up. */
#if PY_VERSION_HEX < 0x02010000
# ifndef Py_NotImplemented
#  define Py_NotImplemented PyExc_RuntimeError
# endif
#endif

/* A crude PyString_AsStringAndSize implementation for old Pythons */
#if PY_VERSION_HEX < 0x02010000
# ifndef PyString_AsStringAndSize
#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
# endif
#endif

/* PySequence_Size for old Pythons */
#if PY_VERSION_HEX < 0x02000000
# ifndef PySequence_Size
#  define PySequence_Size PySequence_Length
# endif
#endif

/* PyBool_FromLong for old Pythons */
#if PY_VERSION_HEX < 0x02030000
static
PyObject *PyBool_FromLong(long ok)
{
  PyObject *result = ok ? Py_True : Py_False;
  Py_INCREF(result);
  return result;
}
#endif

/* Py_ssize_t for old Pythons */
/* This code is as recommended by: */
/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intintargfunc ssizessizeargfunc;
typedef intobjargproc ssizeobjargproc;
typedef intintobjargproc ssizessizeobjargproc;
typedef getreadbufferproc readbufferproc;
typedef getwritebufferproc writebufferproc;
typedef getsegcountproc segcountproc;
typedef getcharbufferproc charbufferproc;
static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
{
  long result = 0;
  PyObject *i = PyNumber_Int(x);
  if (i) {
    result = PyInt_AsLong(i);
    Py_DECREF(i);
  }
  return result;
}
#endif

#if PY_VERSION_HEX < 0x02050000
#define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
#endif

#if PY_VERSION_HEX < 0x02040000
#define Py_VISIT(op)				\
  do { 						\
    if (op) {					\
      int vret = visit((op), arg);		\
      if (vret)					\
        return vret;				\
    }						\
  } while (0)
#endif

#if PY_VERSION_HEX < 0x02030000
typedef struct {
  PyTypeObject type;
  PyNumberMethods as_number;
  PyMappingMethods as_mapping;
  PySequenceMethods as_sequence;
  PyBufferProcs as_buffer;
  PyObject *name, *slots;
} PyHeapTypeObject;
#endif

#if PY_VERSION_HEX < 0x02030000
typedef destructor freefunc;
#endif

#if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
     (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
     (PY_MAJOR_VERSION > 3))
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
#endif

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#define Py_hash_t long
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    char *tmp;
    PyObject *old_str = PyObject_Str(value);
    PyErr_Clear();
    Py_XINCREF(type);

    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
#      define SWIG_PYTHON_USE_GIL
#    endif
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;


/* -----------------------------------------------------------------------------
 * Wrapper of PyInstanceMethod_New() used in Python 3
 * It is exported to the generated module, used for -fastproxy
 * ----------------------------------------------------------------------------- */
#if PY_VERSION_HEX >= 0x03000000
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
{
  return PyInstanceMethod_New(func);
}
#else
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
{
  return NULL;
}
#endif

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
#else
  PyObject*   o2;
  PyObject*   o3;
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyTuple_Check(result)) {
      o2 = result;
      result = PyTuple_New(1);
      PyTuple_SET_ITEM(result, 0, o2);
    }
    o3 = PyTuple_New(1);
    PyTuple_SET_ITEM(o3, 0, obj);
    o2 = result;
    result = PySequence_Concat(o2, o3);
    Py_DECREF(o2);
    Py_DECREF(o3);
  }
  return result;
#endif
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#if PY_VERSION_HEX >= 0x02020000
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
#else
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
#endif

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/*  How to access Py_None */
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  ifndef SWIG_PYTHON_NO_BUILD_NONE
#    ifndef SWIG_PYTHON_BUILD_NONE
#      define SWIG_PYTHON_BUILD_NONE
#    endif
#  endif
#endif

#ifdef SWIG_PYTHON_BUILD_NONE
#  ifdef Py_None
#   undef Py_None
#   define Py_None SWIG_Py_None()
#  endif
SWIGRUNTIMEINLINE PyObject * 
_SWIG_Py_None(void)
{
  PyObject *none = Py_BuildValue((char*)"");
  Py_DECREF(none);
  return none;
}
SWIGRUNTIME PyObject * 
SWIG_Py_None(void)
{
  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
  return none;
}
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  return data ? data->implicitconv : 0;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
#if (PY_VERSION_HEX < 0x02020000)
      data->newraw = 0;
#else
      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
#endif
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
#ifdef METH_O
      data->delargs = !(flags & (METH_O));
#else
      data->delargs = 0;
#endif
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
#ifdef METH_NOARGS
SwigPyObject_repr(SwigPyObject *v)
#else
SwigPyObject_repr(SwigPyObject *v, PyObject *args)
#endif
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
# ifdef METH_NOARGS
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# else
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
# endif
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *val = NULL, *type = NULL, *tb = NULL;
      PyErr_Fetch(&val, &type, &tb);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(val, type, tb);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
#ifndef METH_O
  PyObject *tmp = 0;
  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
  next = tmp;
#endif
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
#ifdef METH_NOARGS
SwigPyObject_next(PyObject* v)
#else
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_disown(PyObject *v)
#else
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_acquire(PyObject *v)
#else
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
#if (PY_VERSION_HEX < 0x02020000)
  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
#elif (PY_VERSION_HEX < 0x02050000)
  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
#else
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) 
#endif
    {
      return NULL;
    } 
  else
    {
      SwigPyObject *sobj = (SwigPyObject *)v;
      PyObject *obj = PyBool_FromLong(sobj->own);
      if (val) {
#ifdef METH_NOARGS
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v);
	} else {
	  SwigPyObject_disown(v);
	}
#else
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v,args);
	} else {
	  SwigPyObject_disown(v,args);
	}
#endif
      } 
      return obj;
    }
}

#ifdef METH_O
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#else
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#endif

#if PY_VERSION_HEX < 0x02020000
SWIGINTERN PyObject *
SwigPyObject_getattr(SwigPyObject *sobj,char *name)
{
  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
}
#endif

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyObject",               /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
#if PY_VERSION_HEX < 0x02020000
      (getattrfunc)SwigPyObject_getattr,    /* tp_getattr */
#else
      (getattrfunc)0,                       /* tp_getattr */
#endif
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpyobject_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
#endif
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME int
SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char result[SWIG_BUFFER_SIZE];
  fputs("<Swig Packed ", fp); 
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    fputs("at ", fp); 
    fputs(result, fp); 
  }
  fputs(v->ty->name,fp); 
  fputs(">", fp);
  return 0; 
}
  
SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyPacked",               /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      (printfunc)SwigPyPacked_print,        /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpypacked_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
#endif
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIMEINLINE PyObject *
_SWIG_This(void)
{
    return SWIG_Python_str_FromChar("this");
}

static PyObject *swig_this = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (swig_this == NULL)
    swig_this = _SWIG_This();
  return swig_this;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
    }
    if (!SWIG_IsOK(res) && obj == Py_None) {
      if (ptr)
        *ptr = 0;
      if (PyErr_Occurred())
        PyErr_Clear();
      res = SWIG_OK;
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    
    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc) 
      return SWIG_ERROR;
    if (ty) {
      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
      if (tc) {
        int newmemory = 0;
        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
        assert(!newmemory); /* newmemory handling not yet implemented */
      } else {
        return SWIG_ERROR;
      }
    } else {
      *ptr = vptr;
    }
    return SWIG_OK;
  }
}

/* Convert a packed value value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
#if (PY_VERSION_HEX >= 0x02020000)
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    inst = ((PyTypeObject*) data->newargs)->tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
    if (inst) {
      PyObject_SetAttr(inst, SWIG_This(), swig_this);
      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
#else
#if (PY_VERSION_HEX >= 0x02010000)
  PyObject *inst = 0;
  PyObject *dict = PyDict_New();
  if (dict) {
    PyDict_SetItem(dict, SWIG_This(), swig_this);
    inst = PyInstance_NewRaw(data->newargs, dict);
    Py_DECREF(dict);
  }
  return (PyObject *) inst;
#else
  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
  if (inst == NULL) {
    return NULL;
  }
  inst->in_class = (PyClassObject *)data->newargs;
  Py_INCREF(inst->in_class);
  inst->in_dict = PyDict_New();
  if (inst->in_dict == NULL) {
    Py_DECREF(inst);
    return NULL;
  }
#ifdef Py_TPFLAGS_HAVE_WEAKREFS
  inst->in_weakreflist = NULL;
#endif
#ifdef Py_TPFLAGS_GC
  PyObject_GC_Init(inst);
#endif
  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
  return (PyObject *) inst;
#endif
#endif
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, (char*)"__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
# ifdef SWIGPY_USE_CAPSULE
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
# else
    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
# endif
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

#if PY_MAJOR_VERSION < 2
/* PyModule_AddObject function was introduced in Python 2.0.  The following function
   is copied out of Python/modsupport.c in python version 2.3.4 */
SWIGINTERN int
PyModule_AddObject(PyObject *m, char *name, PyObject *o)
{
  PyObject *dict;
  if (!PyModule_Check(m)) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs module as first arg");
    return SWIG_ERROR;
  }
  if (!o) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs non-NULL value");
    return SWIG_ERROR;
  }
  
  dict = PyModule_GetDict(m);
  if (dict == NULL) {
    /* Internal error -- modules must have a dict! */
    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
		 PyModule_GetName(m));
    return SWIG_ERROR;
  }
  if (PyDict_SetItemString(dict, name, o))
    return SWIG_ERROR;
  Py_DECREF(o);
  return SWIG_OK;
}
#endif

SWIGRUNTIME void
#ifdef SWIGPY_USE_CAPSULE
SWIG_Python_DestroyModule(PyObject *obj)
#else
SWIG_Python_DestroyModule(void *vptr)
#endif
{
#ifdef SWIGPY_USE_CAPSULE
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
#else
  swig_module_info *swig_module = (swig_module_info *) vptr;
#endif
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  swig_this = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
#ifdef SWIGPY_USE_CAPSULE
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#else
  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#endif
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
#ifdef SWIGPY_USE_CAPSULE
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
#else
    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
#endif
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
#ifdef SWIGPY_USE_CAPSULE
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
#else
      obj = PyCObject_FromVoidPtr(descriptor, NULL);
#endif
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      char *tmp;
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
      } else {
	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_DeviceWrapper swig_types[0]
#define SWIGTYPE_p_Tools swig_types[1]
#define SWIGTYPE_p_char swig_types[2]
#define SWIGTYPE_p_fz_annot_s swig_types[3]
#define SWIGTYPE_p_fz_colorspace_s swig_types[4]
#define SWIGTYPE_p_fz_display_list_s swig_types[5]
#define SWIGTYPE_p_fz_document_s swig_types[6]
#define SWIGTYPE_p_fz_link_s swig_types[7]
#define SWIGTYPE_p_fz_outline_s swig_types[8]
#define SWIGTYPE_p_fz_page_s swig_types[9]
#define SWIGTYPE_p_fz_pixmap_s swig_types[10]
#define SWIGTYPE_p_fz_stext_page_s swig_types[11]
#define SWIGTYPE_p_pdf_graft_map_s swig_types[12]
static swig_type_info *swig_types[14];
static swig_module_info swig_module = {swig_types, 13, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#if (PY_VERSION_HEX <= 0x02000000)
# if !defined(SWIG_PYTHON_CLASSIC)
#  error "This python version requires swig to be run with the '-classic' option"
# endif
#endif

/*-----------------------------------------------
              @(target):= _fitz.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__fitz

#else
#  define SWIG_init    init_fitz

#endif
#define SWIG_name    "_fitz"

#define SWIGVERSION 0x030012 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 


//#define MEMDEBUG
#ifdef MEMDEBUG
#define DEBUGMSG1(x) PySys_WriteStderr("[DEBUG] free %s ", x)
#define DEBUGMSG2 PySys_WriteStderr("... done!\n")
#else
#define DEBUGMSG1(x)
#define DEBUGMSG2
#endif

#define SWIG_FILE_WITH_INIT
#define SWIG_PYTHON_2_UNICODE
#define JM_EPS 1E-5

// memory allocation macros
#define JM_MEMORY 1
#if  PY_VERSION_HEX < 0x03000000
#undef JM_MEMORY
#define JM_MEMORY 0
#endif

#if JM_MEMORY == 1
#define JM_Alloc(type, len) PyMem_New(type, len)
#define JM_Free(x) PyMem_Del(x)
#else
#define JM_Alloc(type, len) (type *) malloc(sizeof(type)*len)
#define JM_Free(x) free(x)
#endif

#define THROWMSG(msg) fz_throw(gctx, FZ_ERROR_GENERIC, msg)
#define assert_PDF(cond) if (cond == NULL) THROWMSG("not a PDF")
#define INRANGE(v, low, high) ((low) <= v && v <= (high))
#define MAX(a, b) ((a) < (b)) ? (b) : (a)
#define MIN(a, b) ((a) < (b)) ? (a) : (b)
#define JM_StrFromBuffer(ctx, x) PyUnicode_DecodeUTF8(fz_string_from_buffer(ctx, x), (Py_ssize_t) fz_buffer_storage(ctx, x, NULL), "replace")
#define JM_PyErr_Clear if (PyErr_Occurred()) PyErr_Clear()

// binary output depending on Python major
# if PY_VERSION_HEX >= 0x03000000
#define JM_UNICODE(data) Py_BuildValue("s", data)
#define JM_BinFromChar(x) PyBytes_FromString(x)
#define JM_BinFromCharSize(x, y) PyBytes_FromStringAndSize(x, (Py_ssize_t) y)
# else
#define JM_UNICODE(data) data ? PyUnicode_DecodeUTF8(data, strlen(data), "replace") : Py_BuildValue("s", NULL)
#define JM_BinFromChar(x) PyByteArray_FromStringAndSize(x, (Py_ssize_t) strlen(x))
#define JM_BinFromCharSize(x, y) PyByteArray_FromStringAndSize(x, (Py_ssize_t) y)
# endif

// define Python None object
#define NONE Py_BuildValue("", NULL)

#include <fitz.h>
#include <pdf.h>
#include <zlib.h>
#include <time.h>
char *JM_Python_str_AsChar(PyObject *str);


fz_context *gctx;
int JM_UNIQUE_ID = 0;

PyObject *fitz_stdout = NULL;
PyObject *fitz_stderr = NULL;

struct DeviceWrapper {
    fz_device *device;
    fz_display_list *list;
};



//-----------------------------------------------------------------------------
// Functions converting betwenn PySequences and fitz geometry objects
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Incomplete - not in use
//-----------------------------------------------------------------------------
/*
int JM_is_valid_quad(fz_quad q)
{
    fz_point b = fz_normalize_vector(fz_make_point(q.ur.x - q.ul.x, q.ur.y - q.ul.y));
    if ((fabs(b.x) + fabs(b.y)) <= JM_EPS) return 0;  // empty quad!

    fz_point c = fz_normalize_vector(fz_make_point(q.ll.x - q.ul.x, q.ll.y - q.ul.y));
    if ((fabs(c.x) + fabs(c.y)) <= JM_EPS) return 0;  // empty quad!

    if (fabs(b.x * c.x + b.y * c.y) > JM_EPS)
        return 0;                                // angle at UL != 90 deg

    b = fz_normalize_vector(fz_make_point(q.ur.x - q.lr.x, q.ur.y - q.lr.y));
    c = fz_normalize_vector(fz_make_point(q.ll.x - q.lr.x, q.ll.y - q.lr.y));
    if (fabs(b.x * c.x + b.y * c.y) > JM_EPS)
        return 0;                                // angle at LR != 90 deg

    b = fz_normalize_vector(fz_make_point(q.ul.x - q.ll.x, q.ul.y - q.ll.y));
    c = fz_normalize_vector(fz_make_point(q.lr.x - q.ll.x, q.lr.y - q.ll.y));
    if (fabs(b.x * c.x + b.y * c.y) > JM_EPS)
        return 0;                                // angle at LL != 90 deg
    return 1;
}
*/

//-----------------------------------------------------------------------------
// PySequence to quad. Default: quad of four (0, 0) points.
// Four floats are treated as coordinates of a rect, and its corners will
// define the quad.
//-----------------------------------------------------------------------------
fz_quad JM_quad_from_py(PyObject *r)
{
    fz_quad q;
    fz_point p[4];
    size_t i;
    q.ul = q.ur = q.ll = q.lr = fz_make_point(0,0);

    if (!r || !PySequence_Check(r) || PySequence_Size(r) != 4)
        return q;

    double x0 = PyFloat_AsDouble(PySequence_ITEM(r, 0));
    if (!PyErr_Occurred())             // assume case 1: a rect is given
    {
        double y0 = PyFloat_AsDouble(PySequence_ITEM(r, 1));
        if (PyErr_Occurred()) goto return_simple;

        double x1 = PyFloat_AsDouble(PySequence_ITEM(r, 2));
        if (PyErr_Occurred()) goto return_simple;

        double y1 = PyFloat_AsDouble(PySequence_ITEM(r, 3));
        if (PyErr_Occurred()) goto return_simple;

        q.ul = fz_make_point(x0, y0);
        q.ur = fz_make_point(x1, y0);
        q.ll = fz_make_point(x0, y1);
        q.lr = fz_make_point(x1, y1);

        return_simple: ;
        PyErr_Clear();
        return q;
    }

    PyErr_Clear();
    for (i = 0; i < 4; i++)
    {
        PyObject *o = PySequence_ITEM(r, i);
        p[i].x = p[i].y = 0;
        if (!PySequence_Check(o) || PySequence_Size(o) != 2)
            goto weiter;

        p[i].x = PyFloat_AsDouble(PySequence_ITEM(o, 0));
        if (PyErr_Occurred())
            p[i].x = 0;

        p[i].y = PyFloat_AsDouble(PySequence_ITEM(o, 1));
        if (PyErr_Occurred())
            p[i].y = 0;

        PyErr_Clear();
        weiter: ;
        Py_CLEAR(o);
    }
    q.ul = p[0];
    q.ur = p[1];
    q.ll = p[2];
    q.lr = p[3];
    return q;
}

//-----------------------------------------------------------------------------
// PySequence to rect. Default: infinite rect
//-----------------------------------------------------------------------------
fz_rect JM_rect_from_py(PyObject *r)
{
    if (!r || !PySequence_Check(r) || PySequence_Size(r) != 4)
        return fz_infinite_rect;

    double x0 = PyFloat_AsDouble(PySequence_ITEM(r, 0));
    if (PyErr_Occurred()) goto return_empty;

    double y0 = PyFloat_AsDouble(PySequence_ITEM(r, 1));
    if (PyErr_Occurred()) goto return_empty;

    double x1 = PyFloat_AsDouble(PySequence_ITEM(r, 2));
    if (PyErr_Occurred()) goto return_empty;

    double y1 = PyFloat_AsDouble(PySequence_ITEM(r, 3));
    if (PyErr_Occurred()) goto return_empty;

    return fz_make_rect((float) x0, (float) y0, (float) x1, (float) y1);

    return_empty: ;
    PyErr_Clear();
    return fz_infinite_rect;
}

//-----------------------------------------------------------------------------
// fz_rect to PySequence
//-----------------------------------------------------------------------------
PyObject *JM_py_from_rect(fz_rect r)
{
    return Py_BuildValue("ffff", r.x0, r.y0, r.x1, r.y1);
}

//-----------------------------------------------------------------------------
// PySequence to fz_irect. Default: infinite irect
//-----------------------------------------------------------------------------
fz_irect JM_irect_from_py(PyObject *r)
{
    if (!r || !PySequence_Check(r) || PySequence_Size(r) != 4)
        return fz_infinite_irect;

    long x0 = PyLong_AsLong(PySequence_ITEM(r, 0));
    if (PyErr_Occurred()) goto return_empty;

    long y0 = PyLong_AsLong(PySequence_ITEM(r, 1));
    if (PyErr_Occurred()) goto return_empty;

    long x1 = PyLong_AsLong(PySequence_ITEM(r, 2));
    if (PyErr_Occurred()) goto return_empty;

    long y1 = PyLong_AsLong(PySequence_ITEM(r, 3));
    if (PyErr_Occurred()) goto return_empty;

    return fz_make_irect((int) x0, (int) y0, (int) x1, (int) y1);

    return_empty: ;
    PyErr_Clear();
    return fz_infinite_irect;
}

//-----------------------------------------------------------------------------
// fz_irect to PySequence
//-----------------------------------------------------------------------------
PyObject *JM_py_from_irect(fz_irect r)
{
    return Py_BuildValue("iiii", r.x0, r.y0, r.x1, r.y1);
}


//-----------------------------------------------------------------------------
// PySequence to fz_point. Default: (0, 0)
//-----------------------------------------------------------------------------
fz_point JM_point_from_py(PyObject *p)
{
    fz_point p0 = {0,0};
    if (!p || !PySequence_Check(p) || PySequence_Size(p) != 2)
        return p0;

    double x = PyFloat_AsDouble(PySequence_ITEM(p, 0));
    if (PyErr_Occurred()) goto zero_point;

    double y = PyFloat_AsDouble(PySequence_ITEM(p, 1));
    if (PyErr_Occurred()) goto zero_point;

    return fz_make_point((float) x, (float) y);

    zero_point: ;
    PyErr_Clear();
    return p0;
}

//-----------------------------------------------------------------------------
// fz_point to PySequence
//-----------------------------------------------------------------------------
PyObject *JM_py_from_point(fz_point p)
{
    return Py_BuildValue("ff", p.x, p.y);
}


//-----------------------------------------------------------------------------
// PySequence to fz_matrix. Default: fz_identity
//-----------------------------------------------------------------------------
fz_matrix JM_matrix_from_py(PyObject *m)
{
    fz_matrix m0 = fz_identity;
    if (!m || !PySequence_Check(m) || PySequence_Size(m) != 6)
        return m0;

    double a = PyFloat_AsDouble(PySequence_ITEM(m, 0));
    if (PyErr_Occurred()) goto fertig;

    double b = PyFloat_AsDouble(PySequence_ITEM(m, 1));
    if (PyErr_Occurred()) goto fertig;

    double c = PyFloat_AsDouble(PySequence_ITEM(m, 2));
    if (PyErr_Occurred()) goto fertig;

    double d = PyFloat_AsDouble(PySequence_ITEM(m, 3));
    if (PyErr_Occurred()) goto fertig;

    double e = PyFloat_AsDouble(PySequence_ITEM(m, 4));
    if (PyErr_Occurred()) goto fertig;

    double f = PyFloat_AsDouble(PySequence_ITEM(m, 5));
    if (PyErr_Occurred()) goto fertig;

    m0.a = a;
    m0.b = b;
    m0.c = c;
    m0.d = d;
    m0.e = e;
    m0.f = f;

    fertig: ;
    PyErr_Clear();
    return m0;
}

//-----------------------------------------------------------------------------
// fz_matrix to PySequence
//-----------------------------------------------------------------------------
PyObject *JM_py_from_matrix(fz_matrix m)
{
    return Py_BuildValue("ffffff", m.a, m.b, m.c, m.d, m.e, m.f);
}



// a simple tracer
void JM_TRACE(const char *id)
{
    PySys_WriteStdout("%s\n", id);
}

// put warnings on Python-stdout
void JM_Warning(const char *id)
{
    PySys_WriteStdout("warning: %s\n", id);
}

#if JM_MEMORY == 1
//-----------------------------------------------------------------------------
// The following 3 functions replace MuPDF standard memory allocation.
// This will ensure, that MuPDF memory handling becomes part of Python's
// memory management.
//-----------------------------------------------------------------------------
static void *JM_Py_Malloc(void *opaque, size_t size)
{
    return PyMem_Malloc(size);
}

static void *JM_Py_Realloc(void *opaque, void *old, size_t size)
{
    return PyMem_Realloc(old, size);
}

static void JM_PY_Free(void *opaque, void *ptr)
{
    PyMem_Free(ptr);
}

const fz_alloc_context JM_Alloc_Context =
{
	NULL,
	JM_Py_Malloc,
	JM_Py_Realloc,
	JM_PY_Free
};
#endif

// return Python bools for a given integer
PyObject *JM_BOOL(int v)
{
    if (v == 0)
        Py_RETURN_FALSE;
    Py_RETURN_TRUE;
}

PyObject *JM_fitz_config()
{
#if defined(TOFU)
#define have_TOFU JM_BOOL(0)
#else
#define have_TOFU JM_BOOL(1)
#endif
#if defined(TOFU_CJK)
#define have_TOFU_CJK JM_BOOL(0)
#else
#define have_TOFU_CJK JM_BOOL(1)
#endif
#if defined(TOFU_CJK_EXT)
#define have_TOFU_CJK_EXT JM_BOOL(0)
#else
#define have_TOFU_CJK_EXT JM_BOOL(1)
#endif
#if defined(TOFU_CJK_LANG)
#define have_TOFU_CJK_LANG JM_BOOL(0)
#else
#define have_TOFU_CJK_LANG JM_BOOL(1)
#endif
#if defined(TOFU_EMOJI)
#define have_TOFU_EMOJI JM_BOOL(0)
#else
#define have_TOFU_EMOJI JM_BOOL(1)
#endif
#if defined(TOFU_HISTORIC)
#define have_TOFU_HISTORIC JM_BOOL(0)
#else
#define have_TOFU_HISTORIC JM_BOOL(1)
#endif
#if defined(TOFU_SYMBOL)
#define have_TOFU_SYMBOL JM_BOOL(0)
#else
#define have_TOFU_SYMBOL JM_BOOL(1)
#endif
#if defined(TOFU_SIL)
#define have_TOFU_SIL JM_BOOL(0)
#else
#define have_TOFU_SIL JM_BOOL(1)
#endif
#if defined(NO_ICC)
#define have_NO_ICC JM_BOOL(0)
#else
#define have_NO_ICC JM_BOOL(1)
#endif
#if defined(TOFU_BASE14)
#define have_TOFU_BASE14 JM_BOOL(0)
#else
#define have_TOFU_BASE14 JM_BOOL(1)
#endif
    PyObject *dict = PyDict_New();
    PyDict_SetItemString(dict, "plotter-g", JM_BOOL(FZ_PLOTTERS_G));
    PyDict_SetItemString(dict, "plotter-rgb", JM_BOOL(FZ_PLOTTERS_RGB));
    PyDict_SetItemString(dict, "plotter-cmyk", JM_BOOL(FZ_PLOTTERS_CMYK));
    PyDict_SetItemString(dict, "plotter-n", JM_BOOL(FZ_PLOTTERS_N));
    PyDict_SetItemString(dict, "pdf", JM_BOOL(FZ_ENABLE_PDF));
    PyDict_SetItemString(dict, "xps", JM_BOOL(FZ_ENABLE_XPS));
    PyDict_SetItemString(dict, "svg", JM_BOOL(FZ_ENABLE_SVG));
    PyDict_SetItemString(dict, "cbz", JM_BOOL(FZ_ENABLE_CBZ));
    PyDict_SetItemString(dict, "img", JM_BOOL(FZ_ENABLE_IMG));
    PyDict_SetItemString(dict, "html", JM_BOOL(FZ_ENABLE_HTML));
    PyDict_SetItemString(dict, "epub", JM_BOOL(FZ_ENABLE_EPUB));
    PyDict_SetItemString(dict, "gprf", JM_BOOL(FZ_ENABLE_GPRF));
    PyDict_SetItemString(dict, "jpx", JM_BOOL(FZ_ENABLE_JPX));
    PyDict_SetItemString(dict, "js", JM_BOOL(FZ_ENABLE_JS));
    PyDict_SetItemString(dict, "tofu", have_TOFU);
    PyDict_SetItemString(dict, "tofu-cjk", have_TOFU_CJK);
    PyDict_SetItemString(dict, "tofu-cjk-ext", have_TOFU_CJK_EXT);
    PyDict_SetItemString(dict, "tofu-cjk-lang", have_TOFU_CJK_LANG);
    PyDict_SetItemString(dict, "tofu-emoji", have_TOFU_EMOJI);
    PyDict_SetItemString(dict, "tofu-historic", have_TOFU_HISTORIC);
    PyDict_SetItemString(dict, "tofu-symbol", have_TOFU_SYMBOL);
    PyDict_SetItemString(dict, "tofu-sil", have_TOFU_SIL);
    PyDict_SetItemString(dict, "icc", have_NO_ICC);
    PyDict_SetItemString(dict, "base14", have_TOFU_BASE14);
    PyDict_SetItemString(dict, "py-memory", JM_BOOL(JM_MEMORY));
    return dict;
}

//----------------------------------------------------------------------------
// Update a color float array with values from a Python sequence.
// Any error condition is treated as a no-op.
//----------------------------------------------------------------------------
void JM_color_FromSequence(PyObject *color, int *n, float col[4])
{
    if (!color) return;
    if (PyFloat_Check(color)) // maybe just a single float
    {
        float c = (float) PyFloat_AsDouble(color);
        if (!INRANGE(c, 0.0f, 1.0f)) return;
        col[0] = c;
        *n = 1;
        return;
    }
    if (!PySequence_Check(color)) return;
    int len = PySequence_Size(color), i;
    if (!INRANGE(len, 1, 4) || len == 2) return;

    float mcol[4] = {0,0,0,0}; // local color storage
    for (i = 0; i < len; i++)
    {
        mcol[i] = (float) PyFloat_AsDouble(PySequence_ITEM(color, i));
        if (PyErr_Occurred())
        {
            PyErr_Clear(); // reset Py error indicator
            return;
        }
        if (!INRANGE(mcol[i], 0.0f, 1.0f)) return;
    }

    *n = len;
    for (i = 0; i < len; i++)
        col[i] = mcol[i];
    return;
}

//----------------------------------------------------------------------------
// Turn fz_buffer into a Python bytes object
//----------------------------------------------------------------------------
PyObject *JM_BinFromBuffer(fz_context *ctx, fz_buffer *buffer)
{
    PyObject *bytes = PyBytes_FromString("");
    char *c = NULL;
    if (buffer)
    {
        size_t len = fz_buffer_storage(gctx, buffer, &c);
        bytes = PyBytes_FromStringAndSize(c, (Py_ssize_t) len);
    }
    return bytes;
}

//----------------------------------------------------------------------------
// Turn fz_buffer into a Python bytearray object
//----------------------------------------------------------------------------
PyObject *JM_BArrayFromBuffer(fz_context *ctx, fz_buffer *buffer)
{
    PyObject *bytes = PyByteArray_FromObject(Py_BuildValue("s", ""));
    char *c = NULL;
    if (buffer)
    {
        size_t len = fz_buffer_storage(ctx, buffer, &c);
        bytes = PyByteArray_FromStringAndSize(c, (Py_ssize_t) len);
    }
    return bytes;
}

//----------------------------------------------------------------------------
// Turn fz_buffer to a base64 encoded bytes object
//----------------------------------------------------------------------------
PyObject *JM_B64FromBuffer(fz_context *ctx, fz_buffer *buffer)
{
    PyObject *bytes = PyBytes_FromString("");
    char *c = NULL;
    char *b64 = NULL;
    if (buffer)
    {
        size_t len = fz_buffer_storage(ctx, buffer, &c);
        fz_buffer *res = fz_new_buffer(ctx, len);
        fz_output *out = fz_new_output_with_buffer(ctx, res);
        fz_write_base64(ctx, out, (const unsigned char *) c, (int) len, 0);
        size_t nlen = fz_buffer_storage(ctx, res, &b64);
        bytes = PyBytes_FromStringAndSize(b64, (Py_ssize_t) nlen);
        fz_drop_buffer(ctx, res);
        fz_drop_output(ctx, out);
    }
    return bytes;
}

//----------------------------------------------------------------------------
// deflate char* into a buffer
// this is a copy of function "deflatebuf" of pdf_write.c
//----------------------------------------------------------------------------
fz_buffer *JM_deflatebuf(fz_context *ctx, unsigned char *p, size_t n)
{
    fz_buffer *buf = NULL;
    uLongf csize;
    int t;
    uLong longN = (uLong) n;
    unsigned char *data = NULL;
    size_t cap;
    fz_try(ctx)
    {
        if (n != (size_t)longN) THROWMSG("buffer too large to deflate");
        cap = compressBound(longN);
        data = fz_malloc(ctx, cap);
        buf = fz_new_buffer_from_data(ctx, data, cap);
        csize = (uLongf)cap;
        t = compress(data, &csize, p, longN);
        if (t != Z_OK) THROWMSG("cannot deflate buffer");
    }
    fz_catch(ctx)
    {
        fz_drop_buffer(ctx, buf);
        fz_rethrow(ctx);
    }
    fz_resize_buffer(ctx, buf, csize);
    return buf;
}

//----------------------------------------------------------------------------
// update a stream object
// compress stream when beneficial
//----------------------------------------------------------------------------
void JM_update_stream(fz_context *ctx, pdf_document *doc, pdf_obj *obj, fz_buffer *buffer)
{
    size_t len, nlen;
    unsigned char *data = NULL;
    fz_buffer *nres = NULL;
    len = fz_buffer_storage(ctx, buffer, &data);
    nlen = len;
    if (len > 20)       // ignore small stuff
    {
        nres = JM_deflatebuf(ctx, data, len);
        nlen = fz_buffer_storage(ctx, nres, NULL);
    }
    if (nlen < len)     // was it worth the effort?
    {
        pdf_dict_put(ctx, obj, PDF_NAME(Filter), PDF_NAME(FlateDecode));
        pdf_update_stream(ctx, doc, obj, nres, 1);
    }
    else
    {
        pdf_update_stream(ctx, doc, obj, buffer, 0);
    }
    fz_drop_buffer(ctx, nres);
}

//-----------------------------------------------------------------------------
// Version of fz_new_pixmap_from_display_list (util.c) to support rendering
// of only the 'clip' part of the displaylist rectangle
//-----------------------------------------------------------------------------
fz_pixmap *
JM_pixmap_from_display_list(fz_context *ctx, fz_display_list *list, PyObject *ctm, fz_colorspace *cs, int alpha, PyObject *clip)
{
    fz_rect rect = fz_bound_display_list(ctx, list);
    fz_matrix matrix = JM_matrix_from_py(ctm);
    fz_pixmap *pix = NULL;
    fz_var(pix);
    fz_device *dev = NULL;
    fz_var(dev);
    fz_separations *seps = NULL;
    fz_rect rclip = JM_rect_from_py(clip);
    rect = fz_intersect_rect(rect, rclip);  // no-op if clip is not given

    rect = fz_transform_rect(rect, matrix);
    fz_irect irect = fz_round_rect(rect);

    pix = fz_new_pixmap_with_bbox(ctx, cs, irect, seps, alpha);
    if (alpha)
        fz_clear_pixmap(ctx, pix);
    else
        fz_clear_pixmap_with_value(ctx, pix, 0xFF);

    fz_try(ctx)
    {
        if (!fz_is_infinite_rect(rclip))
        {
            dev = fz_new_draw_device_with_bbox(ctx, matrix, pix, &irect);
            fz_run_display_list(ctx, list, dev, fz_identity, rclip, NULL);
        }
        else
        {
            dev = fz_new_draw_device(ctx, matrix, pix);
            fz_run_display_list(ctx, list, dev, fz_identity, fz_infinite_rect, NULL);
        }

        fz_close_device(ctx, dev);
    }
    fz_always(ctx)
    {
        fz_drop_device(ctx, dev);
    }
    fz_catch(ctx)
    {
        fz_drop_pixmap(ctx, pix);
        fz_rethrow(ctx);
    }
    return pix;
}

//-----------------------------------------------------------------------------
// return hex characters for n characters in input 'in'
//-----------------------------------------------------------------------------
void hexlify(int n, unsigned char *in, unsigned char *out)
{
    const unsigned char hdigit[17] = "0123456789abcedf";
    int i, i1, i2;
    for (i = 0; i < n; i++)
    {
        i1 = in[i]>>4;
        i2 = in[i] - i1*16;
        out[2*i] = hdigit[i1];
        out[2*i + 1] = hdigit[i2];
    }
    out[2*n] = 0;
}

//----------------------------------------------------------------------------
// Turn a bytes or bytearray object into char* string
// using the "_AsString" functions. Returns string size or 0 on error.
//----------------------------------------------------------------------------
size_t JM_CharFromBytesOrArray(PyObject *stream, char **data)
{
    *data = NULL;
    size_t len = 0;
    if (!stream) return 0;
    if (PyBytes_Check(stream))
    {
        *data = PyBytes_AsString(stream);
        len = (size_t) PyBytes_Size(stream);
    }
    else if (PyByteArray_Check(stream))
    {
        *data = PyByteArray_AsString(stream);
        len = (size_t) PyByteArray_Size(stream);
    }
    return len;
}

//----------------------------------------------------------------------------
// Return fz_buffer from a PyBytes or PyByteArray object
// Attention: must be freed by caller!
//----------------------------------------------------------------------------
fz_buffer *JM_BufferFromBytes(fz_context *ctx, PyObject *stream)
{
    if (!stream) return NULL;
    char *c = NULL;
    size_t len = JM_CharFromBytesOrArray(stream, &c);
    if (!c) return NULL;
    fz_buffer *res = NULL;
    fz_var(res);
    fz_try(ctx)
    {
        res = fz_new_buffer(ctx, len);
        fz_append_data(ctx, res, c, len);
        fz_terminate_buffer(ctx, res);
    }
    fz_catch(ctx)
    {
        fz_drop_buffer(ctx, res);
        fz_rethrow(ctx);
    }
    return res;
}

//----------------------------------------------------------------------------
// Modified copy of SWIG_Python_str_AsChar
// If Py3, the SWIG original v3.0.12 does *not* deliver NULL for a
// non-string input, as does PyString_AsString in Py2.
//----------------------------------------------------------------------------
char *JM_Python_str_AsChar(PyObject *str)
{
    if (!str) return NULL;
#if PY_VERSION_HEX >= 0x03000000
  char *newstr = NULL;
  PyObject *xstr = PyUnicode_AsUTF8String(str);
  if (xstr)
  {
    char *cstr;
    Py_ssize_t len;
    PyBytes_AsStringAndSize(xstr, &cstr, &len);
    size_t l = len + 1;
    newstr = JM_Alloc(char, l);
    memcpy(newstr, cstr, l);
    Py_XDECREF(xstr);
  }
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define JM_Python_str_DelForPy3(x) JM_Free(x)
#else
#  define JM_Python_str_DelForPy3(x) 
#endif

//----------------------------------------------------------------------------
// Deep-copies a specified source page to the target location.
// Modified copy of function of pdfmerge.c: we also copy annotations, but
// we skip **link** annotations. In addition we rotate output.
//----------------------------------------------------------------------------
void page_merge(fz_context *ctx, pdf_document *doc_des, pdf_document *doc_src, int page_from, int page_to, int rotate, pdf_graft_map *graft_map)
{
    pdf_obj *pageref = NULL;
    pdf_obj *page_dict;
    pdf_obj *obj = NULL, *ref = NULL, *subt = NULL;

    // list of object types (per page) we want to copy
    pdf_obj *known_page_objs[] = {PDF_NAME(Contents), PDF_NAME(Resources),
        PDF_NAME(MediaBox), PDF_NAME(CropBox), PDF_NAME(BleedBox), PDF_NAME(Annots),
        PDF_NAME(TrimBox), PDF_NAME(ArtBox), PDF_NAME(Rotate), PDF_NAME(UserUnit)};
    int n = nelem(known_page_objs);                   // number of list elements
    int i;
    int num, j;
    fz_var(obj);
    fz_var(ref);

    fz_try(ctx)
    {
        pageref = pdf_lookup_page_obj(ctx, doc_src, page_from);
        pdf_flatten_inheritable_page_items(ctx, pageref);
        // make a new page
        page_dict = pdf_new_dict(ctx, doc_des, 4);
        pdf_dict_put_drop(ctx, page_dict, PDF_NAME(Type), PDF_NAME(Page));

        // copy objects of source page into it
        for (i = 0; i < n; i++)
            {
            obj = pdf_dict_get(ctx, pageref, known_page_objs[i]);
            if (obj != NULL)
                pdf_dict_put_drop(ctx, page_dict, known_page_objs[i], pdf_graft_mapped_object(ctx, graft_map, obj));
            }
        // remove any links from annots array
        pdf_obj *annots = pdf_dict_get(ctx, page_dict, PDF_NAME(Annots));
        int len = pdf_array_len(ctx, annots);
        for (j = 0; j < len; j++)
        {
            pdf_obj *o = pdf_array_get(ctx, annots, j);
            if (!pdf_name_eq(ctx, pdf_dict_get(ctx, o, PDF_NAME(Subtype)), PDF_NAME(Link)))
                continue;
            // remove the link annotation
            pdf_array_delete(ctx, annots, j);
            len--;
            j--;
        }
        // rotate the page as requested
        if (rotate != -1)
            {
            pdf_obj *rotateobj = pdf_new_int(ctx, (int64_t) rotate);
            pdf_dict_put_drop(ctx, page_dict, PDF_NAME(Rotate), rotateobj);
            }
        // Now add the page dictionary to dest PDF
        obj = pdf_add_object_drop(ctx, doc_des, page_dict);

        // Get indirect ref of the page
        num = pdf_to_num(ctx, obj);
        ref = pdf_new_indirect(ctx, doc_des, num, 0);

        // Insert new page at specified location
        pdf_insert_page(ctx, doc_des, page_to, ref);

    }
    fz_always(ctx)
    {
        pdf_drop_obj(ctx, obj);
        pdf_drop_obj(ctx, ref);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}

//-----------------------------------------------------------------------------
// Copy a range of pages (spage, epage) from a source PDF to a specified
// location (apage) of the target PDF.
// If spage > epage, the sequence of source pages is reversed.
//-----------------------------------------------------------------------------
void merge_range(fz_context *ctx, pdf_document *doc_des, pdf_document *doc_src, int spage, int epage, int apage, int rotate)
{
    int page, afterpage, count;
    pdf_graft_map *graft_map;
    afterpage = apage;
    count = pdf_count_pages(ctx, doc_src);
    graft_map = pdf_new_graft_map(ctx, doc_des);

    fz_try(ctx)
    {
        if (spage < epage)
            for (page = spage; page <= epage; page++, afterpage++)
                page_merge(ctx, doc_des, doc_src, page, afterpage, rotate, graft_map);
        else
            for (page = spage; page >= epage; page--, afterpage++)
                page_merge(ctx, doc_des, doc_src, page, afterpage, rotate, graft_map);
    }

    fz_always(ctx)
    {
        pdf_drop_graft_map(ctx, graft_map);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}

//----------------------------------------------------------------------------
// Return list of outline xref numbers. Recursive function. Arguments:
// 'obj' first OL item
// 'xrefs' empty Python list
//----------------------------------------------------------------------------
PyObject *JM_outline_xrefs(fz_context *ctx, pdf_obj *obj, PyObject *xrefs)
{
    pdf_obj *first, *parent, *thisobj;
    if (!obj) return xrefs;
    thisobj = obj;
    while (thisobj)
    {
        PyList_Append(xrefs, Py_BuildValue("i", pdf_to_num(ctx, thisobj)));
        first = pdf_dict_get(ctx, thisobj, PDF_NAME(First));   // try go down
        if (first) xrefs = JM_outline_xrefs(ctx, first, xrefs);
        thisobj = pdf_dict_get(ctx, thisobj, PDF_NAME(Next));  // try go next
        parent = pdf_dict_get(ctx, thisobj, PDF_NAME(Parent)); // get parent
        if (!thisobj) thisobj = parent;      /* goto parent if no next exists */
    }
    return xrefs;
}

//-----------------------------------------------------------------------------
// Return the contents of a font file
//-----------------------------------------------------------------------------
fz_buffer *fontbuffer(fz_context *ctx, pdf_document *doc, int xref)
{
    if (xref < 1) return NULL;
    pdf_obj *o, *obj = NULL, *desft, *stream = NULL;
    char *ext = "";
    o = pdf_load_object(ctx, doc, xref);
    desft = pdf_dict_get(ctx, o, PDF_NAME(DescendantFonts));
    if (desft)
    {
        obj = pdf_resolve_indirect(ctx, pdf_array_get(ctx, desft, 0));
        obj = pdf_dict_get(ctx, obj, PDF_NAME(FontDescriptor));
    }
    else
        obj = pdf_dict_get(ctx, o, PDF_NAME(FontDescriptor));

    if (!obj)
    {
        pdf_drop_obj(ctx, o);
        PySys_WriteStdout("invalid font - FontDescriptor missing");
        return NULL;
    }
    pdf_drop_obj(ctx, o);
    o = obj;

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile));
    if (obj) stream = obj;             // ext = "pfa"

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile2));
    if (obj) stream = obj;             // ext = "ttf"

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile3));
    if (obj)
    {
        stream = obj;

        obj = pdf_dict_get(ctx, obj, PDF_NAME(Subtype));
        if (obj && !pdf_is_name(ctx, obj))
        {
            PySys_WriteStdout("invalid font descriptor subtype");
            return NULL;
        }

        if (pdf_name_eq(ctx, obj, PDF_NAME(Type1C)))
            ext = "cff";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(CIDFontType0C)))
            ext = "cid";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(OpenType)))
            ext = "otf";
        else
            PySys_WriteStdout("warning: unhandled font type '%s'", pdf_to_name(ctx, obj));
    }

    if (!stream)
    {
        PySys_WriteStdout("warning: unhandled font type");
        return NULL;
    }

    return pdf_load_stream(ctx, stream);
}

//-----------------------------------------------------------------------------
// Return the file extension of an embedded font file
//-----------------------------------------------------------------------------
char *fontextension(fz_context *ctx, pdf_document *doc, int xref)
{
    if (xref < 1) return "n/a";
    pdf_obj *o, *obj = NULL, *desft;
    o = pdf_load_object(ctx, doc, xref);
    desft = pdf_dict_get(ctx, o, PDF_NAME(DescendantFonts));
    if (desft)
    {
        obj = pdf_resolve_indirect(ctx, pdf_array_get(ctx, desft, 0));
        obj = pdf_dict_get(ctx, obj, PDF_NAME(FontDescriptor));
    }
    else
        obj = pdf_dict_get(ctx, o, PDF_NAME(FontDescriptor));

    pdf_drop_obj(ctx, o);
    if (!obj) return "n/a";           // this is a base-14 font

    o = obj;                           // we have the FontDescriptor

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile));
    if (obj) return "pfa";

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile2));
    if (obj) return "ttf";

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile3));
    if (obj)
    {
        obj = pdf_dict_get(ctx, obj, PDF_NAME(Subtype));
        if (obj && !pdf_is_name(ctx, obj))
        {
            PySys_WriteStdout("invalid font descriptor subtype");
            return "n/a";
        }
        if (pdf_name_eq(ctx, obj, PDF_NAME(Type1C)))
            return "cff";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(CIDFontType0C)))
            return "cid";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(OpenType)))
            return "otf";
        else
            PySys_WriteStdout("unhandled font type '%s'", pdf_to_name(ctx, obj));
    }

    return "n/a";
}

//-----------------------------------------------------------------------------
// create PDF object from given string (new in v1.14.0: MuPDF dropped it)
//-----------------------------------------------------------------------------
pdf_obj *JM_pdf_obj_from_str(fz_context *ctx, pdf_document *doc, char *src)
{
    pdf_obj *result = NULL;
    pdf_lexbuf lexbuf;
    fz_stream *stream = fz_open_memory(ctx, (unsigned char *)src, strlen(src));

    pdf_lexbuf_init(ctx, &lexbuf, PDF_LEXBUF_SMALL);

    fz_try(ctx)
        result = pdf_parse_stm_obj(ctx, doc, stream, &lexbuf);

    fz_always(ctx)
    {
        pdf_lexbuf_fin(ctx, &lexbuf);
        fz_drop_stream(ctx, stream);
    }

    fz_catch(ctx)
        fz_rethrow(ctx);

    return result;

}

//-----------------------------------------------------------------------------
// dummy structure for various tools and utilities
//-----------------------------------------------------------------------------
struct Tools {int index;};

typedef struct fz_item_s fz_item;

struct fz_item_s
{
	void *key;
	fz_storable *val;
	size_t size;
	fz_item *next;
	fz_item *prev;
	fz_store *store;
	const fz_store_type *type;
};

struct fz_store_s
{
	int refs;

	/* Every item in the store is kept in a doubly linked list, ordered
	 * by usage (so LRU entries are at the end). */
	fz_item *head;
	fz_item *tail;

	/* We have a hash table that allows to quickly find a subset of the
	 * entries (those whose keys are indirect objects). */
	fz_hash_table *hash;

	/* We keep track of the size of the store, and keep it below max. */
	size_t max;
	size_t size;

	int defer_reap_count;
	int needs_reaping;
};



//-----------------------------------------------------------------------------
// Create an fz_output which writes to a Python ByteArray
//-----------------------------------------------------------------------------
PyObject *JM_output_log;
PyObject *JM_error_log;

static void
JM_WriteBarray(fz_context *ctx, PyObject *barray, const void *buffer, size_t count)
{
    if (!buffer || count < 1) return;
    PyObject *c = PyByteArray_FromStringAndSize((const char *)buffer, (Py_ssize_t) count);
    if (!c || c == NONE) return;
    PyObject *old = barray;                 // save for Py_DECREFing
    barray = PySequence_InPlaceConcat(barray, c);
    Py_DECREF(c);
    Py_DECREF(old);
    return;
}

static void
JM_SeekDummy(fz_context *ctx, void *opaque, int64_t off, int whence)
{   // ignore seeks
    return;
}

static int64_t
JM_TellBarray(fz_context *ctx, PyObject *barray)
{
    return (int64_t) PyByteArray_Size(barray);
}

fz_output *JM_OutFromBarray(fz_context *ctx, PyObject *barray)
{
    fz_output *out = fz_new_output(ctx, 0, barray, JM_WriteBarray, NULL, NULL);
    out->seek = JM_SeekDummy;
    out->tell = JM_TellBarray;
    return out;
}


void pdf_dict_put_val_null(fz_context *ctx, pdf_obj *obj, int idx);

#include <assert.h>
#include <limits.h>
#include <string.h>

#define SIG_EXTRAS_SIZE (1024)

typedef struct pdf_write_state_s pdf_write_state;

/*
    As part of linearization, we need to keep a list of what objects are used
    by what page. We do this by recording the objects used in a given page
    in a page_objects structure. We have a list of these structures (one per
    page) in the page_objects_list structure.

    The page_objects structure maintains a heap in the object array, so
    insertion takes log n time, and we can heapsort and dedupe at the end for
    a total worse case n log n time.

    The magic heap invariant is that:
        entry[n] >= entry[(n+1)*2-1] & entry[n] >= entry[(n+1)*2]
    or equivalently:
        entry[(n-1)>>1] >= entry[n]

    For a discussion of the heap data structure (and heapsort) see Kingston,
    "Algorithms and Data Structures".
*/

typedef struct {
    int num_shared;
    int page_object_number;
    int num_objects;
    int min_ofs;
    int max_ofs;
    /* Extensible list of objects used on this page */
    int cap;
    int len;
    int object[1];
} page_objects;

typedef struct {
    int cap;
    int len;
    page_objects *page[1];
} page_objects_list;

struct pdf_write_state_s
{
    fz_output *out;

    int do_incremental;
    int do_tight;
    int do_ascii;
    int do_expand;
    int do_compress;
    int do_compress_images;
    int do_compress_fonts;
    int do_garbage;
    int do_linear;
    int do_clean;

    int list_len;
    int *use_list;
    int64_t *ofs_list;
    int *gen_list;
    int *renumber_map;
    int continue_on_error;
    int *errors;
    /* The following extras are required for linearization */
    int *rev_renumber_map;
    int start;
    int64_t first_xref_offset;
    int64_t main_xref_offset;
    int64_t first_xref_entry_offset;
    int64_t file_len;
    int hints_shared_offset;
    int hintstream_len;
    pdf_obj *linear_l;
    pdf_obj *linear_h0;
    pdf_obj *linear_h1;
    pdf_obj *linear_o;
    pdf_obj *linear_e;
    pdf_obj *linear_n;
    pdf_obj *linear_t;
    pdf_obj *hints_s;
    pdf_obj *hints_length;
    int page_count;
    page_objects_list *page_object_lists;
    int crypt_object_number;
};

/*
 * Constants for use with use_list.
 *
 * If use_list[num] = 0, then object num is unused.
 * If use_list[num] & PARAMS, then object num is the linearisation params obj.
 * If use_list[num] & CATALOGUE, then object num is used by the catalogue.
 * If use_list[num] & PAGE1, then object num is used by page 1.
 * If use_list[num] & SHARED, then object num is shared between pages.
 * If use_list[num] & PAGE_OBJECT then this must be the first object in a page.
 * If use_list[num] & OTHER_OBJECTS then this must should appear in section 9.
 * Otherwise object num is used by page (use_list[num]>>USE_PAGE_SHIFT).
 */
enum
{
    USE_CATALOGUE = 2,
    USE_PAGE1 = 4,
    USE_SHARED = 8,
    USE_PARAMS = 16,
    USE_HINTS = 32,
    USE_PAGE_OBJECT = 64,
    USE_OTHER_OBJECTS = 128,
    USE_PAGE_MASK = ~255,
    USE_PAGE_SHIFT = 8
};

/*
 * page_objects and page_object_list handling functions
 */
static page_objects_list *
page_objects_list_create(fz_context *ctx)
{
    page_objects_list *pol = fz_calloc(ctx, 1, sizeof(*pol));

    pol->cap = 1;
    pol->len = 0;
    return pol;
}

static void
page_objects_list_destroy(fz_context *ctx, page_objects_list *pol)
{
    int i;

    if (!pol)
        return;
    for (i = 0; i < pol->len; i++)
    {
        fz_free(ctx, pol->page[i]);
    }
    fz_free(ctx, pol);
}

static void
page_objects_list_ensure(fz_context *ctx, page_objects_list **pol, int newcap)
{
    int oldcap = (*pol)->cap;
    if (newcap <= oldcap)
        return;
    *pol = fz_resize_array(ctx, *pol, 1, sizeof(page_objects_list) + (newcap-1)*sizeof(page_objects *));
    memset(&(*pol)->page[oldcap], 0, (newcap-oldcap)*sizeof(page_objects *));
    (*pol)->cap = newcap;
}

static page_objects *
page_objects_create(fz_context *ctx)
{
    int initial_cap = 8;
    page_objects *po = fz_calloc(ctx, 1, sizeof(*po) + (initial_cap-1) * sizeof(int));

    po->cap = initial_cap;
    po->len = 0;
    return po;
}

static void
page_objects_insert(fz_context *ctx, page_objects **ppo, int i)
{
    page_objects *po;

    /* Make a page_objects if we don't have one */
    if (*ppo == NULL)
        *ppo = page_objects_create(ctx);

    po = *ppo;
    /* page_objects insertion: extend the page_objects by 1, and put us on the end */
    if (po->len == po->cap)
    {
        po = fz_resize_array(ctx, po, 1, sizeof(page_objects) + (po->cap*2 - 1)*sizeof(int));
        po->cap *= 2;
        *ppo = po;
    }
    po->object[po->len++] = i;
}

static void
page_objects_list_insert(fz_context *ctx, pdf_write_state *opts, int page, int object)
{
    page_objects_list_ensure(ctx, &opts->page_object_lists, page+1);
    if (opts->page_object_lists->len < page+1)
        opts->page_object_lists->len = page+1;
    page_objects_insert(ctx, &opts->page_object_lists->page[page], object);
}

static void
page_objects_list_set_page_object(fz_context *ctx, pdf_write_state *opts, int page, int object)
{
    page_objects_list_ensure(ctx, &opts->page_object_lists, page+1);
    opts->page_object_lists->page[page]->page_object_number = object;
}

static void
page_objects_sort(fz_context *ctx, page_objects *po)
{
    int i, j;
    int n = po->len;

    /* Step 1: Make a heap */
    /* Invariant: Valid heap in [0..i), unsorted elements in [i..n) */
    for (i = 1; i < n; i++)
    {
        /* Now bubble backwards to maintain heap invariant */
        j = i;
        while (j != 0)
        {
            int tmp;
            int k = (j-1)>>1;
            if (po->object[k] >= po->object[j])
                break;
            tmp = po->object[k];
            po->object[k] = po->object[j];
            po->object[j] = tmp;
            j = k;
        }
    }

    /* Step 2: Heap sort */
    /* Invariant: valid heap in [0..i), sorted list in [i..n) */
    /* Initially: i = n */
    for (i = n-1; i > 0; i--)
    {
        /* Swap the maximum (0th) element from the page_objects into its place
         * in the sorted list (position i). */
        int tmp = po->object[0];
        po->object[0] = po->object[i];
        po->object[i] = tmp;
        /* Now, the page_objects is invalid because the 0th element is out
         * of place. Bubble it until the page_objects is valid. */
        j = 0;
        while (1)
        {
            /* Children are k and k+1 */
            int k = (j+1)*2-1;
            /* If both children out of the page_objects, we're done */
            if (k > i-1)
                break;
            /* If both are in the page_objects, pick the larger one */
            if (k < i-1 && po->object[k] < po->object[k+1])
                k++;
            /* If j is bigger than k (i.e. both of its children),
             * we're done */
            if (po->object[j] > po->object[k])
                break;
            tmp = po->object[k];
            po->object[k] = po->object[j];
            po->object[j] = tmp;
            j = k;
        }
    }
}

static int
order_ge(int ui, int uj)
{
    /*
    For linearization, we need to order the sections as follows:

        Remaining pages                    (Part 7)
        Shared objects                    (Part 8)
        Objects not associated with any page        (Part 9)
        Any "other" objects
                            (Header)(Part 1)
        (Linearization params)                (Part 2)
                    (1st page Xref/Trailer)    (Part 3)
        Catalogue (and other document level objects)    (Part 4)
        First page                    (Part 6)
        (Primary Hint stream)            (*)    (Part 5)
        Any free objects

    Note, this is NOT the same order they appear in
    the final file!

    (*) The PDF reference gives us the option of putting the hint stream
    after the first page, and we take it, for simplicity.
    */

    /* If the 2 objects are in the same section, then page object comes first. */
    if (((ui ^ uj) & ~USE_PAGE_OBJECT) == 0)
        return ((ui & USE_PAGE_OBJECT) == 0);
    /* Put unused objects last */
    else if (ui == 0)
        return 1;
    else if (uj == 0)
        return 0;
    /* Put the hint stream before that... */
    else if (ui & USE_HINTS)
        return 1;
    else if (uj & USE_HINTS)
        return 0;
    /* Put page 1 before that... */
    else if (ui & USE_PAGE1)
        return 1;
    else if (uj & USE_PAGE1)
        return 0;
    /* Put the catalogue before that... */
    else if (ui & USE_CATALOGUE)
        return 1;
    else if (uj & USE_CATALOGUE)
        return 0;
    /* Put the linearization params before that... */
    else if (ui & USE_PARAMS)
        return 1;
    else if (uj & USE_PARAMS)
        return 0;
    /* Put other objects before that */
    else if (ui & USE_OTHER_OBJECTS)
        return 1;
    else if (uj & USE_OTHER_OBJECTS)
        return 0;
    /* Put shared objects before that... */
    else if (ui & USE_SHARED)
        return 1;
    else if (uj & USE_SHARED)
        return 0;
    /* And otherwise, order by the page number on which
     * they are used. */
    return (ui>>USE_PAGE_SHIFT) >= (uj>>USE_PAGE_SHIFT);
}

static void
heap_sort(int *list, int n, const int *val, int (*ge)(int, int))
{
    int i, j;

    /* Step 1: Make a heap */
    /* Invariant: Valid heap in [0..i), unsorted elements in [i..n) */
    for (i = 1; i < n; i++)
    {
        /* Now bubble backwards to maintain heap invariant */
        j = i;
        while (j != 0)
        {
            int tmp;
            int k = (j-1)>>1;
            if (ge(val[list[k]], val[list[j]]))
                break;
            tmp = list[k];
            list[k] = list[j];
            list[j] = tmp;
            j = k;
        }
    }

    /* Step 2: Heap sort */
    /* Invariant: valid heap in [0..i), sorted list in [i..n) */
    /* Initially: i = n */
    for (i = n-1; i > 0; i--)
    {
        /* Swap the maximum (0th) element from the page_objects into its place
         * in the sorted list (position i). */
        int tmp = list[0];
        list[0] = list[i];
        list[i] = tmp;
        /* Now, the page_objects is invalid because the 0th element is out
         * of place. Bubble it until the page_objects is valid. */
        j = 0;
        while (1)
        {
            /* Children are k and k+1 */
            int k = (j+1)*2-1;
            /* If both children out of the page_objects, we're done */
            if (k > i-1)
                break;
            /* If both are in the page_objects, pick the larger one */
            if (k < i-1 && ge(val[list[k+1]], val[list[k]]))
                k++;
            /* If j is bigger than k (i.e. both of its children),
             * we're done */
            if (ge(val[list[j]], val[list[k]]))
                break;
            tmp = list[k];
            list[k] = list[j];
            list[j] = tmp;
            j = k;
        }
    }
}

static void
page_objects_dedupe(fz_context *ctx, page_objects *po)
{
    int i, j;
    int n = po->len-1;

    for (i = 0; i < n; i++)
    {
        if (po->object[i] == po->object[i+1])
            break;
    }
    j = i; /* j points to the last valid one */
    i++; /* i points to the first one we haven't looked at */
    for (; i < n; i++)
    {
        if (po->object[j] != po->object[i])
            po->object[++j] = po->object[i];
    }
    po->len = j+1;
}

static void
page_objects_list_sort_and_dedupe(fz_context *ctx, page_objects_list *pol)
{
    int i;
    int n = pol->len;

    for (i = 0; i < n; i++)
    {
        page_objects_sort(ctx, pol->page[i]);
        page_objects_dedupe(ctx, pol->page[i]);
    }
}

/*
 * Garbage collect objects not reachable from the trailer.
 */

/* Mark a reference. If it's been marked already, return NULL (as no further
 * processing is required). If it's not, return the resolved object so
 * that we can continue our recursive marking. If it's a duff reference
 * return the fact so that we can remove the reference at source.
 */
static pdf_obj *markref(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_obj *obj, int *duff)
{
    int num = pdf_to_num(ctx, obj);

    if (num <= 0 || num >= pdf_xref_len(ctx, doc))
    {
        *duff = 1;
        return NULL;
    }
    *duff = 0;
    if (opts->use_list[num])
        return NULL;

    opts->use_list[num] = 1;

    /* Bake in /Length in stream objects */
    fz_try(ctx)
    {
        if (pdf_obj_num_is_stream(ctx, doc, num))
        {
            pdf_obj *len = pdf_dict_get(ctx, obj, PDF_NAME(Length));
            if (pdf_is_indirect(ctx, len))
            {
                opts->use_list[pdf_to_num(ctx, len)] = 0;
                len = pdf_resolve_indirect(ctx, len);
                pdf_dict_put(ctx, obj, PDF_NAME(Length), len);
            }
        }
    }
    fz_catch(ctx)
    {
        fz_rethrow_if(ctx, FZ_ERROR_TRYLATER);
        /* Leave broken */
    }

    obj = pdf_resolve_indirect(ctx, obj);
    if (obj == NULL || pdf_is_null(ctx, obj))
    {
        *duff = 1;
        opts->use_list[num] = 0;
    }

    return obj;
}

#ifdef DEBUG_MARK_AND_SWEEP
static int depth = 0;

static
void indent()
{
    while (depth > 0)
    {
        int d  = depth;
        if (d > 16)
            d = 16;
        printf("%s", &"                "[16-d]);
        depth -= d;
    }
}
#define DEBUGGING_MARKING(A) do { A; } while (0)
#else
#define DEBUGGING_MARKING(A) do { } while (0)
#endif

/* Recursively mark an object. If any references found are duff, then
 * replace them with nulls. */
static int markobj(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_obj *obj)
{
    int i;

    DEBUGGING_MARKING(depth++);

    while (pdf_is_indirect(ctx, obj))
    {
        int duff;
        DEBUGGING_MARKING(indent(); printf("Marking object %d\n", pdf_to_num(ctx, obj)));
        obj = markref(ctx, doc, opts, obj, &duff);
        if (duff)
        {
            DEBUGGING_MARKING(depth--);
            return 1;
        }
    }

    if (pdf_is_dict(ctx, obj))
    {
        int n = pdf_dict_len(ctx, obj);
        for (i = 0; i < n; i++)
        {
            DEBUGGING_MARKING(indent(); printf("DICT[%d/%d] = %s\n", i, n, pdf_to_name(ctx, pdf_dict_get_key(ctx, obj, i))));
            if (markobj(ctx, doc, opts, pdf_dict_get_val(ctx, obj, i)))
                pdf_dict_put_val_null(ctx, obj, i);
        }
    }

    else if (pdf_is_array(ctx, obj))
    {
        int n = pdf_array_len(ctx, obj);
        for (i = 0; i < n; i++)
        {
            DEBUGGING_MARKING(indent(); printf("ARRAY[%d/%d]\n", i, n));
            if (markobj(ctx, doc, opts, pdf_array_get(ctx, obj, i)))
                pdf_array_put(ctx, obj, i, PDF_NULL);
        }
    }

    DEBUGGING_MARKING(depth--);

    return 0;
}

static void
expand_lists(fz_context *ctx, pdf_write_state *opts, int num)
{
    int i;

    /* objects are numbered 0..num and maybe two additional objects for linearization */
    num += 3;
    opts->use_list = fz_resize_array(ctx, opts->use_list, num, sizeof(*opts->use_list));
    opts->ofs_list = fz_resize_array(ctx, opts->ofs_list, num, sizeof(*opts->ofs_list));
    opts->gen_list = fz_resize_array(ctx, opts->gen_list, num, sizeof(*opts->gen_list));
    opts->renumber_map = fz_resize_array(ctx, opts->renumber_map, num, sizeof(*opts->renumber_map));
    opts->rev_renumber_map = fz_resize_array(ctx, opts->rev_renumber_map, num, sizeof(*opts->rev_renumber_map));

    for (i = opts->list_len; i < num; i++)
    {
        opts->use_list[i] = 0;
        opts->ofs_list[i] = 0;
        opts->gen_list[i] = 0;
        opts->renumber_map[i] = i;
        opts->rev_renumber_map[i] = i;
    }
    opts->list_len = num;
}

/*
 * Scan for and remove duplicate objects (slow)
 */

static void removeduplicateobjs(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)
{
    int num, other, max_num;
    int xref_len = pdf_xref_len(ctx, doc);

    for (num = 1; num < xref_len; num++)
    {
        /* Only compare an object to objects preceding it */
        for (other = 1; other < num; other++)
        {
            pdf_obj *a, *b;
            int newnum, streama = 0, streamb = 0, differ = 0;

            if (num == other || !opts->use_list[num] || !opts->use_list[other])
                continue;

            /* TODO: resolve indirect references to see if we can omit them */

            /*
             * Comparing stream objects data contents would take too long.
             *
             * pdf_obj_num_is_stream calls pdf_cache_object and ensures
             * that the xref table has the objects loaded.
             */
            fz_try(ctx)
            {
                streama = pdf_obj_num_is_stream(ctx, doc, num);
                streamb = pdf_obj_num_is_stream(ctx, doc, other);
                differ = streama || streamb;
                if (streama && streamb && opts->do_garbage >= 4)
                    differ = 0;
            }
            fz_catch(ctx)
            {
                /* Assume different */
                differ = 1;
            }
            if (differ)
                continue;

            a = pdf_get_xref_entry(ctx, doc, num)->obj;
            b = pdf_get_xref_entry(ctx, doc, other)->obj;

            if (pdf_objcmp(ctx, a, b))
                continue;

            if (streama && streamb)
            {
                /* Check to see if streams match too. */
                fz_buffer *sa = NULL;
                fz_buffer *sb = NULL;

                fz_var(sa);
                fz_var(sb);

                differ = 1;
                fz_try(ctx)
                {
                    unsigned char *dataa, *datab;
                    size_t lena, lenb;
                    sa = pdf_load_raw_stream_number(ctx, doc, num);
                    sb = pdf_load_raw_stream_number(ctx, doc, other);
                    lena = fz_buffer_storage(ctx, sa, &dataa);
                    lenb = fz_buffer_storage(ctx, sb, &datab);
                    if (lena == lenb && memcmp(dataa, datab, lena) == 0)
                        differ = 0;
                }
                fz_always(ctx)
                {
                    fz_drop_buffer(ctx, sa);
                    fz_drop_buffer(ctx, sb);
                }
                fz_catch(ctx)
                {
                    fz_rethrow(ctx);
                }
                if (differ)
                    continue;
            }

            /* Keep the lowest numbered object */
            newnum = fz_mini(num, other);
            max_num = fz_maxi(num, other);
            if (max_num >= opts->list_len)
                expand_lists(ctx, opts, max_num);
            opts->renumber_map[num] = newnum;
            opts->renumber_map[other] = newnum;
            opts->rev_renumber_map[newnum] = num; /* Either will do */
            opts->use_list[fz_maxi(num, other)] = 0;

            /* One duplicate was found, do not look for another */
            break;
        }
    }
}

/*
 * Renumber objects sequentially so the xref is more compact
 *
 * This code assumes that any opts->renumber_map[n] <= n for all n.
 */

static void compactxref(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)
{
    int num, newnum;
    int xref_len = pdf_xref_len(ctx, doc);

    /*
     * Update renumber_map in-place, clustering all used
     * objects together at low object ids. Objects that
     * already should be renumbered will have their new
     * object ids be updated to reflect the compaction.
     */

    if (xref_len > opts->list_len)
        expand_lists(ctx, opts, xref_len-1);

    newnum = 1;
    for (num = 1; num < xref_len; num++)
    {
        /* If it's not used, map it to zero */
        if (!opts->use_list[opts->renumber_map[num]])
        {
            opts->renumber_map[num] = 0;
        }
        /* If it's not moved, compact it. */
        else if (opts->renumber_map[num] == num)
        {
            opts->rev_renumber_map[newnum] = opts->rev_renumber_map[num];
            opts->renumber_map[num] = newnum++;
        }
        /* Otherwise it's used, and moved. We know that it must have
         * moved down, so the place it's moved to will be in the right
         * place already. */
        else
        {
            opts->renumber_map[num] = opts->renumber_map[opts->renumber_map[num]];
        }
    }
}

/*
 * Update indirect objects according to renumbering established when
 * removing duplicate objects and compacting the xref.
 */

static void renumberobj(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_obj *obj)
{
    int i;
    int xref_len = pdf_xref_len(ctx, doc);

    if (pdf_is_dict(ctx, obj))
    {
        int n = pdf_dict_len(ctx, obj);
        for (i = 0; i < n; i++)
        {
            pdf_obj *key = pdf_dict_get_key(ctx, obj, i);
            pdf_obj *val = pdf_dict_get_val(ctx, obj, i);
            if (pdf_is_indirect(ctx, val))
            {
                int o = pdf_to_num(ctx, val);
                if (o >= xref_len || o <= 0 || opts->renumber_map[o] == 0)
                    val = PDF_NULL;
                else
                    val = pdf_new_indirect(ctx, doc, opts->renumber_map[o], 0);
                pdf_dict_put_drop(ctx, obj, key, val);
            }
            else
            {
                renumberobj(ctx, doc, opts, val);
            }
        }
    }

    else if (pdf_is_array(ctx, obj))
    {
        int n = pdf_array_len(ctx, obj);
        for (i = 0; i < n; i++)
        {
            pdf_obj *val = pdf_array_get(ctx, obj, i);
            if (pdf_is_indirect(ctx, val))
            {
                int o = pdf_to_num(ctx, val);
                if (o >= xref_len || o <= 0 || opts->renumber_map[o] == 0)
                    val = PDF_NULL;
                else
                    val = pdf_new_indirect(ctx, doc, opts->renumber_map[o], 0);
                pdf_array_put_drop(ctx, obj, i, val);
            }
            else
            {
                renumberobj(ctx, doc, opts, val);
            }
        }
    }
}

static void renumberobjs(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)
{
    pdf_xref_entry *newxref = NULL;
    int newlen;
    int num;
    int *new_use_list;
    int xref_len = pdf_xref_len(ctx, doc);

    new_use_list = fz_calloc(ctx, pdf_xref_len(ctx, doc)+3, sizeof(int));

    fz_var(newxref);
    fz_try(ctx)
    {
        /* Apply renumber map to indirect references in all objects in xref */
        renumberobj(ctx, doc, opts, pdf_trailer(ctx, doc));
        for (num = 0; num < xref_len; num++)
        {
            pdf_obj *obj;
            int to = opts->renumber_map[num];

            /* If object is going to be dropped, don't bother renumbering */
            if (to == 0)
                continue;

            obj = pdf_get_xref_entry(ctx, doc, num)->obj;

            if (pdf_is_indirect(ctx, obj))
            {
                obj = pdf_new_indirect(ctx, doc, to, 0);
                fz_try(ctx)
                    pdf_update_object(ctx, doc, num, obj);
                fz_always(ctx)
                    pdf_drop_obj(ctx, obj);
                fz_catch(ctx)
                    fz_rethrow(ctx);
            }
            else
            {
                renumberobj(ctx, doc, opts, obj);
            }
        }

        /* Create new table for the reordered, compacted xref */
        newxref = fz_malloc_array(ctx, xref_len + 3, sizeof(pdf_xref_entry));
        newxref[0] = *pdf_get_xref_entry(ctx, doc, 0);

        /* Move used objects into the new compacted xref */
        newlen = 0;
        for (num = 1; num < xref_len; num++)
        {
            if (opts->use_list[num])
            {
                pdf_xref_entry *e;
                if (newlen < opts->renumber_map[num])
                    newlen = opts->renumber_map[num];
                e = pdf_get_xref_entry(ctx, doc, num);
                newxref[opts->renumber_map[num]] = *e;
                if (e->obj)
                {
                    pdf_set_obj_parent(ctx, e->obj, opts->renumber_map[num]);
                    e->obj = NULL;
                }
                new_use_list[opts->renumber_map[num]] = opts->use_list[num];
            }
            else
            {
                pdf_xref_entry *e = pdf_get_xref_entry(ctx, doc, num);
                pdf_drop_obj(ctx, e->obj);
                e->obj = NULL;
                fz_drop_buffer(ctx, e->stm_buf);
                e->stm_buf = NULL;
            }
        }

        pdf_replace_xref(ctx, doc, newxref, newlen + 1);
        newxref = NULL;
    }
    fz_catch(ctx)
    {
        fz_free(ctx, newxref);
        fz_free(ctx, new_use_list);
        fz_rethrow(ctx);
    }
    fz_free(ctx, opts->use_list);
    opts->use_list = new_use_list;

    for (num = 1; num < xref_len; num++)
    {
        opts->renumber_map[num] = num;
    }
}

static void page_objects_list_renumber(pdf_write_state *opts)
{
    int i, j;

    for (i = 0; i < opts->page_object_lists->len; i++)
    {
        page_objects *po = opts->page_object_lists->page[i];
        for (j = 0; j < po->len; j++)
        {
            po->object[j] = opts->renumber_map[po->object[j]];
        }
        po->page_object_number = opts->renumber_map[po->page_object_number];
    }
}

static void
mark_all(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_obj *val, int flag, int page)
{
    if (pdf_mark_obj(ctx, val))
        return;

    fz_try(ctx)
    {
        if (pdf_is_indirect(ctx, val))
        {
            int num = pdf_to_num(ctx, val);
            if (opts->use_list[num] & USE_PAGE_MASK)
                /* Already used */
                opts->use_list[num] |= USE_SHARED;
            else
                opts->use_list[num] |= flag;
            if (page >= 0)
                page_objects_list_insert(ctx, opts, page, num);
        }

        if (pdf_is_dict(ctx, val))
        {
            int i, n = pdf_dict_len(ctx, val);

            for (i = 0; i < n; i++)
            {
                mark_all(ctx, doc, opts, pdf_dict_get_val(ctx, val, i), flag, page);
            }
        }
        else if (pdf_is_array(ctx, val))
        {
            int i, n = pdf_array_len(ctx, val);

            for (i = 0; i < n; i++)
            {
                mark_all(ctx, doc, opts, pdf_array_get(ctx, val, i), flag, page);
            }
        }
    }
    fz_always(ctx)
    {
        pdf_unmark_obj(ctx, val);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}

static int
mark_pages(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_obj *val, int pagenum)
{
    if (pdf_mark_obj(ctx, val))
        return pagenum;

    fz_try(ctx)
    {
        if (pdf_is_dict(ctx, val))
        {
            if (pdf_name_eq(ctx, PDF_NAME(Page), pdf_dict_get(ctx, val, PDF_NAME(Type))))
            {
                int num = pdf_to_num(ctx, val);
                pdf_unmark_obj(ctx, val);
                mark_all(ctx, doc, opts, val, pagenum == 0 ? USE_PAGE1 : (pagenum<<USE_PAGE_SHIFT), pagenum);
                page_objects_list_set_page_object(ctx, opts, pagenum, num);
                pagenum++;
                opts->use_list[num] |= USE_PAGE_OBJECT;
            }
            else
            {
                int i, n = pdf_dict_len(ctx, val);

                for (i = 0; i < n; i++)
                {
                    pdf_obj *key = pdf_dict_get_key(ctx, val, i);
                    pdf_obj *obj = pdf_dict_get_val(ctx, val, i);

                    if (pdf_name_eq(ctx, PDF_NAME(Kids), key))
                        pagenum = mark_pages(ctx, doc, opts, obj, pagenum);
                    else
                        mark_all(ctx, doc, opts, obj, USE_CATALOGUE, -1);
                }

                if (pdf_is_indirect(ctx, val))
                {
                    int num = pdf_to_num(ctx, val);
                    opts->use_list[num] |= USE_CATALOGUE;
                }
            }
        }
        else if (pdf_is_array(ctx, val))
        {
            int i, n = pdf_array_len(ctx, val);

            for (i = 0; i < n; i++)
            {
                pagenum = mark_pages(ctx, doc, opts, pdf_array_get(ctx, val, i), pagenum);
            }
            if (pdf_is_indirect(ctx, val))
            {
                int num = pdf_to_num(ctx, val);
                opts->use_list[num] |= USE_CATALOGUE;
            }
        }
    }
    fz_always(ctx)
    {
        pdf_unmark_obj(ctx, val);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
    return pagenum;
}

static void
mark_root(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_obj *dict)
{
    int i, n = pdf_dict_len(ctx, dict);

    if (pdf_mark_obj(ctx, dict))
        return;

    fz_try(ctx)
    {
        if (pdf_is_indirect(ctx, dict))
        {
            int num = pdf_to_num(ctx, dict);
            opts->use_list[num] |= USE_CATALOGUE;
        }

        for (i = 0; i < n; i++)
        {
            pdf_obj *key = pdf_dict_get_key(ctx, dict, i);
            pdf_obj *val = pdf_dict_get_val(ctx, dict, i);

            if (pdf_name_eq(ctx, PDF_NAME(Pages), key))
                opts->page_count = mark_pages(ctx, doc, opts, val, 0);
            else if (pdf_name_eq(ctx, PDF_NAME(Names), key))
                mark_all(ctx, doc, opts, val, USE_OTHER_OBJECTS, -1);
            else if (pdf_name_eq(ctx, PDF_NAME(Dests), key))
                mark_all(ctx, doc, opts, val, USE_OTHER_OBJECTS, -1);
            else if (pdf_name_eq(ctx, PDF_NAME(Outlines), key))
            {
                int section;
                /* Look at PageMode to decide whether to
                 * USE_OTHER_OBJECTS or USE_PAGE1 here. */
                if (pdf_name_eq(ctx, pdf_dict_get(ctx, dict, PDF_NAME(PageMode)), PDF_NAME(UseOutlines)))
                    section = USE_PAGE1;
                else
                    section = USE_OTHER_OBJECTS;
                mark_all(ctx, doc, opts, val, section, -1);
            }
            else
                mark_all(ctx, doc, opts, val, USE_CATALOGUE, -1);
        }
    }
    fz_always(ctx)
    {
        pdf_unmark_obj(ctx, dict);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}

static void
mark_trailer(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_obj *dict)
{
    int i, n = pdf_dict_len(ctx, dict);

    if (pdf_mark_obj(ctx, dict))
        return;

    fz_try(ctx)
    {
        for (i = 0; i < n; i++)
        {
            pdf_obj *key = pdf_dict_get_key(ctx, dict, i);
            pdf_obj *val = pdf_dict_get_val(ctx, dict, i);

            if (pdf_name_eq(ctx, PDF_NAME(Root), key))
                mark_root(ctx, doc, opts, val);
            else
                mark_all(ctx, doc, opts, val, USE_CATALOGUE, -1);
        }
    }
    fz_always(ctx)
    {
        pdf_unmark_obj(ctx, dict);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}

static void
add_linearization_objs(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)
{
    pdf_obj *params_obj = NULL;
    pdf_obj *params_ref = NULL;
    pdf_obj *hint_obj = NULL;
    pdf_obj *hint_ref = NULL;
    pdf_obj *o;
    int params_num, hint_num;

    fz_var(params_obj);
    fz_var(params_ref);
    fz_var(hint_obj);
    fz_var(hint_ref);

    fz_try(ctx)
    {
        /* Linearization params */
        params_obj = pdf_new_dict(ctx, doc, 10);
        params_ref = pdf_add_object(ctx, doc, params_obj);
        params_num = pdf_to_num(ctx, params_ref);

        opts->use_list[params_num] = USE_PARAMS;
        opts->renumber_map[params_num] = params_num;
        opts->rev_renumber_map[params_num] = params_num;
        opts->gen_list[params_num] = 0;
        pdf_dict_put_real(ctx, params_obj, PDF_NAME(Linearized), 1.0f);
        opts->linear_l = pdf_new_int(ctx, INT_MIN);
        pdf_dict_put(ctx, params_obj, PDF_NAME(L), opts->linear_l);
        opts->linear_h0 = pdf_new_int(ctx, INT_MIN);
        o = pdf_new_array(ctx, doc, 2);
        pdf_dict_put_drop(ctx, params_obj, PDF_NAME(H), o);
        pdf_array_push(ctx, o, opts->linear_h0);
        opts->linear_h1 = pdf_new_int(ctx, INT_MIN);
        pdf_array_push(ctx, o, opts->linear_h1);
        opts->linear_o = pdf_new_int(ctx, INT_MIN);
        pdf_dict_put(ctx, params_obj, PDF_NAME(O), opts->linear_o);
        opts->linear_e = pdf_new_int(ctx, INT_MIN);
        pdf_dict_put(ctx, params_obj, PDF_NAME(E), opts->linear_e);
        opts->linear_n = pdf_new_int(ctx, INT_MIN);
        pdf_dict_put(ctx, params_obj, PDF_NAME(N), opts->linear_n);
        opts->linear_t = pdf_new_int(ctx, INT_MIN);
        pdf_dict_put(ctx, params_obj, PDF_NAME(T), opts->linear_t);

        /* Primary hint stream */
        hint_obj = pdf_new_dict(ctx, doc, 10);
        hint_ref = pdf_add_object(ctx, doc, hint_obj);
        hint_num = pdf_to_num(ctx, hint_ref);

        opts->use_list[hint_num] = USE_HINTS;
        opts->renumber_map[hint_num] = hint_num;
        opts->rev_renumber_map[hint_num] = hint_num;
        opts->gen_list[hint_num] = 0;
        pdf_dict_put_int(ctx, hint_obj, PDF_NAME(P), 0);
        opts->hints_s = pdf_new_int(ctx, INT_MIN);
        pdf_dict_put(ctx, hint_obj, PDF_NAME(S), opts->hints_s);
        /* FIXME: Do we have thumbnails? Do a T entry */
        /* FIXME: Do we have outlines? Do an O entry */
        /* FIXME: Do we have article threads? Do an A entry */
        /* FIXME: Do we have named destinations? Do a E entry */
        /* FIXME: Do we have interactive forms? Do a V entry */
        /* FIXME: Do we have document information? Do an I entry */
        /* FIXME: Do we have logical structure hierarchy? Do a C entry */
        /* FIXME: Do L, Page Label hint table */
        pdf_dict_put(ctx, hint_obj, PDF_NAME(Filter), PDF_NAME(FlateDecode));
        opts->hints_length = pdf_new_int(ctx, INT_MIN);
        pdf_dict_put(ctx, hint_obj, PDF_NAME(Length), opts->hints_length);
        pdf_get_xref_entry(ctx, doc, hint_num)->stm_ofs = -1;
    }
    fz_always(ctx)
    {
        pdf_drop_obj(ctx, params_obj);
        pdf_drop_obj(ctx, params_ref);
        pdf_drop_obj(ctx, hint_ref);
        pdf_drop_obj(ctx, hint_obj);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}

static void
lpr_inherit_res_contents(fz_context *ctx, pdf_obj *res, pdf_obj *dict, pdf_obj *text)
{
    pdf_obj *o, *r;
    int i, n;

    /* If the parent node doesn't have an entry of this type, give up. */
    o = pdf_dict_get(ctx, dict, text);
    if (!o)
        return;

    /* If the resources dict we are building doesn't have an entry of this
     * type yet, then just copy it (ensuring it's not a reference) */
    r = pdf_dict_get(ctx, res, text);
    if (r == NULL)
    {
        o = pdf_resolve_indirect(ctx, o);
        if (pdf_is_dict(ctx, o))
            o = pdf_copy_dict(ctx, o);
        else if (pdf_is_array(ctx, o))
            o = pdf_copy_array(ctx, o);
        else
            o = NULL;
        if (o)
            pdf_dict_put_drop(ctx, res, text, o);
        return;
    }

    /* Otherwise we need to merge o into r */
    if (pdf_is_dict(ctx, o))
    {
        n = pdf_dict_len(ctx, o);
        for (i = 0; i < n; i++)
        {
            pdf_obj *key = pdf_dict_get_key(ctx, o, i);
            pdf_obj *val = pdf_dict_get_val(ctx, o, i);

            if (pdf_dict_get(ctx, res, key))
                continue;
            pdf_dict_put(ctx, res, key, val);
        }
    }
}

static void
lpr_inherit_res(fz_context *ctx, pdf_obj *node, int depth, pdf_obj *dict)
{
    while (1)
    {
        pdf_obj *o;

        node = pdf_dict_get(ctx, node, PDF_NAME(Parent));
        depth--;
        if (!node || depth < 0)
            break;

        o = pdf_dict_get(ctx, node, PDF_NAME(Resources));
        if (o)
        {
            lpr_inherit_res_contents(ctx, dict, o, PDF_NAME(ExtGState));
            lpr_inherit_res_contents(ctx, dict, o, PDF_NAME(ColorSpace));
            lpr_inherit_res_contents(ctx, dict, o, PDF_NAME(Pattern));
            lpr_inherit_res_contents(ctx, dict, o, PDF_NAME(Shading));
            lpr_inherit_res_contents(ctx, dict, o, PDF_NAME(XObject));
            lpr_inherit_res_contents(ctx, dict, o, PDF_NAME(Font));
            lpr_inherit_res_contents(ctx, dict, o, PDF_NAME(ProcSet));
            lpr_inherit_res_contents(ctx, dict, o, PDF_NAME(Properties));
        }
    }
}

static pdf_obj *
lpr_inherit(fz_context *ctx, pdf_obj *node, char *text, int depth)
{
    do
    {
        pdf_obj *o = pdf_dict_gets(ctx, node, text);

        if (o)
            return pdf_resolve_indirect(ctx, o);
        node = pdf_dict_get(ctx, node, PDF_NAME(Parent));
        depth--;
    }
    while (depth >= 0 && node);

    return NULL;
}

static int
lpr(fz_context *ctx, pdf_document *doc, pdf_obj *node, int depth, int page)
{
    pdf_obj *kids;
    pdf_obj *o = NULL;
    int i, n;

    if (pdf_mark_obj(ctx, node))
        return page;

    fz_var(o);

    fz_try(ctx)
    {
        if (pdf_name_eq(ctx, PDF_NAME(Page), pdf_dict_get(ctx, node, PDF_NAME(Type))))
        {
            pdf_obj *r; /* r is deliberately not cleaned up */

            /* Copy resources down to the child */
            o = pdf_keep_obj(ctx, pdf_dict_get(ctx, node, PDF_NAME(Resources)));
            if (!o)
            {
                o = pdf_keep_obj(ctx, pdf_new_dict(ctx, doc, 2));
                pdf_dict_put(ctx, node, PDF_NAME(Resources), o);
            }
            lpr_inherit_res(ctx, node, depth, o);
            r = lpr_inherit(ctx, node, "MediaBox", depth);
            if (r)
                pdf_dict_put(ctx, node, PDF_NAME(MediaBox), r);
            r = lpr_inherit(ctx, node, "CropBox", depth);
            if (r)
                pdf_dict_put(ctx, node, PDF_NAME(CropBox), r);
            r = lpr_inherit(ctx, node, "BleedBox", depth);
            if (r)
                pdf_dict_put(ctx, node, PDF_NAME(BleedBox), r);
            r = lpr_inherit(ctx, node, "TrimBox", depth);
            if (r)
                pdf_dict_put(ctx, node, PDF_NAME(TrimBox), r);
            r = lpr_inherit(ctx, node, "ArtBox", depth);
            if (r)
                pdf_dict_put(ctx, node, PDF_NAME(ArtBox), r);
            r = lpr_inherit(ctx, node, "Rotate", depth);
            if (r)
                pdf_dict_put(ctx, node, PDF_NAME(Rotate), r);
            page++;
        }
        else
        {
            kids = pdf_dict_get(ctx, node, PDF_NAME(Kids));
            n = pdf_array_len(ctx, kids);
            for(i = 0; i < n; i++)
            {
                page = lpr(ctx, doc, pdf_array_get(ctx, kids, i), depth+1, page);
            }
            pdf_dict_del(ctx, node, PDF_NAME(Resources));
            pdf_dict_del(ctx, node, PDF_NAME(MediaBox));
            pdf_dict_del(ctx, node, PDF_NAME(CropBox));
            pdf_dict_del(ctx, node, PDF_NAME(BleedBox));
            pdf_dict_del(ctx, node, PDF_NAME(TrimBox));
            pdf_dict_del(ctx, node, PDF_NAME(ArtBox));
            pdf_dict_del(ctx, node, PDF_NAME(Rotate));
        }
    }
    fz_always(ctx)
    {
        pdf_drop_obj(ctx, o);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }

    pdf_unmark_obj(ctx, node);

    return page;
}

static void
linearize(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)
{
    int i;
    int n = pdf_xref_len(ctx, doc) + 2;
    int *reorder;
    int *rev_renumber_map;

    opts->page_object_lists = page_objects_list_create(ctx);

    /* Ensure that every page has local references of its resources */
    /* FIXME: We could 'thin' the resources according to what is actually
     * required for each page, but this would require us to run the page
     * content streams. */
    pdf_localise_page_resources(ctx, doc);

    /* Walk the objects for each page, marking which ones are used, where */
    memset(opts->use_list, 0, n * sizeof(int));
    mark_trailer(ctx, doc, opts, pdf_trailer(ctx, doc));

    /* Add new objects required for linearization */
    add_linearization_objs(ctx, doc, opts);

    /* Allocate/init the structures used for renumbering the objects */
    reorder = fz_calloc(ctx, n, sizeof(int));
    rev_renumber_map = fz_calloc(ctx, n, sizeof(int));
    for (i = 0; i < n; i++)
    {
        reorder[i] = i;
    }

    /* Heap sort the reordering */
    heap_sort(reorder+1, n-1, opts->use_list, &order_ge);

    /* Find the split point */
    for (i = 1; (opts->use_list[reorder[i]] & USE_PARAMS) == 0; i++) {}
    opts->start = i;

    /* Roll the reordering into the renumber_map */
    for (i = 0; i < n; i++)
    {
        opts->renumber_map[reorder[i]] = i;
        rev_renumber_map[i] = opts->rev_renumber_map[reorder[i]];
    }
    fz_free(ctx, opts->rev_renumber_map);
    opts->rev_renumber_map = rev_renumber_map;
    fz_free(ctx, reorder);

    /* Apply the renumber_map */
    page_objects_list_renumber(opts);
    renumberobjs(ctx, doc, opts);

    page_objects_list_sort_and_dedupe(ctx, opts->page_object_lists);
}

static void
update_linearization_params(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)
{
    int64_t offset;
    pdf_set_int(ctx, opts->linear_l, opts->file_len);
    /* Primary hint stream offset (of object, not stream!) */
    pdf_set_int(ctx, opts->linear_h0, opts->ofs_list[pdf_xref_len(ctx, doc)-1]);
    /* Primary hint stream length (of object, not stream!) */
    offset = (opts->start == 1 ? opts->main_xref_offset : opts->ofs_list[1] + opts->hintstream_len);
    pdf_set_int(ctx, opts->linear_h1, offset - opts->ofs_list[pdf_xref_len(ctx, doc)-1]);
    /* Object number of first pages page object (the first object of page 0) */
    pdf_set_int(ctx, opts->linear_o, opts->page_object_lists->page[0]->object[0]);
    /* Offset of end of first page (first page is followed by primary
     * hint stream (object n-1) then remaining pages (object 1...). The
     * primary hint stream counts as part of the first pages data, I think.
     */
    offset = (opts->start == 1 ? opts->main_xref_offset : opts->ofs_list[1] + opts->hintstream_len);
    pdf_set_int(ctx, opts->linear_e, offset);
    /* Number of pages in document */
    pdf_set_int(ctx, opts->linear_n, opts->page_count);
    /* Offset of first entry in main xref table */
    pdf_set_int(ctx, opts->linear_t, opts->first_xref_entry_offset + opts->hintstream_len);
    /* Offset of shared objects hint table in the primary hint stream */
    pdf_set_int(ctx, opts->hints_s, opts->hints_shared_offset);
    /* Primary hint stream length */
    pdf_set_int(ctx, opts->hints_length, opts->hintstream_len);
}

/*
 * Make sure we have loaded objects from object streams.
 */

static void preloadobjstms(fz_context *ctx, pdf_document *doc)
{
    pdf_obj *obj;
    int num;

    /* xref_len may change due to repair, so check it every iteration */
    for (num = 0; num < pdf_xref_len(ctx, doc); num++)
    {
        if (pdf_get_xref_entry(ctx, doc, num)->type == 'o')
        {
            obj = pdf_load_object(ctx, doc, num);
            pdf_drop_obj(ctx, obj);
        }
    }
}

/*
 * Save streams and objects to the output
 */

static inline int isbinary(int c)
{
    if (c == '\n' || c == '\r' || c == '\t')
        return 0;
    return c < 32 || c > 127;
}

static int isbinarystream(fz_context *ctx, fz_buffer *buf)
{
    unsigned char *data;
    size_t len = fz_buffer_storage(ctx, buf, &data);
    size_t i;
    for (i = 0; i < len; i++)
        if (isbinary(data[i]))
            return 1;
    return 0;
}

static fz_buffer *hexbuf(fz_context *ctx, const unsigned char *p, size_t n)
{
    static const char hex[17] = "0123456789abcdef";
    int x = 0;
    size_t len = n * 2 + (n / 32) + 1;
    unsigned char *data = fz_malloc(ctx, len);
    fz_buffer *buf = fz_new_buffer_from_data(ctx, data, len);

    while (n--)
    {
        *data++ = hex[*p >> 4];
        *data++ = hex[*p & 15];
        if (++x == 32)
        {
            *data++ = '\n';
            x = 0;
        }
        p++;
    }

    *data++ = '>';

    return buf;
}

static void addhexfilter(fz_context *ctx, pdf_document *doc, pdf_obj *dict)
{
    pdf_obj *f, *dp, *newf, *newdp;

    newf = newdp = NULL;
    f = pdf_dict_get(ctx, dict, PDF_NAME(Filter));
    dp = pdf_dict_get(ctx, dict, PDF_NAME(DecodeParms));

    fz_var(newf);
    fz_var(newdp);

    fz_try(ctx)
    {
        if (pdf_is_name(ctx, f))
        {
            newf = pdf_new_array(ctx, doc, 2);
            pdf_array_push(ctx, newf, PDF_NAME(ASCIIHexDecode));
            pdf_array_push(ctx, newf, f);
            f = newf;
            if (pdf_is_dict(ctx, dp))
            {
                newdp = pdf_new_array(ctx, doc, 2);
                pdf_array_push(ctx, newdp, PDF_NULL);
                pdf_array_push(ctx, newdp, dp);
                dp = newdp;
            }
        }
        else if (pdf_is_array(ctx, f))
        {
            pdf_array_insert(ctx, f, PDF_NAME(ASCIIHexDecode), 0);
            if (pdf_is_array(ctx, dp))
                pdf_array_insert(ctx, dp, PDF_NULL, 0);
        }
        else
            f = PDF_NAME(ASCIIHexDecode);

        pdf_dict_put(ctx, dict, PDF_NAME(Filter), f);
        if (dp)
            pdf_dict_put(ctx, dict, PDF_NAME(DecodeParms), dp);
    }
    fz_always(ctx)
    {
        pdf_drop_obj(ctx, newf);
        pdf_drop_obj(ctx, newdp);
    }
    fz_catch(ctx)
        fz_rethrow(ctx);
}

static fz_buffer *deflatebuf(fz_context *ctx, const unsigned char *p, size_t n)
{
    fz_buffer *buf;
    uLongf csize;
    int t;
    uLong longN = (uLong)n;
    unsigned char *data;
    size_t cap;

    if (n != (size_t)longN)
        fz_throw(ctx, FZ_ERROR_GENERIC, "Buffer too large to deflate");

    cap = compressBound(longN);
    data = fz_malloc(ctx, cap);
    buf = fz_new_buffer_from_data(ctx, data, cap);
    csize = (uLongf)cap;
    t = compress(data, &csize, p, longN);
    if (t != Z_OK)
    {
        fz_drop_buffer(ctx, buf);
        fz_throw(ctx, FZ_ERROR_GENERIC, "cannot deflate buffer");
    }
    fz_resize_buffer(ctx, buf, csize);
    return buf;
}

static void write_data(fz_context *ctx, void *arg, const unsigned char *data, int len)
{
    fz_write_data(ctx, (fz_output *)arg, data, len);
}

static void copystream(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_obj *obj_orig, int num, int gen, int do_deflate)
{
    fz_buffer *buf, *tmp;
    pdf_obj *obj;
    size_t len;
    unsigned char *data;

    buf = pdf_load_raw_stream_number(ctx, doc, num);

    obj = pdf_copy_dict(ctx, obj_orig);

    len = fz_buffer_storage(ctx, buf, &data);
    if (do_deflate && !pdf_dict_get(ctx, obj, PDF_NAME(Filter)))
    {
        size_t clen;
        unsigned char *cdata;
        tmp = deflatebuf(ctx, data, len);
        clen = fz_buffer_storage(ctx, tmp, &cdata);
        if (clen >= len)
        {
            /* Don't bother compressing, as we gain nothing. */
            fz_drop_buffer(ctx, tmp);
        }
        else
        {
            len = clen;
            data = cdata;
            pdf_dict_put(ctx, obj, PDF_NAME(Filter), PDF_NAME(FlateDecode));
            fz_drop_buffer(ctx, buf);
            buf = tmp;
        }
    }

    if (opts->do_ascii && isbinarystream(ctx, buf))
    {
        tmp = hexbuf(ctx, data, len);
        fz_drop_buffer(ctx, buf);
        buf = tmp;
        len = fz_buffer_storage(ctx, buf, &data);

        addhexfilter(ctx, doc, obj);
    }

    pdf_dict_put_int(ctx, obj, PDF_NAME(Length), pdf_encrypted_len(ctx, NULL, num, gen, (int)len));

    fz_write_printf(ctx, opts->out, "%d %d obj\n", num, gen);
    pdf_print_encrypted_obj(ctx, opts->out, obj, opts->do_tight, NULL, num, gen);
    fz_write_string(ctx, opts->out, "\nstream\n");
    pdf_encrypt_data(ctx, NULL, num, gen, write_data, opts->out, data, (int) len);
    fz_write_string(ctx, opts->out, "\nendstream\nendobj\n\n");

    fz_drop_buffer(ctx, buf);
    pdf_drop_obj(ctx, obj);
}

static void expandstream(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_obj *obj_orig, int num, int gen, int do_deflate)
{
    fz_buffer *buf, *tmp;
    pdf_obj *obj;
    int truncated = 0;
    size_t len;
    unsigned char *data;

    buf = pdf_load_stream_truncated(ctx, doc, num, (opts->continue_on_error ? &truncated : NULL));
    if (truncated && opts->errors)
        (*opts->errors)++;

    obj = pdf_copy_dict(ctx, obj_orig);
    pdf_dict_del(ctx, obj, PDF_NAME(Filter));
    pdf_dict_del(ctx, obj, PDF_NAME(DecodeParms));

    len = fz_buffer_storage(ctx, buf, &data);
    if (do_deflate)
    {
        unsigned char *cdata;
        size_t clen;
        tmp = deflatebuf(ctx, data, len);
        clen = fz_buffer_storage(ctx, tmp, &cdata);
        if (clen >= len)
        {
            /* Don't bother compressing, as we gain nothing. */
            fz_drop_buffer(ctx, tmp);
        }
        else
        {
            len = clen;
            data = cdata;
            pdf_dict_put(ctx, obj, PDF_NAME(Filter), PDF_NAME(FlateDecode));
            fz_drop_buffer(ctx, buf);
            buf = tmp;
        }
    }

    if (opts->do_ascii && isbinarystream(ctx, buf))
    {
        tmp = hexbuf(ctx, data, len);
        fz_drop_buffer(ctx, buf);
        buf = tmp;
        len = fz_buffer_storage(ctx, buf, &data);

        addhexfilter(ctx, doc, obj);
    }

    pdf_dict_put_int(ctx, obj, PDF_NAME(Length), len);

    fz_write_printf(ctx, opts->out, "%d %d obj\n", num, gen);
    pdf_print_encrypted_obj(ctx, opts->out, obj, opts->do_tight, NULL, num, gen);
    fz_write_string(ctx, opts->out, "\nstream\n");
    fz_write_data(ctx, opts->out, data, len);
    fz_write_string(ctx, opts->out, "\nendstream\nendobj\n\n");

    fz_drop_buffer(ctx, buf);
    pdf_drop_obj(ctx, obj);
}

static int is_image_filter(const char *s)
{
    if (!strcmp(s, "CCITTFaxDecode") || !strcmp(s, "CCF") ||
        !strcmp(s, "DCTDecode") || !strcmp(s, "DCT") ||
        !strcmp(s, "RunLengthDecode") || !strcmp(s, "RL") ||
        !strcmp(s, "JBIG2Decode") ||
        !strcmp(s, "JPXDecode"))
        return 1;
    return 0;
}

static int filter_implies_image(fz_context *ctx, pdf_obj *o)
{
    if (!o)
        return 0;
    if (pdf_is_name(ctx, o))
        return is_image_filter(pdf_to_name(ctx, o));
    if (pdf_is_array(ctx, o))
    {
        int i, len;
        len = pdf_array_len(ctx, o);
        for (i = 0; i < len; i++)
            if (is_image_filter(pdf_to_name(ctx, pdf_array_get(ctx, o, i))))
                return 1;
    }
    return 0;
}

static int is_image_stream(fz_context *ctx, pdf_obj *obj)
{
    pdf_obj *o;
    if ((o = pdf_dict_get(ctx, obj, PDF_NAME(Type)), pdf_name_eq(ctx, o, PDF_NAME(XObject))))
        if ((o = pdf_dict_get(ctx, obj, PDF_NAME(Subtype)), pdf_name_eq(ctx, o, PDF_NAME(Image))))
            return 1;
    if (o = pdf_dict_get(ctx, obj, PDF_NAME(Filter)), filter_implies_image(ctx, o))
        return 1;
    if (pdf_dict_get(ctx, obj, PDF_NAME(Width)) != NULL && pdf_dict_get(ctx, obj, PDF_NAME(Height)) != NULL)
        return 1;
    return 0;
}

static int is_font_stream(fz_context *ctx, pdf_obj *obj)
{
    pdf_obj *o;
    if (o = pdf_dict_get(ctx, obj, PDF_NAME(Type)), pdf_name_eq(ctx, o, PDF_NAME(Font)))
        return 1;
    if (o = pdf_dict_get(ctx, obj, PDF_NAME(Type)), pdf_name_eq(ctx, o, PDF_NAME(FontDescriptor)))
        return 1;
    if (pdf_dict_get(ctx, obj, PDF_NAME(Length1)) != NULL)
        return 1;
    if (pdf_dict_get(ctx, obj, PDF_NAME(Length2)) != NULL)
        return 1;
    if (pdf_dict_get(ctx, obj, PDF_NAME(Length3)) != NULL)
        return 1;
    if (o = pdf_dict_get(ctx, obj, PDF_NAME(Subtype)), pdf_name_eq(ctx, o, PDF_NAME(Type1C)))
        return 1;
    if (o = pdf_dict_get(ctx, obj, PDF_NAME(Subtype)), pdf_name_eq(ctx, o, PDF_NAME(CIDFontType0C)))
        return 1;
    return 0;
}

static int is_xml_metadata(fz_context *ctx, pdf_obj *obj)
{
    if (pdf_name_eq(ctx, pdf_dict_get(ctx, obj, PDF_NAME(Type)), PDF_NAME(Metadata)))
        if (pdf_name_eq(ctx, pdf_dict_get(ctx, obj, PDF_NAME(Subtype)), PDF_NAME(XML)))
            return 1;
    return 0;
}

static void writeobject(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, int num, int gen, int skip_xrefs, int unenc)
{
    if (unenc) return;
    pdf_xref_entry *entry;
    pdf_obj *obj;
    pdf_obj *type;

    fz_try(ctx)
    {
        obj = pdf_load_object(ctx, doc, num);
    }
    fz_catch(ctx)
    {
        fz_rethrow_if(ctx, FZ_ERROR_TRYLATER);
        if (opts->continue_on_error)
        {
            fz_write_printf(ctx, opts->out, "%d %d obj\nnull\nendobj\n", num, gen);
            if (opts->errors)
                (*opts->errors)++;
            fz_warn(ctx, "%s", fz_caught_message(ctx));
            return;
        }
        else
            fz_rethrow(ctx);
    }

    /* skip ObjStm and XRef objects */
    if (pdf_is_dict(ctx, obj))
    {
        type = pdf_dict_get(ctx, obj, PDF_NAME(Type));
        if (pdf_name_eq(ctx, type, PDF_NAME(ObjStm)))
        {
            opts->use_list[num] = 0;
            pdf_drop_obj(ctx, obj);
            return;
        }
        if (skip_xrefs && pdf_name_eq(ctx, type, PDF_NAME(XRef)))
        {
            opts->use_list[num] = 0;
            pdf_drop_obj(ctx, obj);
            return;
        }
    }

    entry = pdf_get_xref_entry(ctx, doc, num);
    if (!pdf_obj_num_is_stream(ctx, doc, num))
    {
        fz_write_printf(ctx, opts->out, "%d %d obj\n", num, gen);
        pdf_print_encrypted_obj(ctx, opts->out, obj, opts->do_tight, NULL, num, gen);
        fz_write_string(ctx, opts->out, "\nendobj\n\n");
    }
    else if (entry->stm_ofs < 0 && entry->stm_buf == NULL)
    {
        fz_write_printf(ctx, opts->out, "%d %d obj\n", num, gen);
        pdf_print_encrypted_obj(ctx, opts->out, obj, opts->do_tight, NULL, num, gen);
        fz_write_string(ctx, opts->out, "\nstream\nendstream\nendobj\n\n");
    }
    else
    {
        fz_try(ctx)
        {
            int do_deflate = opts->do_compress;
            int do_expand = opts->do_expand;
            if (opts->do_compress_images && is_image_stream(ctx, obj))
                do_deflate = 1, do_expand = 0;
            if (opts->do_compress_fonts && is_font_stream(ctx, obj))
                do_deflate = 1, do_expand = 0;
            if (is_xml_metadata(ctx, obj))
                do_deflate = 0, do_expand = 0;
            if (do_expand)
                expandstream(ctx, doc, opts, obj, num, gen, do_deflate);
            else
                copystream(ctx, doc, opts, obj, num, gen, do_deflate);
        }
        fz_catch(ctx)
        {
            fz_rethrow_if(ctx, FZ_ERROR_TRYLATER);
            if (opts->continue_on_error)
            {
                fz_write_printf(ctx, opts->out, "%d %d obj\nnull\nendobj\n", num, gen);
                if (opts->errors)
                    (*opts->errors)++;
                fz_warn(ctx, "%s", fz_caught_message(ctx));
            }
            else
            {
                pdf_drop_obj(ctx, obj);
                fz_rethrow(ctx);
            }
        }
    }

    pdf_drop_obj(ctx, obj);
}

static void writexrefsubsect(fz_context *ctx, pdf_write_state *opts, int from, int to)
{
    int num;

    fz_write_printf(ctx, opts->out, "%d %d\n", from, to - from);
    for (num = from; num < to; num++)
    {
        if (opts->use_list[num])
            fz_write_printf(ctx, opts->out, "%010lu %05d n \n", opts->ofs_list[num], opts->gen_list[num]);
        else
            fz_write_printf(ctx, opts->out, "%010lu %05d f \n", opts->ofs_list[num], opts->gen_list[num]);
    }
}

static void writexref(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, int from, int to, int first, int64_t main_xref_offset, int64_t startxref)
{
    pdf_obj *trailer = NULL;
    pdf_obj *obj;
    pdf_obj *nobj = NULL;

    fz_write_string(ctx, opts->out, "xref\n");
    opts->first_xref_entry_offset = fz_tell_output(ctx, opts->out);

    if (opts->do_incremental)
    {
        int subfrom = from;
        int subto;

        while (subfrom < to)
        {
            while (subfrom < to && !pdf_xref_is_incremental(ctx, doc, subfrom))
                subfrom++;

            subto = subfrom;
            while (subto < to && pdf_xref_is_incremental(ctx, doc, subto))
                subto++;

            if (subfrom < subto)
                writexrefsubsect(ctx, opts, subfrom, subto);

            subfrom = subto;
        }
    }
    else
    {
        writexrefsubsect(ctx, opts, from, to);
    }

    fz_write_string(ctx, opts->out, "\n");

    fz_var(trailer);

    if (opts->do_incremental)
    {
        trailer = pdf_keep_obj(ctx, pdf_trailer(ctx, doc));
        pdf_dict_put_int(ctx, trailer, PDF_NAME(Size), pdf_xref_len(ctx, doc));
        pdf_dict_put_int(ctx, trailer, PDF_NAME(Prev), doc->startxref);
        doc->startxref = startxref;
    }
    else
    {
        trailer = pdf_new_dict(ctx, doc, 5);

        nobj = pdf_new_int(ctx, to);
        pdf_dict_put_drop(ctx, trailer, PDF_NAME(Size), nobj);

        if (first)
        {
            obj = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(Info));
            if (obj)
                pdf_dict_put(ctx, trailer, PDF_NAME(Info), obj);

            obj = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(Root));
            if (obj)
                pdf_dict_put(ctx, trailer, PDF_NAME(Root), obj);

            obj = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(ID));
            if (obj)
                pdf_dict_put(ctx, trailer, PDF_NAME(ID), obj);
        }
        if (main_xref_offset != 0)
        {
            nobj = pdf_new_int(ctx, main_xref_offset);
            pdf_dict_put_drop(ctx, trailer, PDF_NAME(Prev), nobj);
        }
    }

    fz_write_string(ctx, opts->out, "trailer\n");
    /* Trailer is NOT encrypted */
    pdf_print_obj(ctx, opts->out, trailer, opts->do_tight);
    fz_write_string(ctx, opts->out, "\n");

    pdf_drop_obj(ctx, trailer);

    fz_write_printf(ctx, opts->out, "startxref\n%lu\n%%%%EOF\n", startxref);

    doc->has_xref_streams = 0;
}

static void writexrefstreamsubsect(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_obj *index, fz_buffer *fzbuf, int from, int to)
{
    int num;

    pdf_array_push_int(ctx, index, from);
    pdf_array_push_int(ctx, index, to - from);
    for (num = from; num < to; num++)
    {
        fz_append_byte(ctx, fzbuf, opts->use_list[num] ? 1 : 0);
        fz_append_byte(ctx, fzbuf, opts->ofs_list[num]>>24);
        fz_append_byte(ctx, fzbuf, opts->ofs_list[num]>>16);
        fz_append_byte(ctx, fzbuf, opts->ofs_list[num]>>8);
        fz_append_byte(ctx, fzbuf, opts->ofs_list[num]);
        fz_append_byte(ctx, fzbuf, opts->gen_list[num]);
    }
}

static void writexrefstream(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, int from, int to, int first, int64_t main_xref_offset, int64_t startxref)
{
    int num;
    pdf_obj *dict = NULL;
    pdf_obj *obj;
    pdf_obj *w = NULL;
    pdf_obj *index;
    fz_buffer *fzbuf = NULL;

    fz_var(dict);
    fz_var(w);
    fz_var(fzbuf);
    fz_try(ctx)
    {
        num = pdf_create_object(ctx, doc);
        dict = pdf_new_dict(ctx, doc, 6);
        pdf_update_object(ctx, doc, num, dict);

        opts->first_xref_entry_offset = fz_tell_output(ctx, opts->out);

        to++;

        if (first)
        {
            obj = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(Info));
            if (obj)
                pdf_dict_put(ctx, dict, PDF_NAME(Info), obj);

            obj = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(Root));
            if (obj)
                pdf_dict_put(ctx, dict, PDF_NAME(Root), obj);

            obj = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(ID));
            if (obj)
                pdf_dict_put(ctx, dict, PDF_NAME(ID), obj);

            if (opts->do_incremental)
            {
                obj = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(Encrypt));
                if (obj)
                    pdf_dict_put(ctx, dict, PDF_NAME(Encrypt), obj);
            }
        }

        pdf_dict_put_int(ctx, dict, PDF_NAME(Size), to);

        if (opts->do_incremental)
        {
            pdf_dict_put_int(ctx, dict, PDF_NAME(Prev), doc->startxref);
            doc->startxref = startxref;
        }
        else
        {
            if (main_xref_offset != 0)
                pdf_dict_put_int(ctx, dict, PDF_NAME(Prev), main_xref_offset);
        }

        pdf_dict_put(ctx, dict, PDF_NAME(Type), PDF_NAME(XRef));

        w = pdf_new_array(ctx, doc, 3);
        pdf_dict_put(ctx, dict, PDF_NAME(W), w);
        pdf_array_push_int(ctx, w, 1);
        pdf_array_push_int(ctx, w, 4);
        pdf_array_push_int(ctx, w, 1);

        index = pdf_new_array(ctx, doc, 2);
        pdf_dict_put_drop(ctx, dict, PDF_NAME(Index), index);

        /* opts->gen_list[num] is already initialized by fz_calloc. */
        opts->use_list[num] = 1;
        opts->ofs_list[num] = opts->first_xref_entry_offset;

        fzbuf = fz_new_buffer(ctx, (1 + 4 + 1) * (to-from));

        if (opts->do_incremental)
        {
            int subfrom = from;
            int subto;

            while (subfrom < to)
            {
                while (subfrom < to && !pdf_xref_is_incremental(ctx, doc, subfrom))
                    subfrom++;

                subto = subfrom;
                while (subto < to && pdf_xref_is_incremental(ctx, doc, subto))
                    subto++;

                if (subfrom < subto)
                    writexrefstreamsubsect(ctx, doc, opts, index, fzbuf, subfrom, subto);

                subfrom = subto;
            }
        }
        else
        {
            writexrefstreamsubsect(ctx, doc, opts, index, fzbuf, from, to);
        }

        pdf_update_stream(ctx, doc, dict, fzbuf, 0);

        writeobject(ctx, doc, opts, num, 0, 0, 0);
        fz_write_printf(ctx, opts->out, "startxref\n%lu\n%%%%EOF\n", startxref);
    }
    fz_always(ctx)
    {
        pdf_drop_obj(ctx, dict);
        pdf_drop_obj(ctx, w);
        fz_drop_buffer(ctx, fzbuf);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }

    doc->has_old_style_xrefs = 0;
}

static void
padto(fz_context *ctx, fz_output *out, int64_t target)
{
    int64_t pos = fz_tell_output(ctx, out);

    assert(pos <= target);
    while (pos < target)
    {
        fz_write_byte(ctx, out, '\n');
        pos++;
    }
}

static void
dowriteobject(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, int num, int pass)
{
    pdf_xref_entry *entry = pdf_get_xref_entry(ctx, doc, num);
    if (entry->type == 'f')
        opts->gen_list[num] = entry->gen;
    if (entry->type == 'n')
        opts->gen_list[num] = entry->gen;
    if (entry->type == 'o')
        opts->gen_list[num] = 0;

    /* If we are renumbering, then make sure all generation numbers are
     * zero (except object 0 which must be free, and have a gen number of
     * 65535). Changing the generation numbers (and indeed object numbers)
     * will break encryption - so only do this if we are renumbering
     * anyway. */
    if (opts->do_garbage >= 2)
        opts->gen_list[num] = (num == 0 ? 65535 : 0);

    if (opts->do_garbage && !opts->use_list[num])
        return;

    if (entry->type == 'n' || entry->type == 'o')
    {
        if (pass > 0)
            padto(ctx, opts->out, opts->ofs_list[num]);
        if (!opts->do_incremental || pdf_xref_is_incremental(ctx, doc, num))
        {
            opts->ofs_list[num] = fz_tell_output(ctx, opts->out);
            writeobject(ctx, doc, opts, num, opts->gen_list[num], 1, num == opts->crypt_object_number);
        }
    }
    else
        opts->use_list[num] = 0;
}

static void
writeobjects(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, int pass)
{
    int num;
    int xref_len = pdf_xref_len(ctx, doc);

    if (!opts->do_incremental)
    {
        fz_write_printf(ctx, opts->out, "%%PDF-%d.%d\n", doc->version / 10, doc->version % 10);
        fz_write_string(ctx, opts->out, "%\xC2\xB5\xC2\xB6\n\n");
    }

    dowriteobject(ctx, doc, opts, opts->start, pass);

    if (opts->do_linear)
    {
        /* Write first xref */
        if (pass == 0)
            opts->first_xref_offset = fz_tell_output(ctx, opts->out);
        else
            padto(ctx, opts->out, opts->first_xref_offset);
        writexref(ctx, doc, opts, opts->start, pdf_xref_len(ctx, doc), 1, opts->main_xref_offset, 0);
    }

    for (num = opts->start+1; num < xref_len; num++)
        dowriteobject(ctx, doc, opts, num, pass);
    if (opts->do_linear && pass == 1)
    {
        int64_t offset = (opts->start == 1 ? opts->main_xref_offset : opts->ofs_list[1] + opts->hintstream_len);
        padto(ctx, opts->out, offset);
    }
    for (num = 1; num < opts->start; num++)
    {
        if (pass == 1)
            opts->ofs_list[num] += opts->hintstream_len;
        dowriteobject(ctx, doc, opts, num, pass);
    }
}

static int
my_log2(int x)
{
    int i = 0;

    if (x <= 0)
        return 0;

    while ((1<<i) <= x && (1<<i) > 0)
        i++;

    if ((1<<i) <= 0)
        return 0;

    return i;
}

static void
make_page_offset_hints(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, fz_buffer *buf)
{
    int i, j;
    int min_objs_per_page, max_objs_per_page;
    int min_page_length, max_page_length;
    int objs_per_page_bits;
    int min_shared_object, max_shared_object;
    int max_shared_object_refs = 0;
    int min_shared_length, max_shared_length;
    page_objects **pop = &opts->page_object_lists->page[0];
    int page_len_bits, shared_object_bits, shared_object_id_bits;
    int shared_length_bits;
    int xref_len = pdf_xref_len(ctx, doc);

    min_shared_object = pdf_xref_len(ctx, doc);
    max_shared_object = 1;
    min_shared_length = opts->file_len;
    max_shared_length = 0;
    for (i=1; i < xref_len; i++)
    {
        int min, max, page;

        min = opts->ofs_list[i];
        if (i == opts->start-1 || (opts->start == 1 && i == xref_len-1))
            max = opts->main_xref_offset;
        else if (i == xref_len-1)
            max = opts->ofs_list[1];
        else
            max = opts->ofs_list[i+1];

        assert(max > min);

        if (opts->use_list[i] & USE_SHARED)
        {
            page = -1;
            if (i < min_shared_object)
                min_shared_object = i;
            if (i > max_shared_object)
                max_shared_object = i;
            if (min_shared_length > max - min)
                min_shared_length = max - min;
            if (max_shared_length < max - min)
                max_shared_length = max - min;
        }
        else if (opts->use_list[i] & (USE_CATALOGUE | USE_HINTS | USE_PARAMS))
            page = -1;
        else if (opts->use_list[i] & USE_PAGE1)
        {
            page = 0;
            if (min_shared_length > max - min)
                min_shared_length = max - min;
            if (max_shared_length < max - min)
                max_shared_length = max - min;
        }
        else if (opts->use_list[i] == 0)
            page = -1;
        else
            page = opts->use_list[i]>>USE_PAGE_SHIFT;

        if (page >= 0)
        {
            pop[page]->num_objects++;
            if (pop[page]->min_ofs > min)
                pop[page]->min_ofs = min;
            if (pop[page]->max_ofs < max)
                pop[page]->max_ofs = max;
        }
    }

    min_objs_per_page = max_objs_per_page = pop[0]->num_objects;
    min_page_length = max_page_length = pop[0]->max_ofs - pop[0]->min_ofs;
    for (i=1; i < opts->page_count; i++)
    {
        int tmp;
        if (min_objs_per_page > pop[i]->num_objects)
            min_objs_per_page = pop[i]->num_objects;
        if (max_objs_per_page < pop[i]->num_objects)
            max_objs_per_page = pop[i]->num_objects;
        tmp = pop[i]->max_ofs - pop[i]->min_ofs;
        if (tmp < min_page_length)
            min_page_length = tmp;
        if (tmp > max_page_length)
            max_page_length = tmp;
    }

    for (i=0; i < opts->page_count; i++)
    {
        int count = 0;
        page_objects *po = opts->page_object_lists->page[i];
        for (j = 0; j < po->len; j++)
        {
            if (i == 0 && opts->use_list[po->object[j]] & USE_PAGE1)
                count++;
            else if (i != 0 && opts->use_list[po->object[j]] & USE_SHARED)
                count++;
        }
        po->num_shared = count;
        if (i == 0 || count > max_shared_object_refs)
            max_shared_object_refs = count;
    }
    if (min_shared_object > max_shared_object)
        min_shared_object = max_shared_object = 0;

    /* Table F.3 - Header */
    /* Header Item 1: Least number of objects in a page */
    fz_append_bits(ctx, buf, min_objs_per_page, 32);
    /* Header Item 2: Location of first pages page object */
    fz_append_bits(ctx, buf, opts->ofs_list[pop[0]->page_object_number], 32);
    /* Header Item 3: Number of bits required to represent the difference
     * between the greatest and least number of objects in a page. */
    objs_per_page_bits = my_log2(max_objs_per_page - min_objs_per_page);
    fz_append_bits(ctx, buf, objs_per_page_bits, 16);
    /* Header Item 4: Least length of a page. */
    fz_append_bits(ctx, buf, min_page_length, 32);
    /* Header Item 5: Number of bits needed to represent the difference
     * between the greatest and least length of a page. */
    page_len_bits = my_log2(max_page_length - min_page_length);
    fz_append_bits(ctx, buf, page_len_bits, 16);
    /* Header Item 6: Least offset to start of content stream (Acrobat
     * sets this to always be 0) */
    fz_append_bits(ctx, buf, 0, 32);
    /* Header Item 7: Number of bits needed to represent the difference
     * between the greatest and least offset to content stream (Acrobat
     * sets this to always be 0) */
    fz_append_bits(ctx, buf, 0, 16);
    /* Header Item 8: Least content stream length. (Acrobat
     * sets this to always be 0) */
    fz_append_bits(ctx, buf, 0, 32);
    /* Header Item 9: Number of bits needed to represent the difference
     * between the greatest and least content stream length (Acrobat
     * sets this to always be the same as item 5) */
    fz_append_bits(ctx, buf, page_len_bits, 16);
    /* Header Item 10: Number of bits needed to represent the greatest
     * number of shared object references. */
    shared_object_bits = my_log2(max_shared_object_refs);
    fz_append_bits(ctx, buf, shared_object_bits, 16);
    /* Header Item 11: Number of bits needed to represent the greatest
     * shared object identifier. */
    shared_object_id_bits = my_log2(max_shared_object - min_shared_object + pop[0]->num_shared);
    fz_append_bits(ctx, buf, shared_object_id_bits, 16);
    /* Header Item 12: Number of bits needed to represent the numerator
     * of the fractions. We always send 0. */
    fz_append_bits(ctx, buf, 0, 16);
    /* Header Item 13: Number of bits needed to represent the denominator
     * of the fractions. We always send 0. */
    fz_append_bits(ctx, buf, 0, 16);

    /* Table F.4 - Page offset hint table (per page) */
    /* Item 1: A number that, when added to the least number of objects
     * on a page, gives the number of objects in the page. */
    for (i = 0; i < opts->page_count; i++)
    {
        fz_append_bits(ctx, buf, pop[i]->num_objects - min_objs_per_page, objs_per_page_bits);
    }
    fz_append_bits_pad(ctx, buf);
    /* Item 2: A number that, when added to the least page length, gives
     * the length of the page in bytes. */
    for (i = 0; i < opts->page_count; i++)
    {
        fz_append_bits(ctx, buf, pop[i]->max_ofs - pop[i]->min_ofs - min_page_length, page_len_bits);
    }
    fz_append_bits_pad(ctx, buf);
    /* Item 3: The number of shared objects referenced from the page. */
    for (i = 0; i < opts->page_count; i++)
    {
        fz_append_bits(ctx, buf, pop[i]->num_shared, shared_object_bits);
    }
    fz_append_bits_pad(ctx, buf);
    /* Item 4: Shared object id for each shared object ref in every page.
     * Spec says "not for page 1", but acrobat does send page 1's - all
     * as zeros. */
    for (i = 0; i < opts->page_count; i++)
    {
        for (j = 0; j < pop[i]->len; j++)
        {
            int o = pop[i]->object[j];
            if (i == 0 && opts->use_list[o] & USE_PAGE1)
                fz_append_bits(ctx, buf, 0 /* o - pop[0]->page_object_number */, shared_object_id_bits);
            if (i != 0 && opts->use_list[o] & USE_SHARED)
                fz_append_bits(ctx, buf, o - min_shared_object + pop[0]->num_shared, shared_object_id_bits);
        }
    }
    fz_append_bits_pad(ctx, buf);
    /* Item 5: Numerator of fractional position for each shared object reference. */
    /* We always send 0 in 0 bits */
    /* Item 6: A number that, when added to the least offset to the start
     * of the content stream (F.3 Item 6), gives the offset in bytes of
     * start of the pages content stream object relative to the beginning
     * of the page. Always 0 in 0 bits. */
    /* Item 7: A number that, when added to the least content stream length
     * (F.3 Item 8), gives the length of the pages content stream object.
     * Always == Item 2 as least content stream length = least page stream
     * length.
     */
    for (i = 0; i < opts->page_count; i++)
    {
        fz_append_bits(ctx, buf, pop[i]->max_ofs - pop[i]->min_ofs - min_page_length, page_len_bits);
    }

    /* Pad, and then do shared object hint table */
    fz_append_bits_pad(ctx, buf);
    opts->hints_shared_offset = (int)fz_buffer_storage(ctx, buf, NULL);

    /* Table F.5: */
    /* Header Item 1: Object number of the first object in the shared
     * objects section. */
    fz_append_bits(ctx, buf, min_shared_object, 32);
    /* Header Item 2: Location of first object in the shared objects
     * section. */
    fz_append_bits(ctx, buf, opts->ofs_list[min_shared_object], 32);
    /* Header Item 3: The number of shared object entries for the first
     * page. */
    fz_append_bits(ctx, buf, pop[0]->num_shared, 32);
    /* Header Item 4: The number of shared object entries for the shared
     * objects section + first page. */
    fz_append_bits(ctx, buf, max_shared_object - min_shared_object + pop[0]->num_shared, 32);
    /* Header Item 5: The number of bits needed to represent the greatest
     * number of objects in a shared object group (Always 0). */
    fz_append_bits(ctx, buf, 0, 16);
    /* Header Item 6: The least length of a shared object group in bytes. */
    fz_append_bits(ctx, buf, min_shared_length, 32);
    /* Header Item 7: The number of bits required to represent the
     * difference between the greatest and least length of a shared object
     * group. */
    shared_length_bits = my_log2(max_shared_length - min_shared_length);
    fz_append_bits(ctx, buf, shared_length_bits, 16);

    /* Table F.6 */
    /* Item 1: Shared object group length (page 1 objects) */
    for (j = 0; j < pop[0]->len; j++)
    {
        int o = pop[0]->object[j];
        int64_t min, max;
        min = opts->ofs_list[o];
        if (o == opts->start-1)
            max = opts->main_xref_offset;
        else if (o < xref_len-1)
            max = opts->ofs_list[o+1];
        else
            max = opts->ofs_list[1];
        if (opts->use_list[o] & USE_PAGE1)
            fz_append_bits(ctx, buf, max - min - min_shared_length, shared_length_bits);
    }
    /* Item 1: Shared object group length (shared objects) */
    for (i = min_shared_object; i <= max_shared_object; i++)
    {
        int min, max;
        min = opts->ofs_list[i];
        if (i == opts->start-1)
            max = opts->main_xref_offset;
        else if (i < xref_len-1)
            max = opts->ofs_list[i+1];
        else
            max = opts->ofs_list[1];
        fz_append_bits(ctx, buf, max - min - min_shared_length, shared_length_bits);
    }
    fz_append_bits_pad(ctx, buf);

    /* Item 2: MD5 presence flags */
    for (i = max_shared_object - min_shared_object + pop[0]->num_shared; i > 0; i--)
    {
        fz_append_bits(ctx, buf, 0, 1);
    }
    fz_append_bits_pad(ctx, buf);
    /* Item 3: MD5 sums (not present) */
    fz_append_bits_pad(ctx, buf);
    /* Item 4: Number of objects in the group (not present) */
}

static void
make_hint_stream(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)
{
    fz_buffer *buf = fz_new_buffer(ctx, 100);

    fz_try(ctx)
    {
        make_page_offset_hints(ctx, doc, opts, buf);
        pdf_update_stream(ctx, doc, pdf_load_object(ctx, doc, pdf_xref_len(ctx, doc)-1), buf, 0);
        opts->hintstream_len = (int)fz_buffer_storage(ctx, buf, NULL);
        fz_drop_buffer(ctx, buf);
    }
    fz_catch(ctx)
    {
        fz_drop_buffer(ctx, buf);
        fz_rethrow(ctx);
    }
}

static void presize_unsaved_signature_byteranges(fz_context *ctx, pdf_document *doc)
{
    int s;

    for (s = 0; s < doc->num_incremental_sections; s++)
    {
        pdf_xref *xref = &doc->xref_sections[s];

        if (xref->unsaved_sigs)
        {
            /* The ByteRange objects of signatures are initially written out with
            * dummy values, and then overwritten later. We need to make sure their
            * initial form at least takes enough sufficient file space */
            pdf_unsaved_sig *usig;
            int n = 0;

            for (usig = xref->unsaved_sigs; usig; usig = usig->next)
                n++;

            for (usig = xref->unsaved_sigs; usig; usig = usig->next)
            {
                /* There will be segments of bytes at the beginning, at
                * the end and between each consecutive pair of signatures,
                * hence n + 1 */
                int i;
                pdf_obj *byte_range = pdf_dict_getl(ctx, usig->field, PDF_NAME(V), PDF_NAME(ByteRange), NULL);

                for (i = 0; i < n+1; i++)
                {
                    pdf_array_push_int(ctx, byte_range, INT_MAX);
                    pdf_array_push_int(ctx, byte_range, INT_MAX);
                }
            }
        }
    }
}

static void complete_signatures(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)
{
    pdf_unsaved_sig *usig;
    char *buf = NULL;
    int buf_size;
    int s;
    int i;
    int last_end;
    fz_stream *stm = NULL;
    fz_var(stm);
    fz_var(buf);

    fz_try(ctx)
    {
        for (s = 0; s < doc->num_incremental_sections; s++)
        {
            pdf_xref *xref = &doc->xref_sections[doc->num_incremental_sections - s - 1];

            if (xref->unsaved_sigs)
            {
                pdf_obj *byte_range;
                buf_size = 0;

                for (usig = xref->unsaved_sigs; usig; usig = usig->next)
                {
                    int size = usig->signer->max_digest_size(usig->signer);

                    buf_size = fz_maxi(buf_size, size);
                }

                buf_size = buf_size * 2 + SIG_EXTRAS_SIZE;

                buf = fz_calloc(ctx, buf_size, 1);

                stm = fz_stream_from_output(ctx, opts->out);
                /* Locate the byte ranges and contents in the saved file */
                for (usig = xref->unsaved_sigs; usig; usig = usig->next)
                {
                    char *bstr, *cstr, *fstr;
                    int pnum = pdf_obj_parent_num(ctx, pdf_dict_getl(ctx, usig->field, PDF_NAME(V), PDF_NAME(ByteRange), NULL));
                    fz_seek(ctx, stm, opts->ofs_list[pnum], SEEK_SET);
                    (void)fz_read(ctx, stm, (unsigned char *)buf, buf_size);
                    buf[buf_size-1] = 0;

                    bstr = strstr(buf, "/ByteRange");
                    cstr = strstr(buf, "/Contents");
                    fstr = strstr(buf, "/Filter");

                    if (bstr && cstr && fstr && bstr < cstr && cstr < fstr)
                    {
                        usig->byte_range_start = bstr - buf + 10 + opts->ofs_list[pnum];
                        usig->byte_range_end = cstr - buf + opts->ofs_list[pnum];
                        usig->contents_start = cstr - buf + 9 + opts->ofs_list[pnum];
                        usig->contents_end = fstr - buf + opts->ofs_list[pnum];
                    }
                }

                fz_drop_stream(ctx, stm);
                stm = NULL;

                /* Recreate ByteRange with correct values. Initially store the
                * recreated object in the first of the unsaved signatures */
                byte_range = pdf_new_array(ctx, doc, 4);
                pdf_dict_putl_drop(ctx, xref->unsaved_sigs->field, byte_range, PDF_NAME(V), PDF_NAME(ByteRange), NULL);

                last_end = 0;
                for (usig = xref->unsaved_sigs; usig; usig = usig->next)
                {
                    pdf_array_push_int(ctx, byte_range, last_end);
                    pdf_array_push_int(ctx, byte_range, usig->contents_start - last_end);
                    last_end = usig->contents_end;
                }
                pdf_array_push_int(ctx, byte_range, last_end);
                pdf_array_push_int(ctx, byte_range, xref->end_ofs - last_end);

                /* Copy the new ByteRange to the other unsaved signatures */
                for (usig = xref->unsaved_sigs->next; usig; usig = usig->next)
                    pdf_dict_putl_drop(ctx, usig->field, pdf_copy_array(ctx, byte_range), PDF_NAME(V), PDF_NAME(ByteRange), NULL);

                /* Write the byte range into buf, padding with spaces*/
                i = pdf_sprint_obj(ctx, buf, buf_size, byte_range, 1);
                memset(buf+i, ' ', buf_size-i);

                /* Write the byte range to the file */
                for (usig = xref->unsaved_sigs; usig; usig = usig->next)
                {
                    fz_seek_output(ctx, opts->out, usig->byte_range_start, SEEK_SET);
                    fz_write_data(ctx, opts->out, buf, usig->byte_range_end - usig->byte_range_start);
                }

                /* Write the digests into the file */
                for (usig = xref->unsaved_sigs; usig; usig = usig->next)
                    pdf_write_digest(ctx, opts->out, byte_range, usig->contents_start, usig->contents_end - usig->contents_start, usig->signer);

                /* delete the unsaved_sigs records */
                while ((usig = xref->unsaved_sigs) != NULL)
                {
                    xref->unsaved_sigs = usig->next;
                    pdf_drop_obj(ctx, usig->field);
                    usig->signer->drop(usig->signer);
                    fz_free(ctx, usig);
                }

                xref->unsaved_sigs_end = NULL;

                fz_free(ctx, buf);
                buf = NULL;
            }
        }
    }
    fz_catch(ctx)
    {
        fz_drop_stream(ctx, stm);
        fz_free(ctx, buf);
        fz_rethrow(ctx);
    }
}

static void clean_content_streams(fz_context *ctx, pdf_document *doc, int sanitize, int ascii)
{
    int n = pdf_count_pages(ctx, doc);
    int i;

    for (i = 0; i < n; i++)
    {
        pdf_annot *annot;
        pdf_page *page = pdf_load_page(ctx, doc, i);
        pdf_clean_page_contents(ctx, doc, page, NULL, NULL, NULL, sanitize, ascii);

        for (annot = pdf_first_annot(ctx, page); annot != NULL; annot = pdf_next_annot(ctx, annot))
        {
            pdf_clean_annot_contents(ctx, doc, annot, NULL, NULL, NULL, sanitize, ascii);
        }

        fz_drop_page(ctx, &page->super);
    }
}

/* Initialise the pdf_write_state, used dynamically during the write, from the static
 * pdf_write_options, passed into pdf_save_document */
static void initialise_write_state(fz_context *ctx, pdf_document *doc, const pdf_write_options *in_opts, pdf_write_state *opts)
{
    int xref_len = pdf_xref_len(ctx, doc);

    opts->do_incremental = in_opts->do_incremental;
    opts->do_ascii = in_opts->do_ascii;
    opts->do_tight = !in_opts->do_pretty;
    opts->do_expand = in_opts->do_decompress;
    opts->do_compress = in_opts->do_compress;
    opts->do_compress_images = in_opts->do_compress_images;
    opts->do_compress_fonts = in_opts->do_compress_fonts;

    opts->do_garbage = in_opts->do_garbage;
    opts->do_linear = in_opts->do_linear;
    opts->do_clean = in_opts->do_clean;
    opts->start = 0;
    opts->main_xref_offset = INT_MIN;

    /* We deliberately make these arrays long enough to cope with
    * 1 to n access rather than 0..n-1, and add space for 2 new
    * extra entries that may be required for linearization. */
    opts->list_len = 0;
    opts->use_list = NULL;
    opts->ofs_list = NULL;
    opts->gen_list = NULL;
    opts->renumber_map = NULL;
    opts->rev_renumber_map = NULL;
    opts->continue_on_error = in_opts->continue_on_error;
    opts->errors = in_opts->errors;

    expand_lists(ctx, opts, xref_len);
}

/* Free the resources held by the dynamic write options */
static void finalise_write_state(fz_context *ctx, pdf_write_state *opts)
{
    fz_free(ctx, opts->use_list);
    fz_free(ctx, opts->ofs_list);
    fz_free(ctx, opts->gen_list);
    fz_free(ctx, opts->renumber_map);
    fz_free(ctx, opts->rev_renumber_map);
    pdf_drop_obj(ctx, opts->linear_l);
    pdf_drop_obj(ctx, opts->linear_h0);
    pdf_drop_obj(ctx, opts->linear_h1);
    pdf_drop_obj(ctx, opts->linear_o);
    pdf_drop_obj(ctx, opts->linear_e);
    pdf_drop_obj(ctx, opts->linear_n);
    pdf_drop_obj(ctx, opts->linear_t);
    pdf_drop_obj(ctx, opts->hints_s);
    pdf_drop_obj(ctx, opts->hints_length);
    page_objects_list_destroy(ctx, opts->page_object_lists);
}

static void
prepare_for_save(fz_context *ctx, pdf_document *doc, pdf_write_options *in_opts)
{
    doc->freeze_updates = 1;

    /* Rewrite (and possibly sanitize) the operator streams */
    if (in_opts->do_clean || in_opts->do_sanitize)
        clean_content_streams(ctx, doc, in_opts->do_sanitize, in_opts->do_ascii);

    pdf_finish_edit(ctx, doc);
    presize_unsaved_signature_byteranges(ctx, doc);
}

static void
change_identity(fz_context *ctx, pdf_document *doc)
{
    pdf_obj *identity = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(ID));
    pdf_obj *str;
    unsigned char rnd[16];

    if (pdf_array_len(ctx, identity) < 2)
        return;

    /* Maybe recalculate this in future. For now, just change the second one. */
    fz_memrnd(ctx, rnd, 16);
    str = pdf_new_string(ctx, (char *)rnd, 16);
    pdf_array_put_drop(ctx, identity, 1, str);

}

static void
do_pdf_save_document(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_write_options *in_opts)
{
    int lastfree;
    int num;
    int xref_len;

    if (in_opts->do_incremental)
    {
        /* If no changes, nothing to write */
        if (doc->num_incremental_sections == 0)
            return;
        if (opts->out)
        {
            fz_seek_output(ctx, opts->out, 0, SEEK_END);
            fz_write_string(ctx, opts->out, "\n");
        }
    }

    xref_len = pdf_xref_len(ctx, doc);

    fz_try(ctx)
    {
        initialise_write_state(ctx, doc, in_opts, opts);

        /* Make sure any objects hidden in compressed streams have been loaded */
        if (!opts->do_incremental)
        {
            pdf_ensure_solid_xref(ctx, doc, xref_len);
            preloadobjstms(ctx, doc);
            change_identity(ctx, doc);
            xref_len = pdf_xref_len(ctx, doc); /* May have changed due to repair */
            expand_lists(ctx, opts, xref_len);
        }

        /* Sweep & mark objects from the trailer */
        if (opts->do_garbage >= 1 || opts->do_linear)
            (void)markobj(ctx, doc, opts, pdf_trailer(ctx, doc));
        else
        {
            xref_len = pdf_xref_len(ctx, doc); /* May have changed due to repair */
            expand_lists(ctx, opts, xref_len);
            for (num = 0; num < xref_len; num++)
                opts->use_list[num] = 1;
        }

        /* Coalesce and renumber duplicate objects */
        if (opts->do_garbage >= 3)
            removeduplicateobjs(ctx, doc, opts);

        /* Compact xref by renumbering and removing unused objects */
        if (opts->do_garbage >= 2 || opts->do_linear)
            compactxref(ctx, doc, opts);

        opts->crypt_object_number = 0;

        if (doc->crypt)
        {
            pdf_obj *crypt = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(Encrypt));
            int crypt_num = pdf_to_num(ctx, crypt);
            opts->crypt_object_number = opts->renumber_map[crypt_num];
        }

        /* Make renumbering affect all indirect references and update xref */
        if (opts->do_garbage >= 2 || opts->do_linear)
            renumberobjs(ctx, doc, opts);

        /* Truncate the xref after compacting and renumbering */
        if ((opts->do_garbage >= 2 || opts->do_linear) && !opts->do_incremental)
        {
            xref_len = pdf_xref_len(ctx, doc); /* May have changed due to repair */
            expand_lists(ctx, opts, xref_len);
            while (xref_len > 0 && !opts->use_list[xref_len-1])
                xref_len--;
        }

        if (opts->do_linear)
            linearize(ctx, doc, opts);

        if (opts->do_incremental)
        {
            int i;

            doc->disallow_new_increments = 1;

            for (i = 0; i < doc->num_incremental_sections; i++)
            {
                doc->xref_base = doc->num_incremental_sections - i - 1;

                writeobjects(ctx, doc, opts, 0);

                for (num = 0; num < xref_len; num++)
                {
                    if (!opts->use_list[num] && pdf_xref_is_incremental(ctx, doc, num))
                    {
                        /* Make unreusable. FIXME: would be better to link to existing free list */
                        opts->gen_list[num] = 65535;
                        opts->ofs_list[num] = 0;
                    }
                }

                opts->first_xref_offset = fz_tell_output(ctx, opts->out);
                if (doc->has_xref_streams)
                    writexrefstream(ctx, doc, opts, 0, xref_len, 1, 0, opts->first_xref_offset);
                else
                    writexref(ctx, doc, opts, 0, xref_len, 1, 0, opts->first_xref_offset);

                doc->xref_sections[doc->xref_base].end_ofs = fz_tell_output(ctx, opts->out);
            }

            doc->xref_base = 0;
            doc->disallow_new_increments = 0;
        }
        else
        {
            writeobjects(ctx, doc, opts, 0);

            /* Construct linked list of free object slots */
            lastfree = 0;
            for (num = 0; num < xref_len; num++)
            {
                if (!opts->use_list[num])
                {
                    opts->gen_list[num]++;
                    opts->ofs_list[lastfree] = num;
                    lastfree = num;
                }
            }

            if (opts->do_linear && opts->page_count > 0)
            {
                opts->main_xref_offset = fz_tell_output(ctx, opts->out);
                writexref(ctx, doc, opts, 0, opts->start, 0, 0, opts->first_xref_offset);
                opts->file_len = fz_tell_output(ctx, opts->out);

                make_hint_stream(ctx, doc, opts);
                if (opts->do_ascii)
                {
                    opts->hintstream_len *= 2;
                    opts->hintstream_len += 1 + ((opts->hintstream_len+63)>>6);
                }
                opts->file_len += opts->hintstream_len;
                opts->main_xref_offset += opts->hintstream_len;
                update_linearization_params(ctx, doc, opts);
                fz_seek_output(ctx, opts->out, 0, 0);
                writeobjects(ctx, doc, opts, 1);

                padto(ctx, opts->out, opts->main_xref_offset);
                writexref(ctx, doc, opts, 0, opts->start, 0, 0, opts->first_xref_offset);
            }
            else
            {
                opts->first_xref_offset = fz_tell_output(ctx, opts->out);
                writexref(ctx, doc, opts, 0, xref_len, 1, 0, opts->first_xref_offset);
            }

            doc->xref_sections[0].end_ofs = fz_tell_output(ctx, opts->out);
        }

        complete_signatures(ctx, doc, opts);

        doc->dirty = 0;
    }
    fz_always(ctx)
    {
        finalise_write_state(ctx, opts);

        doc->freeze_updates = 0;
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}

void JM_write_document(fz_context *ctx, pdf_document *doc, fz_output *out, pdf_write_options *in_opts, int decrypt)
{
    if (decrypt == 0)
    {
        pdf_write_document(ctx, doc, out, in_opts);
        return;
    }
    pdf_write_options opts_defaults = { 0 };
    pdf_write_state opts = { 0 };

    if (!doc)
        return;

    if (!in_opts)
        in_opts = &opts_defaults;

    if (in_opts->do_incremental && doc->repair_attempted)
        fz_throw(ctx, FZ_ERROR_GENERIC, "Can't do incremental writes on a repaired file");
    if (in_opts->do_incremental && in_opts->do_garbage)
        fz_throw(ctx, FZ_ERROR_GENERIC, "Can't do incremental writes with garbage collection");
    if (in_opts->do_incremental && in_opts->do_linear)
        fz_throw(ctx, FZ_ERROR_GENERIC, "Can't do incremental writes with linearisation");
    if (pdf_has_unsaved_sigs(ctx, doc) && !out->as_stream)
        fz_throw(ctx, FZ_ERROR_GENERIC, "Can't write pdf that has unsaved sigs to a fz_output unless it supports fz_stream_from_output!");

    prepare_for_save(ctx, doc, in_opts);

    opts.out = out;

    do_pdf_save_document(ctx, doc, &opts, in_opts);
}

void JM_save_document(fz_context *ctx, pdf_document *doc, const char *filename, pdf_write_options *in_opts, int decrypt)
{
    if (decrypt == 0)
    {
        pdf_save_document(ctx, doc, filename, in_opts);
        return;
    }
    pdf_write_options opts_defaults = { 0 };
    pdf_write_state opts = { 0 };

    if (!doc)
        return;

    if (!in_opts)
        in_opts = &opts_defaults;

    if (in_opts->do_incremental && !doc->file)
        fz_throw(ctx, FZ_ERROR_GENERIC, "Can't do incremental writes on a new document");
    if (in_opts->do_incremental && doc->repair_attempted)
        fz_throw(ctx, FZ_ERROR_GENERIC, "Can't do incremental writes on a repaired file");
    if (in_opts->do_incremental && in_opts->do_garbage)
        fz_throw(ctx, FZ_ERROR_GENERIC, "Can't do incremental writes with garbage collection");
    if (in_opts->do_incremental && in_opts->do_linear)
        fz_throw(ctx, FZ_ERROR_GENERIC, "Can't do incremental writes with linearisation");

    prepare_for_save(ctx, doc, in_opts);

    if (in_opts->do_incremental)
    {
        /* If no changes, nothing to write */
        if (doc->num_incremental_sections == 0)
            return;
        opts.out = fz_new_output_with_path(ctx, filename, 1);
    }
    else
    {
        opts.out = fz_new_output_with_path(ctx, filename, 0);
    }
    fz_try(ctx)
    {
        do_pdf_save_document(ctx, doc, &opts, in_opts);
        fz_close_output(ctx, opts.out);
    }
    fz_always(ctx)
    {
        fz_drop_output(ctx, opts.out);
        opts.out = NULL;
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}


//----------------------------------------------------------------------------
// annotation types
//----------------------------------------------------------------------------
#define ANNOT_TEXT 0
#define ANNOT_LINK 1
#define ANNOT_FREETEXT 2
#define ANNOT_LINE 3
#define ANNOT_SQUARE 4
#define ANNOT_CIRCLE 5
#define ANNOT_POLYGON 6
#define ANNOT_POLYLINE 7
#define ANNOT_HIGHLIGHT 8
#define ANNOT_UNDERLINE 9
#define ANNOT_SQUIGGLY 10
#define ANNOT_STRIKEOUT 11
#define ANNOT_STAMP 12
#define ANNOT_CARET 13
#define ANNOT_INK 14
#define ANNOT_POPUP 15
#define ANNOT_FILEATTACHMENT 16
#define ANNOT_SOUND 17
#define ANNOT_MOVIE 18
#define ANNOT_WIDGET 19
#define ANNOT_SCREEN 20
#define ANNOT_PRINTERMARK 21
#define ANNOT_TRAPNET 22
#define ANNOT_WATERMARK 23
#define ANNOT_3D 24

//----------------------------------------------------------------------------
// annotation flag bits
//----------------------------------------------------------------------------
#define ANNOT_XF_Invisible 1 << (1-1)
#define ANNOT_XF_Hidden 1 << (2-1)
#define ANNOT_XF_Print 1 << (3-1)
#define ANNOT_XF_NoZoom 1 << (4-1)
#define ANNOT_XF_NoRotate 1 << (5-1)
#define ANNOT_XF_NoView 1 << (6-1)
#define ANNOT_XF_ReadOnly 1 << (7-1)
#define ANNOT_XF_Locked 1 << (8-1)
#define ANNOT_XF_ToggleNoView 1 << (9-1)
#define ANNOT_XF_LockedContents 1 << (10-1)

//----------------------------------------------------------------------------
// annotation line ending styles
//----------------------------------------------------------------------------
#define ANNOT_LE_None 0
#define ANNOT_LE_Square 1
#define ANNOT_LE_Circle 2
#define ANNOT_LE_Diamond 3
#define ANNOT_LE_OpenArrow 4
#define ANNOT_LE_ClosedArrow 5
#define ANNOT_LE_Butt 6
#define ANNOT_LE_ROpenArrow 7
#define ANNOT_LE_RClosedArrow 8
#define ANNOT_LE_Slash 9

//----------------------------------------------------------------------------
// annotation field (widget) types
//----------------------------------------------------------------------------
#define ANNOT_WG_NOT_WIDGET -1
#define ANNOT_WG_PUSHBUTTON 0
#define ANNOT_WG_CHECKBOX 1
#define ANNOT_WG_RADIOBUTTON 2
#define ANNOT_WG_TEXT 3
#define ANNOT_WG_LISTBOX 4
#define ANNOT_WG_COMBOBOX 5
#define ANNOT_WG_SIGNATURE 6

//----------------------------------------------------------------------------
// annotation text widget subtypes
//----------------------------------------------------------------------------
#define ANNOT_WG_TEXT_UNRESTRAINED 0
#define ANNOT_WG_TEXT_NUMBER 1
#define ANNOT_WG_TEXT_SPECIAL 2
#define ANNOT_WG_TEXT_DATE 3
#define ANNOT_WG_TEXT_TIME 4

//----------------------------------------------------------------------------
// annotation widget flags
//----------------------------------------------------------------------------
// Common to all field types
#define WIDGET_Ff_ReadOnly 1
#define WIDGET_Ff_Required 2
#define WIDGET_Ff_NoExport 4

// Text fields
#define WIDGET_Ff_Multiline 4096
#define WIDGET_Ff_Password 8192

#define WIDGET_Ff_FileSelect 1048576
#define WIDGET_Ff_DoNotSpellCheck 4194304
#define WIDGET_Ff_DoNotScroll 8388608
#define WIDGET_Ff_Comb 16777216
#define WIDGET_Ff_RichText 33554432

// Button fields
#define WIDGET_Ff_NoToggleToOff 16384
#define WIDGET_Ff_Radio 32768
#define WIDGET_Ff_Pushbutton 65536
#define WIDGET_Ff_RadioInUnison 33554432

// Choice fields
#define WIDGET_Ff_Combo 131072
#define WIDGET_Ff_Edit 262144
#define WIDGET_Ff_Sort 524288
#define WIDGET_Ff_MultiSelect 2097152
#define WIDGET_Ff_CommitOnSelCHange 67108864

//----------------------------------------------------------------------------
// return code for line end style string
//----------------------------------------------------------------------------
int JM_le_value(fz_context *ctx, char *le)
{
    if (!le) return ANNOT_LE_None;
    return pdf_line_ending_from_string(ctx, le);
}

//----------------------------------------------------------------------------
// return pdf_obj "border style" from Python str
//----------------------------------------------------------------------------
pdf_obj *JM_get_border_style(fz_context *ctx, PyObject *style)
{
    pdf_obj *val = PDF_NAME(S);
    if (!style) return val;
    char *s = JM_Python_str_AsChar(style);
    JM_PyErr_Clear;
    if (!s) return val;
    if      (!strncmp(s, "b", 1) || !strncmp(s, "B", 1)) val = PDF_NAME(B);
    else if (!strncmp(s, "d", 1) || !strncmp(s, "D", 1)) val = PDF_NAME(D);
    else if (!strncmp(s, "i", 1) || !strncmp(s, "I", 1)) val = PDF_NAME(I);
    else if (!strncmp(s, "u", 1) || !strncmp(s, "U", 1)) val = PDF_NAME(U);
    JM_Python_str_DelForPy3(s);
    return val;
}

//----------------------------------------------------------------------------
// Make /DA string of annotation
//----------------------------------------------------------------------------
const char *JM_expand_fname(const char **name)
{
    if (!*name) return "Helv";
    if (!strncmp(*name, "Co", 2)) return "Cour";
    if (!strncmp(*name, "co", 2)) return "Cour";
    if (!strncmp(*name, "Ti", 2)) return "TiRo";
    if (!strncmp(*name, "ti", 2)) return "TiRo";
    if (!strncmp(*name, "Sy", 2)) return "Symb";
    if (!strncmp(*name, "sy", 2)) return "Symb";
    if (!strncmp(*name, "Za", 2)) return "ZaDb";
    if (!strncmp(*name, "za", 2)) return "ZaDb";
    return "Helv";
}

void JM_make_annot_DA(fz_context *ctx, pdf_annot *annot, int ncol, float col[4], const char *fontname, float fontsize)
{
    fz_buffer *buf = NULL;
    fz_try(ctx)
    {
        buf = fz_new_buffer(ctx, 50);
       if (ncol == 1)
            fz_append_printf(ctx, buf, "%g g ", col[0]);
        else if (ncol == 3)
            fz_append_printf(ctx, buf, "%g %g %g rg ", col[0], col[1], col[2]);
        else
            fz_append_printf(ctx, buf, "%g %g %g %g k ", col[0], col[1], col[2], col[3]);
        fz_append_printf(ctx, buf, "/%s %g Tf", JM_expand_fname(&fontname), fontsize);
        char *da = NULL;
        size_t len = fz_buffer_storage(ctx, buf, &da);
        pdf_dict_put_string(ctx, annot->obj, PDF_NAME(DA), (const char *)da, len);
    }
    fz_always(ctx) fz_drop_buffer(ctx, buf);
    fz_catch(ctx) fz_rethrow(ctx);
    return;
}

//----------------------------------------------------------------------------
// refreshes the link and annotation tables of a page
//----------------------------------------------------------------------------
void refresh_link_table(fz_context *ctx, pdf_page *page)
{
    pdf_obj *annots_arr = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
    if (annots_arr)
    {
        fz_rect page_mediabox;
        fz_matrix page_ctm;
        pdf_page_transform(ctx, page, &page_mediabox, &page_ctm);
        page->links = pdf_load_link_annots(ctx, page->doc, annots_arr,
                                           pdf_to_num(ctx, page->obj), page_ctm);
        pdf_load_annots(ctx, page, annots_arr);
    }
    return;
}

//-----------------------------------------------------------------------------
// create a strike-out / underline / highlight annotation
//-----------------------------------------------------------------------------
struct fz_annot_s *JM_AnnotTextmarker(fz_context *ctx, pdf_page *page, fz_quad q, int type)
{
    pdf_annot *annot = NULL;
    float width = 0;
    float color[3] = {0,0,0};
    switch (type)
    {
        case PDF_ANNOT_HIGHLIGHT:
            color[0] = color[1] = 1; color[2] = 0;
            width = 1.0f;
            break;
        case PDF_ANNOT_UNDERLINE:
            color[0] = color[1] = 0; color[2] = 1;
            width = 0.07f;
            break;
        case PDF_ANNOT_SQUIGGLY:
            color[0] = color[1] = 0; color[2] = 1;
            width = 0.07f;
            break;
        case PDF_ANNOT_STRIKE_OUT:
            color[0] = 1; color[1] = color[2] = 0;
            width = 0.07f;
            break;
    }
    fz_try(ctx)
    {
        pdf_document *pdf = page->doc;
        annot = pdf_create_annot(ctx, page, type);
        pdf_set_annot_color(ctx, annot, 3, color);
        pdf_set_annot_border(ctx, annot, width);
        pdf_add_annot_quad_point(ctx, annot, q);
        pdf_set_annot_rect(ctx, annot, fz_rect_from_quad(q));
        pdf_update_annot(ctx, annot);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return (fz_annot *) annot;
}

//-----------------------------------------------------------------------------
// create a circle or rectangle annotation
//-----------------------------------------------------------------------------
struct fz_annot_s *JM_AnnotCircleOrRect(fz_context *ctx, pdf_page *page, PyObject *rect, int type)
{
    pdf_annot *annot;
    float col[3] = {0,0,0};
    float width  = 1;
    fz_try(ctx)
    {
        pdf_document *pdf = page->doc;
        annot = pdf_create_annot(ctx, page, type);
        pdf_set_annot_border(ctx, annot, width);
        pdf_set_annot_color(ctx, annot, 3, col);
        pdf_set_annot_rect(ctx, annot, JM_rect_from_py(rect));
        pdf_update_annot(ctx, annot);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return (fz_annot *) annot;
}

//-----------------------------------------------------------------------------
// create a polyline or polygon annotation
//-----------------------------------------------------------------------------
struct fz_annot_s *JM_AnnotMultiline(fz_context *ctx, pdf_page *page, PyObject *points, int type)
{
    pdf_annot *annot;
    fz_try(ctx)
    {
        float col[3] = {0,0,0};
        float width  = 1;
        fz_point point = {0,0};
        fz_rect rect;
        
        int n = 0, i;
        if (PySequence_Check(points)) n = PySequence_Size(points);
        if (n < 2) THROWMSG("invalid points list");
        annot = pdf_create_annot(ctx, page, type);
        for (i = 0; i < n; i++)
        {
            PyObject *p = PySequence_ITEM(points, i);
            if (!PySequence_Check(p) || PySequence_Size(p) != 2)
                THROWMSG("invalid points list");
            point.x = (float) PyFloat_AsDouble(PySequence_ITEM(p, 0));
            point.y = (float) PyFloat_AsDouble(PySequence_ITEM(p, 1));
            Py_CLEAR(p);
            pdf_add_annot_vertex(ctx, annot, point);
            if (i == 0)
            {
                rect.x0 = point.x;
                rect.y0 = point.y;
                rect.x1 = point.x;
                rect.y1 = point.y;
            }
            else
                rect = fz_include_point_in_rect(rect, point);
        }
        pdf_set_annot_border(ctx, annot, width); // standard: width = 1
        pdf_set_annot_color(ctx, annot, 3, col); // standard: black
        rect = fz_expand_rect(rect, 3 * width);
        pdf_set_annot_rect(ctx, annot, rect);
        pdf_update_annot(ctx, annot);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return (fz_annot *) annot;
}

PyObject *JM_annot_border(fz_context *ctx, pdf_obj *annot_obj)
{
    PyObject *res = PyDict_New();
    PyObject *dash_py   = PyList_New(0);
    PyObject *effect_py = PyList_New(0);
    int i;
    char *effect2 = NULL, *style = NULL;
    float width = -1.0f;
    int effect1 = -1;

    pdf_obj *o = pdf_dict_get(ctx, annot_obj, PDF_NAME(Border));
    if (pdf_is_array(ctx, o))
    {
        width = pdf_to_real(ctx, pdf_array_get(ctx, o, 2));
        if (pdf_array_len(ctx, o) == 4)
        {
            pdf_obj *dash = pdf_array_get(ctx, o, 3);
            for (i = 0; i < pdf_array_len(ctx, dash); i++)
                PyList_Append(dash_py, Py_BuildValue("i",
                              pdf_to_int(ctx, pdf_array_get(ctx, dash, i))));
        }
    }

    pdf_obj *bs_o = pdf_dict_get(ctx, annot_obj, PDF_NAME(BS));
    if (bs_o)
    {
        o = pdf_dict_get(ctx, bs_o, PDF_NAME(W));
        if (o) width = pdf_to_real(ctx, o);
        o = pdf_dict_get(ctx, bs_o, PDF_NAME(S));
        if (o) style = (char *) pdf_to_name(ctx, o);
        o = pdf_dict_get(ctx, bs_o, PDF_NAME(D));
        if (o)
        {
            for (i = 0; i < pdf_array_len(ctx, o); i++)
                PyList_Append(dash_py, Py_BuildValue("i",
                              pdf_to_int(ctx, pdf_array_get(ctx, o, i))));
        }
    }

    pdf_obj *be_o = pdf_dict_gets(ctx, annot_obj, "BE");
    if (be_o)
    {
        o = pdf_dict_get(ctx, be_o, PDF_NAME(S));
        if (o) effect2 = (char *) pdf_to_name(ctx, o);
        o = pdf_dict_get(ctx, be_o, PDF_NAME(I));
        if (o) effect1 = pdf_to_int(ctx, o);
    }

    PyList_Append(effect_py, Py_BuildValue("i", effect1));
    PyList_Append(effect_py, Py_BuildValue("s", effect2));

    PyDict_SetItemString(res, "width", Py_BuildValue("f", width));

    PyDict_SetItemString(res, "dashes", dash_py);

    PyDict_SetItemString(res, "style", Py_BuildValue("s", style));

    if (effect1 > -1) PyDict_SetItemString(res, "effect", effect_py);
    Py_CLEAR(effect_py);
    Py_CLEAR(dash_py);
    return res;
}

PyObject *JM_annot_set_border(fz_context *ctx, PyObject *border, pdf_document *doc, pdf_obj *annot_obj)
{
    if (!PyDict_Check(border))
    {
        JM_Warning("arg must be a dict");
        return NONE;     // not a dict
    }

    double nwidth = -1;                       // new width
    double owidth = -1;                       // old width
    PyObject *ndashes = NULL;                 // new dashes
    PyObject *odashes = NULL;                 // old dashes
    PyObject *nstyle  = NULL;                 // new style
    PyObject *ostyle  = NULL;                 // old style

    nwidth = PyFloat_AsDouble(PyDict_GetItemString(border, "width"));
    ndashes = PyDict_GetItemString(border, "dashes");
    nstyle  = PyDict_GetItemString(border, "style");

    // first get old border properties
    PyObject *oborder = JM_annot_border(ctx, annot_obj);
    owidth = PyFloat_AsDouble(PyDict_GetItemString(oborder, "width"));
    odashes = PyDict_GetItemString(oborder, "dashes");
    ostyle = PyDict_GetItemString(oborder, "style");

    // then delete any relevant entries
    pdf_dict_del(ctx, annot_obj, PDF_NAME(BS));
    pdf_dict_del(ctx, annot_obj, PDF_NAME(BE));
    pdf_dict_del(ctx, annot_obj, PDF_NAME(Border));

    Py_ssize_t i, n;
    int d;
    // populate new border array
    if (nwidth < 0) nwidth = owidth;     // no new width: take current
    if (nwidth < 0) nwidth = 0.0f;       // default if no width given
    if (!ndashes) ndashes = odashes;     // no new dashes: take old
    if (!nstyle)  nstyle  = ostyle;      // no new style: take old

    if (ndashes && PySequence_Check(ndashes) && PySequence_Size(ndashes) > 0)
    {
        n = PySequence_Size(ndashes);
        pdf_obj *darr = pdf_new_array(ctx, doc, n);
        for (i = 0; i < n; i++)
        {
            d = (int) PyInt_AsLong(PySequence_ITEM(ndashes, i));
            pdf_array_push_int(ctx, darr, (int64_t) d);
        }
        pdf_dict_putl_drop(ctx, annot_obj, darr, PDF_NAME(BS), PDF_NAME(D), NULL);
        nstyle = Py_BuildValue("s", "D");
    }

    pdf_dict_putl_drop(ctx, annot_obj, pdf_new_real(ctx, nwidth),
                               PDF_NAME(BS), PDF_NAME(W), NULL);

    pdf_obj *val = JM_get_border_style(ctx, nstyle);

    pdf_dict_putl_drop(ctx, annot_obj, val,
                               PDF_NAME(BS), PDF_NAME(S), NULL);

    PyErr_Clear();
    return NONE;
}

PyObject *JM_annot_colors(fz_context *ctx, pdf_obj *annot_obj)
{
    PyObject *res = PyDict_New();
    PyObject *bc = PyList_New(0);        // stroke colors
    PyObject *fc = PyList_New(0);        // fill colors

    int i;
    float col;
    pdf_obj *o = pdf_dict_get(ctx, annot_obj, PDF_NAME(C));
    if (pdf_is_array(ctx, o))
    {
        int n = pdf_array_len(ctx, o);
        for (i = 0; i < n; i++)
        {
            col = pdf_to_real(ctx, pdf_array_get(ctx, o, i));
            PyList_Append(bc, Py_BuildValue("f", col));
        }
    }
    PyDict_SetItemString(res, "stroke", bc);

    o = pdf_dict_gets(ctx, annot_obj, "IC");
    if (pdf_is_array(ctx, o))
    {
        int n = pdf_array_len(ctx, o);
        for (i = 0; i < n; i++)
        {
            col = pdf_to_real(ctx, pdf_array_get(ctx, o, i));
            PyList_Append(fc, Py_BuildValue("f", col));
        }
    }
    PyDict_SetItemString(res, "fill", fc);

    Py_CLEAR(bc);
    Py_CLEAR(fc);
    return res;
}


PyObject *JM_UnicodeFromASCII(const char *in);
//-----------------------------------------------------------------------------
// Plain text output. An identical copy of fz_print_stext_page_as_text,
// but lines within a block are concatenated by space instead a new-line
// character (which else leads to 2 new-lines).
//-----------------------------------------------------------------------------
void
JM_print_stext_page_as_text(fz_context *ctx, fz_output *out, fz_stext_page *page)
{
    fz_stext_block *block;
    fz_stext_line *line;
    fz_stext_char *ch;
    char utf[10];
    int i, n, last_char;

    for (block = page->first_block; block; block = block->next)
    {
        if (block->type == FZ_STEXT_BLOCK_TEXT)
        {
            int line_n = 0;
            for (line = block->u.t.first_line; line; line = line->next)
            {
                if (line_n > 0 && last_char != 10) fz_write_string(ctx, out, "\n");
                line_n++;
                for (ch = line->first_char; ch; ch = ch->next)
                {
                    n = fz_runetochar(utf, ch->c);
                    for (i = 0; i < n; i++)
                        fz_write_byte(ctx, out, utf[i]);
                    last_char = ch->c;
                }
            }
            fz_write_string(ctx, out, "\n");
        }
    }
}

//-----------------------------------------------------------------------------
// Functions for wordlist output
//-----------------------------------------------------------------------------
int JM_append_word(fz_context *ctx, PyObject *lines, fz_buffer *buff, fz_rect *wbbox,
                   int block_n, int line_n, int word_n)
{
    PyObject *litem = Py_BuildValue("ffffOiii", wbbox->x0, wbbox->y0, wbbox->x1, wbbox->y1,
                                    JM_StrFromBuffer(ctx, buff),
                                    block_n, line_n, word_n);
    PyList_Append(lines, litem);
    Py_CLEAR(litem);
    wbbox->x0 = wbbox->y0 = wbbox->x1 = wbbox->y1 = 0;
    return word_n + 1;                 // word counter
}

//-----------------------------------------------------------------------------
// Functions for dictionary output
//-----------------------------------------------------------------------------

// create the char rectangle from the char quad
fz_rect JM_char_bbox(fz_stext_line *line, fz_stext_char *ch)
{
    fz_rect r = fz_rect_from_quad(ch->quad);
    if (!fz_is_empty_rect(r)) return r;
    // we need to correct erroneous font!
    if ((r.y1 - r.y0) <= JM_EPS) r.y0 = r.y1 - ch->size;
    if ((r.x1 - r.x0) <= JM_EPS) r.x0 = r.x1 - ch->size;
    return r;
}

static int detect_super_script(fz_stext_line *line, fz_stext_char *ch)
{
    if (line->wmode == 0 && line->dir.x == 1 && line->dir.y == 0)
        return ch->origin.y < line->first_char->origin.y - ch->size * 0.1f;
    return 0;
}

static const char *font_full_name(fz_context *ctx, fz_font *font)
{
    const char *name = fz_font_name(ctx, font);
    const char *s = strchr(name, '+');
    return s ? s + 1 : name;
}

static void font_family_name(fz_context *ctx, fz_font *font, char *buf, int size)
{
    const char *name = font_full_name(ctx, font);
    fz_strlcpy(buf, name, size);
}

PyObject *
JM_style_begin_dict(fz_context *ctx, fz_font *font, float size, int sup)
{
    //JM_TRACE("entering JM_style_begin_dict");
    char family[80];
    font_family_name(ctx, font, family, sizeof family);
    int flags = sup;
    flags += fz_font_is_italic(ctx, font) * 2;
    flags += fz_font_is_serif(ctx, font) * 4;
    flags += fz_font_is_monospaced(ctx, font) * 8;
    flags += fz_font_is_bold(ctx, font) * 16;
    PyObject *span = PyDict_New();
    PyDict_SetItemString(span, "font", JM_UnicodeFromASCII(family));
    PyDict_SetItemString(span, "size", Py_BuildValue("f", size));
    PyDict_SetItemString(span, "flags", Py_BuildValue("i", flags));
    //JM_TRACE("leaving JM_style_begin_dict");
    return span;
}

void
JM_style_end_dict(fz_context *ctx, fz_buffer *buff, PyObject *span, PyObject *spanlist)
{
    if (buff) 
        PyDict_SetItemString(span, "text",  JM_StrFromBuffer(ctx, buff));
    PyList_Append(spanlist, span);
}

PyObject *
JM_extract_stext_textchar_as_dict(fz_context *ctx, fz_stext_char *ch, fz_rect *ch_bbox)
{
    //JM_TRACE("entering JM_extract_stext_textchar_as_dict");
    char data[10];
    Py_ssize_t len = (Py_ssize_t) fz_runetochar(data, ch->c);
    PyObject *chardict = PyDict_New();
    PyDict_SetItemString(chardict, "c",  PyUnicode_FromStringAndSize(data, len));
    PyDict_SetItemString(chardict, "origin",  Py_BuildValue("ff", ch->origin.x, ch->origin.y));
    PyDict_SetItemString(chardict, "bbox",   Py_BuildValue("ffff",
                                     ch_bbox->x0, ch_bbox->y0,
                                     ch_bbox->x1, ch_bbox->y1));
    //JM_TRACE("leaving JM_extract_stext_textchar_as_dict");
    return chardict;
}

PyObject *
JM_extract_stext_textblock_as_dict(fz_context *ctx, fz_stext_block *block, int rawdict)
{
    //JM_TRACE("enter: JM_extract_stext_textblock_as_dict");
    fz_stext_line *line;
    fz_stext_char *ch;
    fz_font *font = NULL;
    fz_buffer *buff = NULL;
    float size = 0;
    int sup = 0;
    PyObject *span = NULL, *spanlist = NULL, *linelist = NULL, *linedict = NULL;
    PyObject *charlist = NULL, *chardict = NULL;
    linelist = PyList_New(0);
    PyObject *dict = PyDict_New();
    fz_rect blockrect = block->bbox, linerect, ch_bbox;
    PyDict_SetItemString(dict, "type",  PyInt_FromLong(FZ_STEXT_BLOCK_TEXT));
    //JM_TRACE("before line loop");
    for (line = block->u.t.first_line; line; line = line->next)
    {
        linedict = PyDict_New();
        linerect = line->bbox;
        PyDict_SetItemString(linedict, "wmode",  Py_BuildValue("i", line->wmode));
        PyDict_SetItemString(linedict, "dir",  Py_BuildValue("ff", line->dir.x, line->dir.y));
        spanlist = PyList_New(0);
        font = NULL;
        buff = NULL;
        size = 0;
        //JM_TRACE("before character loop");
        for (ch = line->first_char; ch; ch = ch->next)
        {
            ch_bbox = JM_char_bbox(line, ch);
            linerect = fz_union_rect(linerect, ch_bbox);
            //JM_TRACE("joined char bbox to linerect");
            int ch_sup = detect_super_script(line, ch);
            if (ch->font != font || ch->size != size)
            {   // start new span
                //JM_TRACE("starting new span");
                if (font)    // must finish old span first
                {
                    //JM_TRACE("finishing old span");
                    if (rawdict)
                    {
                        PyDict_SetItemString(span, "chars",  charlist);
                        Py_CLEAR(charlist);
                    }
                    JM_style_end_dict(ctx, buff, span, spanlist);
                    Py_CLEAR(span);
                    fz_drop_buffer(ctx, buff);
                    buff = NULL;
                    font = NULL;
                    //JM_TRACE("finished old span");
                }
                font = ch->font;
                size = ch->size;
                sup = ch_sup;
                span = JM_style_begin_dict(ctx, font, size, sup);
                if (rawdict)
                    charlist = PyList_New(0);
                else
                    buff = fz_new_buffer(ctx, 64);
                //JM_TRACE("new span started");
            }
            if (!rawdict)
                fz_append_rune(ctx, buff, ch->c);
            else 
            {
                chardict = JM_extract_stext_textchar_as_dict(ctx, ch, &ch_bbox);
                PyList_Append(charlist, chardict);
                Py_CLEAR(chardict);
            }
            //JM_TRACE("finished one char");
        }
        if (font)
        {
            //JM_TRACE("start output last span");
            if (rawdict)
            {
                PyDict_SetItemString(span, "chars",  charlist);
                Py_CLEAR(charlist);
            }
            JM_style_end_dict(ctx, buff, span, spanlist);
            Py_CLEAR(span);
            fz_drop_buffer(ctx, buff);
            buff = NULL;
            font = NULL;
        }
        //JM_TRACE("finishing line");
        PyDict_SetItemString(linedict, "spans",  spanlist);
        Py_CLEAR(spanlist);
        PyDict_SetItemString(linedict, "bbox",   Py_BuildValue("ffff",
                                         linerect.x0, linerect.y0,
                                         linerect.x1, linerect.y1));

        blockrect = fz_union_rect(blockrect, linerect);

        PyList_Append(linelist, linedict);
        Py_CLEAR(linedict);
    }
    //JM_TRACE("after line loop");
    PyDict_SetItemString(dict, "lines",  linelist);
    Py_CLEAR(linelist);
    PyDict_SetItemString(dict, "bbox",   Py_BuildValue("ffff",
                                         blockrect.x0, blockrect.y0,
                                         blockrect.x1, blockrect.y1));
    //JM_TRACE("leaving JM_extract_stext_textblock_as_dict");
    return dict;
}

PyObject *
JM_extract_stext_imageblock_as_dict(fz_context *ctx, fz_stext_block *block)
{
    fz_image *image = block->u.i.image;
    fz_buffer *buf = NULL, *freebuf = NULL;
    fz_var(buf);
    fz_var(freebuf);
    fz_compressed_buffer *buffer = NULL;
    int n = fz_colorspace_n(ctx, image->colorspace);
    int w = image->w;
    int h = image->h;
    int type = 0;
    unsigned char ext[5];
    PyObject *bytes = JM_BinFromChar("");
    fz_var(bytes);
    buffer = fz_compressed_image_buffer(ctx, image);
    if (buffer) type = buffer->params.type;
    PyObject *dict = PyDict_New();
    PyDict_SetItemString(dict, "type",  PyInt_FromLong(FZ_STEXT_BLOCK_IMAGE));
    PyDict_SetItemString(dict, "bbox",   Py_BuildValue("[ffff]",
                                         block->bbox.x0, block->bbox.y0,
                                         block->bbox.x1, block->bbox.y1));
    PyDict_SetItemString(dict, "width",  PyInt_FromLong((long) w));
    PyDict_SetItemString(dict, "height", PyInt_FromLong((long) h));
    fz_try(ctx)
    {
        if (image->use_colorkey) type = FZ_IMAGE_UNKNOWN;
        if (image->use_decode)   type = FZ_IMAGE_UNKNOWN;
        if (image->mask)         type = FZ_IMAGE_UNKNOWN;
        if (type < FZ_IMAGE_BMP) type = FZ_IMAGE_UNKNOWN;
        if (n != 1 && n != 3 && type == FZ_IMAGE_JPEG)
            type = FZ_IMAGE_UNKNOWN;
        if (type != FZ_IMAGE_UNKNOWN)
        {
            buf = buffer->buffer;
            switch(type)
            {
                case(FZ_IMAGE_BMP):  strcpy(ext, "bmp");  break;
                case(FZ_IMAGE_GIF):  strcpy(ext, "gif");  break;
                case(FZ_IMAGE_JPEG): strcpy(ext, "jpeg"); break;
                case(FZ_IMAGE_JPX):  strcpy(ext, "jpx");  break;
                case(FZ_IMAGE_JXR):  strcpy(ext, "jxr");  break;
                case(FZ_IMAGE_PNM):  strcpy(ext, "pnm");  break;
                case(FZ_IMAGE_TIFF): strcpy(ext, "tiff"); break;
                default:             strcpy(ext, "png");  break;
            }
        }
        else
        {
            buf = freebuf = fz_new_buffer_from_image_as_png(ctx, image, NULL);
            strcpy(ext, "png");
        }
        if (PY_MAJOR_VERSION > 2)
            bytes = JM_BinFromBuffer(ctx, buf);
        else 
            bytes = JM_BArrayFromBuffer(ctx, buf);
    }
    fz_always(ctx)
    {
        fz_drop_buffer(ctx, freebuf);
        PyDict_SetItemString(dict, "ext",  PyString_FromString(ext));
        PyDict_SetItemString(dict, "image",  bytes);
        Py_CLEAR(bytes);
    }
    fz_catch(ctx) {;}
    return dict;
}

PyObject *
JM_stext_page_as_dict(fz_context *ctx, fz_stext_page *page, int rawdict)
{
    PyObject *dict = PyDict_New();
    PyObject *blocklist = PyList_New(0);
    fz_stext_block *block;
    float w = page->mediabox.x1 - page->mediabox.x0;
    float h = page->mediabox.y1 - page->mediabox.y0;
    PyDict_SetItemString(dict, "width", Py_BuildValue("f", w));
    PyDict_SetItemString(dict, "height", Py_BuildValue("f", h));
    for (block = page->first_block; block; block = block->next)
    {
        if (block->type == FZ_STEXT_BLOCK_IMAGE)
            PyList_Append(blocklist, JM_extract_stext_imageblock_as_dict(ctx, block));
        else
            PyList_Append(blocklist, JM_extract_stext_textblock_as_dict(ctx, block, rawdict));
    }
    PyDict_SetItemString(dict, "blocks", blocklist);
    Py_CLEAR(blocklist);
    return dict;
}


//-----------------------------------------------------------------------------
// Functions dealing with PDF form fields
//-----------------------------------------------------------------------------

// PushButton get state
//-----------------------------------------------------------------------------
PyObject *JM_pushbtn_state(fz_context *ctx, pdf_annot *annot)
{   // pushed buttons do not reflect status changes in the PDF
    // always reflect them as untouched
    Py_RETURN_FALSE;
}

// CheckBox get state
//-----------------------------------------------------------------------------
PyObject *JM_checkbox_state(fz_context *ctx, pdf_annot *annot)
{
    pdf_obj *leafv  = pdf_dict_get_inheritable(ctx, annot->obj, PDF_NAME(V));
    pdf_obj *leafas = pdf_dict_get_inheritable(ctx, annot->obj, PDF_NAME(AS));
    if (!leafv) Py_RETURN_FALSE;
    if (leafv  == PDF_NAME(Off)) Py_RETURN_FALSE;
    if (leafv == pdf_new_name(ctx, "Yes"))
        Py_RETURN_TRUE;
    if (pdf_is_string(ctx, leafv) && !strcmp(pdf_to_str_buf(ctx, leafv), "Off"))
        Py_RETURN_FALSE;
    if (pdf_is_string(ctx, leafv) && !strcmp(pdf_to_str_buf(ctx, leafv), "Yes"))
        Py_RETURN_TRUE;
    if (leafas && leafas == PDF_NAME(Off)) Py_RETURN_FALSE;
    Py_RETURN_TRUE;
}

// RadioBox get state
//-----------------------------------------------------------------------------
PyObject *JM_radiobtn_state(fz_context *ctx, pdf_annot *annot)
{   // MuPDF treats radio buttons like check boxes - hence so do we
    return JM_checkbox_state(ctx, annot);
}

// Text field retrieve value
//-----------------------------------------------------------------------------
PyObject *JM_text_value(fz_context *ctx, pdf_annot *annot)
{
    char *text = NULL;
    pdf_document *pdf = pdf_get_bound_document(ctx, annot->obj);
    fz_var(text);
    fz_try(ctx)
        text = pdf_field_value(ctx, pdf, annot->obj);
    fz_catch(ctx) return NONE;
    return Py_BuildValue("s", text);
}

// ListBox retrieve value
//-----------------------------------------------------------------------------
PyObject *JM_listbox_value(fz_context *ctx, pdf_annot *annot)
{
    int i = 0, n = 0;
    // may be single value or array
    pdf_obj *optarr = pdf_dict_get(ctx, annot->obj, PDF_NAME(V));
    if (pdf_is_string(ctx, optarr))         // a single string
        return PyString_FromString(pdf_to_text_string(ctx, optarr));

    // value is an array (may have len 0)
    n = pdf_array_len(ctx, optarr);
    PyObject *liste = PyList_New(0);

    // extract a list of strings
    // each entry may again be an array: take second entry then
    for (i = 0; i < n; i++)
    {
        pdf_obj *elem = pdf_array_get(ctx, optarr, i);
        if (pdf_is_array(ctx, elem))
            elem = pdf_array_get(ctx, elem, 1);
        PyList_Append(liste, PyString_FromString(pdf_to_text_string(ctx, elem)));
    }
    return liste;
}

// ComboBox retrieve value
//-----------------------------------------------------------------------------
PyObject *JM_combobox_value(fz_context *ctx, pdf_annot *annot)
{   // combobox values are treated like listbox values
    return JM_listbox_value(ctx, annot);
}

// Signature field retrieve value
PyObject *JM_signature_value(fz_context *ctx, pdf_annot *annot)
{   // signatures are currently not supported
    return NONE;
}

// retrieve ListBox / ComboBox choice values
//-----------------------------------------------------------------------------
PyObject *JM_choice_options(fz_context *ctx, pdf_annot *annot)
{   // return list of choices for list or combo boxes
    pdf_document *pdf = pdf_get_bound_document(ctx, annot->obj);
    int n = pdf_choice_widget_options(ctx, pdf, (pdf_widget *) annot, 0, NULL);
    if (n == 0) return NONE;                     // wrong widget type

    pdf_obj *optarr = pdf_dict_get(ctx, annot->obj, PDF_NAME(Opt));
    int i, m;
    PyObject *liste = PyList_New(0);

    for (i = 0; i < n; i++)
    {
        m = pdf_array_len(ctx, pdf_array_get(ctx, optarr, i));
        if (m == 2)
        {
            PyList_Append(liste, Py_BuildValue("ss",
            pdf_to_text_string(ctx, pdf_array_get(ctx, pdf_array_get(ctx, optarr, i), 0)),
            pdf_to_text_string(ctx, pdf_array_get(ctx, pdf_array_get(ctx, optarr, i), 1))));
        }
        else
        {
            PyList_Append(liste, PyString_FromString(pdf_to_text_string(ctx, pdf_array_get(ctx, optarr, i))));
        }
    }
    return liste;
}

// set ListBox / ComboBox values
//-----------------------------------------------------------------------------
void JM_set_choice_options(fz_context *ctx, pdf_annot *annot, PyObject *liste)
{
    pdf_document *pdf = pdf_get_bound_document(ctx, annot->obj);
    Py_ssize_t i, n = PySequence_Size(liste);
    char *opt = NULL;
    pdf_obj *optarr = pdf_new_array(ctx, pdf, n);
    for (i = 0; i < n; i++)
    {
        opt = JM_Python_str_AsChar(PySequence_ITEM(liste, i));
        pdf_array_push_text_string(ctx, optarr, (const char *) opt);
        JM_Python_str_DelForPy3(opt);
    }

    pdf_dict_put(ctx, annot->obj, PDF_NAME(Opt), optarr);

    return;
}

//-----------------------------------------------------------------------------
// Called by "Page.addWidget" and "Annot.updateWidget".
// Set all properties of a new or updated widget, whether changed or not.
// Should be no performance issue, because verifying a change before updating
// is costly as well (and a code bloat). No problem on the PDF side, because
// any change will always lead to the complete new PDF object being stored.
//-----------------------------------------------------------------------------
void JM_set_widget_properties(fz_context *ctx, pdf_annot *annot, PyObject *Widget, int field_type)
{
    pdf_document *pdf = annot->page->doc;
    pdf_page *page = annot->page;
    fz_rect rect;
    pdf_obj *fill_col = NULL, *text_col = NULL, *border_col = NULL;
    pdf_obj *dashes = NULL;
    Py_ssize_t i, n = 0;
    PyObject *value;

    // ensure a font resources dict /DR --- -----------------------------------
    pdf_obj *dr = pdf_dict_getl(ctx, pdf_trailer(ctx, pdf),
                           PDF_NAME(Root), PDF_NAME(AcroForm), PDF_NAME(DR), NULL);
    // new /DR using the object prepared in xref
    if (!dr)
    {
        pdf_obj *form = pdf_dict_getl(ctx, pdf_trailer(ctx, pdf),
                                        PDF_NAME(Root), PDF_NAME(AcroForm), NULL);
        int xref = (int) PyInt_AsLong(PyObject_GetAttrString(Widget,
                                                                   "_dr_xref"));
        pdf_obj *f = pdf_new_indirect(ctx, pdf, xref, 0);
        dr = pdf_new_dict(ctx, pdf, 1);
        pdf_dict_put(ctx, dr, PDF_NAME(Font), f);
        pdf_dict_put_drop(ctx, form, PDF_NAME(DR), dr);
        JM_PyErr_Clear;
    }

    // rectangle --------------------------------------------------------------
    value = PyObject_GetAttrString(Widget, "rect");
    rect = JM_rect_from_py(value);
    Py_CLEAR(value);
    pdf_set_annot_rect(ctx, annot, rect);    // set the rect

    // fill color -------------------------------------------------------------
    value = PyObject_GetAttrString(Widget, "fill_color");
    if (value && PySequence_Check(value))
    {
        n = PySequence_Size(value);
        fill_col = pdf_new_array(ctx, pdf, n);
        for (i = 0; i < n; i++)
            pdf_array_push_real(ctx, fill_col,
                                PyFloat_AsDouble(PySequence_ITEM(value, i)));
        pdf_field_set_fill_color(ctx, pdf, annot->obj, fill_col);
        pdf_drop_obj(ctx, fill_col);
    }
    Py_CLEAR(value);
    JM_PyErr_Clear;

    // dashes -----------------------------------------------------------------
    value = PyObject_GetAttrString(Widget, "border_dashes");
    if (value && PySequence_Check(value))
    {
        n = PySequence_Size(value);
        dashes = pdf_new_array(ctx, pdf, n);
        for (i = 0; i < n; i++)
            pdf_array_push_int(ctx, dashes,
                                    PyInt_AsLong(PySequence_ITEM(value, i)));
        pdf_dict_putl_drop(ctx, annot->obj, dashes, PDF_NAME(BS),
                                                              PDF_NAME(D), NULL);
    }
    Py_CLEAR(value);
    JM_PyErr_Clear;

    // border color -----------------------------------------------------------
    value = PyObject_GetAttrString(Widget, "border_color");
    if (value && PySequence_Check(value))
    {
        n = PySequence_Size(value);
        border_col = pdf_new_array(ctx, pdf, n);
        for (i = 0; i < n; i++)
            pdf_array_push_real(ctx, border_col,
                                PyFloat_AsDouble(PySequence_ITEM(value, i)));
        pdf_dict_putl_drop(ctx, annot->obj, border_col, PDF_NAME(MK),
                                                             PDF_NAME(BC), NULL);
    }
    Py_CLEAR(value);
    JM_PyErr_Clear;

    // entry ignored - may be later use
    /*
    int text_type = (int) PyInt_AsLong(PyObject_GetAttrString(Widget,
                                                                  "text_type"));
    JM_PyErr_Clear;
    */

    // max text len -----------------------------------------------------------
    if (field_type == PDF_WIDGET_TYPE_TEXT)
    {
        int text_maxlen = (int) PyInt_AsLong(PyObject_GetAttrString(Widget,
                                                               "text_maxlen"));
        if (text_maxlen)
            pdf_dict_put_int(ctx, annot->obj, PDF_NAME(MaxLen), text_maxlen);
        JM_PyErr_Clear;
    }
    
    // choice values ----------------------------------------------------------
    if (field_type == PDF_WIDGET_TYPE_LISTBOX ||
        field_type == PDF_WIDGET_TYPE_COMBOBOX)
    {
        value = PyObject_GetAttrString(Widget, "choice_values");
        JM_set_choice_options(ctx, annot, value);
        Py_CLEAR(value);
    }
    JM_PyErr_Clear;

    // border style -----------------------------------------------------------
    pdf_obj *val = JM_get_border_style(ctx,
                                PyObject_GetAttrString(Widget, "border_style"));
    pdf_dict_putl_drop(ctx, annot->obj, val, PDF_NAME(BS), PDF_NAME(S), NULL);

    // border width -----------------------------------------------------------
    float border_width = (float) PyFloat_AsDouble(PyObject_GetAttrString(Widget,
                                                               "border_width"));
    pdf_dict_putl_drop(ctx, annot->obj, pdf_new_real(ctx, border_width),
                       PDF_NAME(BS), PDF_NAME(W), NULL);
    JM_PyErr_Clear;

    // /DA string -------------------------------------------------------------
    char *da = JM_Python_str_AsChar(PyObject_GetAttrString(Widget, "_text_da"));
    if (da)
    {
        pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(DA), da);
        JM_Python_str_DelForPy3(da);
        pdf_dict_dels(ctx, annot->obj, "DS");  // unsupported
        pdf_dict_dels(ctx, annot->obj, "RC");  // unsupported
    }
    JM_PyErr_Clear;

    // field flags ------------------------------------------------------------
    int field_flags = 0, Ff = 0;
    if (field_type != PDF_WIDGET_TYPE_CHECKBOX)
    {
        field_flags = (int) PyInt_AsLong(PyObject_GetAttrString(Widget,
                                                                "field_flags"));
        if (!PyErr_Occurred())
        {
            Ff = pdf_get_field_flags(ctx, pdf, annot->obj);
            Ff |= field_flags;
        }
        JM_PyErr_Clear;
    }
    pdf_dict_put_int(ctx, annot->obj, PDF_NAME(Ff), Ff);

    // button caption ---------------------------------------------------------
    if (field_type == PDF_WIDGET_TYPE_RADIOBUTTON ||
        field_type == PDF_WIDGET_TYPE_PUSHBUTTON ||
        field_type == PDF_WIDGET_TYPE_CHECKBOX)
    {
        char *ca = JM_Python_str_AsChar(PyObject_GetAttrString(Widget,
                                                             "button_caption"));
        if (ca)
        {
            pdf_dict_putl(ctx, annot->obj, pdf_new_text_string(ctx, ca),
                          PDF_NAME(MK), PDF_NAME(CA), NULL);
            JM_Python_str_DelForPy3(ca);
        }
        JM_PyErr_Clear;
    }

    // field value ------------------------------------------------------------
    // MuPDF function "pdf_field_set_value" always sets strings. For button
    // fields this may lead to an unrecognized state for some PDF viewers.
    //-------------------------------------------------------------------------
    value = PyObject_GetAttrString(Widget, "field_value");
    int result = 0;
    char *text = NULL;
    switch(field_type)
    {
    case PDF_WIDGET_TYPE_CHECKBOX:
    case PDF_WIDGET_TYPE_RADIOBUTTON:
        if (PyObject_RichCompareBool(value, Py_True, Py_EQ))
        {
            result = pdf_field_set_value(ctx, pdf, annot->obj, "Yes");
            pdf_dict_put_name(ctx, annot->obj, PDF_NAME(V), "Yes");
        }
        else
        {
            result = pdf_field_set_value(ctx, pdf, annot->obj, "Off");
            pdf_dict_put(ctx, annot->obj, PDF_NAME(V), PDF_NAME(Off));
        }
        break;
    default:
        text = JM_Python_str_AsChar(value);
        if (text)
        {
            result = pdf_field_set_value(ctx, pdf, annot->obj, (const char *)text);
            JM_Python_str_DelForPy3(text);
        }
    }
    Py_CLEAR(value);
    pdf_dirty_annot(ctx, annot);
    pdf_update_page(gctx, page);
}



//----------------------------------------------------------------------------
// portfolio schema types
//----------------------------------------------------------------------------
#define PDF_SCHEMA_NUMBER 0
#define PDF_SCHEMA_SIZE 1
#define PDF_SCHEMA_TEXT 2
#define PDF_SCHEMA_DATE 3
#define PDF_SCHEMA_DESC 4
#define PDF_SCHEMA_MODDATE 5
#define PDF_SCHEMA_CREATIONDATE 6
#define PDF_SCHEMA_FILENAME 7
#define PDF_SCHEMA_UNKNOWN 8
//-----------------------------------------------------------------------------
// finds index of an embedded file in a pdf
// Object "id" contains either the entry name (str) or the index. An index is
// only checked for valid range.
//-----------------------------------------------------------------------------
int JM_find_embedded(fz_context *ctx, PyObject *id, pdf_document *pdf)
{
    char *name = NULL;
    char *tname= NULL;
    int i = -1, count = pdf_count_portfolio_entries(ctx, pdf);
    if (count < 1) return -1;

    // just return the integer id if in range
    if (PyInt_Check(id))
    {
        i = (int) PyInt_AsLong(id);
        if (!INRANGE(i, 0, (count-1))) return -1;
        return i;
    }
    name = JM_Python_str_AsChar(id);
    if (!name || strlen(name) == 0) return -1;
    for (i = 0; i < count; i++)
    {
        tname = (char *) pdf_to_text_string(ctx, pdf_portfolio_entry_name(ctx, pdf, i));
        if (!strcmp(tname, name))
        {
            JM_Python_str_DelForPy3(name);
            return i;
        }
    }
    JM_Python_str_DelForPy3(name);
    return -1;
}

//-----------------------------------------------------------------------------
// Return the /Names object for embedded files
//-----------------------------------------------------------------------------
pdf_obj *JM_embedded_names(fz_context *ctx, pdf_document *pdf)
{
    pdf_obj *names = NULL, *kids = NULL, *o = NULL;
    int i, n;
    names = pdf_dict_getl(ctx, pdf_trailer(ctx, pdf), PDF_NAME(Root),                                         PDF_NAME(Names), PDF_NAME(EmbeddedFiles),
                         PDF_NAME(Names), NULL);
    if (names) return names;
    
    // not found, therefore a /Kids object contains the /Names
    kids = pdf_dict_getl(ctx, pdf_trailer(ctx, pdf), PDF_NAME(Root),
                         PDF_NAME(Names), PDF_NAME(EmbeddedFiles),
                        PDF_NAME(Kids), NULL);
    //-------------------------------------------------------------------------
    // 'kids' is an array of indirect references pointing to dictionaries.
    // Only /Limits and /Names can occur in those dictionaries
    // We take the first encounter of /Names.
    //-------------------------------------------------------------------------
    if (!pdf_is_array(ctx, kids) || !(n = pdf_array_len(ctx, kids)))
        return NULL;         // should never occur

    for (i = 0; i < n; i++)
    {
        o = pdf_resolve_indirect(ctx, pdf_array_get(ctx, kids, i));
        names = pdf_dict_get(ctx, o, PDF_NAME(Names));
        if (names) return names;
    }
    return NULL;             // should never execute
}

//-----------------------------------------------------------------------------
// perform some cleaning if we have /EmbeddedFiles:
// (1) remove any /Limits if /Names exists
// (2) remove any empty /Collection
// (3) set /PageMode/UseAttachments
//-----------------------------------------------------------------------------
void JM_embedded_clean(fz_context *ctx, pdf_document *pdf)
{
    pdf_obj *root = pdf_dict_get(ctx, pdf_trailer(ctx, pdf), PDF_NAME(Root));

    // remove any empty /Collection entry
    pdf_obj *coll = pdf_dict_get(ctx, root, PDF_NAME(Collection));
    if (coll && pdf_dict_len(ctx, coll) == 0)
        pdf_dict_del(ctx, root, PDF_NAME(Collection));
    
    if (!pdf_count_portfolio_entries(ctx, pdf))
        return;

    pdf_obj *efiles = pdf_dict_getl(ctx, root, PDF_NAME(Names),
                                    PDF_NAME(EmbeddedFiles), NULL);
    if (efiles)         // we have embedded files
    {   // make sure they are displayed
        pdf_dict_put_name(ctx, root, PDF_NAME(PageMode), "UseAttachments");
        // remove the limits entry: seems to be a MuPDF bug
        pdf_dict_del(ctx, efiles, PDF_NAME(Limits));
    }

    return;
}

//-----------------------------------------------------------------------------
// insert new embedded file in PDF
// not necessarily an /EmbeddedFiles entry
//-----------------------------------------------------------------------------
pdf_obj *JM_embed_file(fz_context *ctx, pdf_document *pdf, fz_buffer *buf,
                       char *filename, char *ufilename, char *desc)
{
    size_t len = 0;
    pdf_obj *ef, *f, *params;
    pdf_obj *val = NULL;
    fz_buffer *tbuf;
    fz_var(val);
    fz_try(ctx)
    {
        val = pdf_new_dict(ctx, pdf, 6);
        pdf_dict_put_dict(ctx, val, PDF_NAME(CI), 4);
        ef = pdf_dict_put_dict(ctx, val, PDF_NAME(EF), 4);
        pdf_dict_put_text_string(ctx, val, PDF_NAME(F), filename);
        pdf_dict_put_text_string(ctx, val, PDF_NAME(UF), filename);
        pdf_dict_put_text_string(ctx, val, PDF_NAME(Desc), desc);
        pdf_dict_put(ctx, val, PDF_NAME(Type), PDF_NAME(Filespec));
        tbuf = fz_new_buffer(ctx, strlen(filename)+1);
        fz_append_string(ctx, tbuf, filename);
        fz_terminate_buffer(ctx, tbuf);
        pdf_dict_put_drop(ctx, ef, PDF_NAME(F),
                         (f = pdf_add_stream(ctx, pdf, tbuf, NULL, 0)));
        fz_drop_buffer(ctx, tbuf);
        JM_update_stream(ctx, pdf, f, buf);
        len = fz_buffer_storage(ctx, buf, NULL);
        pdf_dict_put_int(ctx, f, PDF_NAME(DL), len);
        pdf_dict_put_int(ctx, f, PDF_NAME(Length), len);
        params = pdf_dict_put_dict(ctx, f, PDF_NAME(Params), 4);
        pdf_dict_put_int(ctx, params, PDF_NAME(Size), len);
    }
    fz_always(ctx)
    {
        ;
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return val;
}


//----------------------------------------------------------------------------
// Helpers for document page selection - main logic was imported
// from pdf_clean_file.c. But instead of analyzing a string-based spec of
// selected pages, we accept a Python sequence.
//----------------------------------------------------------------------------
typedef struct globals_s
{
    pdf_document *doc;
    fz_context *ctx;
} globals;

int string_in_names_list(fz_context *ctx, pdf_obj *p, pdf_obj *names_list)
{
    int n = pdf_array_len(ctx, names_list);
    int i;
    char *str = pdf_to_str_buf(ctx, p);

    for (i = 0; i < n ; i += 2)
    {
        if (!strcmp(pdf_to_str_buf(ctx, pdf_array_get(ctx, names_list, i)), str))
            return 1;
    }
    return 0;
}

//----------------------------------------------------------------------------
// Recreate page tree to only retain specified pages.
//----------------------------------------------------------------------------
void retainpage(fz_context *ctx, pdf_document *doc, pdf_obj *parent, pdf_obj *kids, int page)
{
    pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, page);

    pdf_flatten_inheritable_page_items(ctx, pageref);

    pdf_dict_put(ctx, pageref, PDF_NAME(Parent), parent);

    /* Store page object in new kids array */
    pdf_array_push(ctx, kids, pageref);
}

int dest_is_valid_page(fz_context *ctx, pdf_obj *obj, int *page_object_nums, int pagecount)
{
    int i;
    int num = pdf_to_num(ctx, obj);

    if (num == 0)
        return 0;
    for (i = 0; i < pagecount; i++)
    {
        if (page_object_nums[i] == num)
            return 1;
    }
    return 0;
}

int dest_is_valid(fz_context *ctx, pdf_obj *o, int page_count, int *page_object_nums, pdf_obj *names_list)
{
    pdf_obj *p;

    p = pdf_dict_get(ctx, o, PDF_NAME(A));
    if (pdf_name_eq(ctx, pdf_dict_get(ctx, p, PDF_NAME(S)), PDF_NAME(GoTo)) &&
        !string_in_names_list(ctx, pdf_dict_get(ctx, p, PDF_NAME(D)), names_list))
        return 0;

    p = pdf_dict_get(ctx, o, PDF_NAME(Dest));
    if (p == NULL)
    {}
    else if (pdf_is_string(ctx, p))
    {
        return string_in_names_list(ctx, p, names_list);
    }
    else if (!dest_is_valid_page(ctx, pdf_array_get(ctx, p, 0), page_object_nums, page_count))
        return 0;

    return 1;
}

int strip_outlines(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int *page_object_nums, pdf_obj *names_list);

int strip_outline(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int *page_object_nums, pdf_obj *names_list, pdf_obj **pfirst, pdf_obj **plast)
{
    pdf_obj *prev = NULL;
    pdf_obj *first = NULL;
    pdf_obj *current;
    int count = 0;

    for (current = outlines; current != NULL; )
    {
        int nc;

        /*********************************************************************/
        // Strip any children to start with. This takes care of
        // First / Last / Count for us.
        /*********************************************************************/
        nc = strip_outlines(ctx, doc, current, page_count, page_object_nums, names_list);

        if (!dest_is_valid(ctx, current, page_count, page_object_nums, names_list))
        {
            if (nc == 0)
            {
                /*************************************************************/
                // Outline with invalid dest and no children. Drop it by
                // pulling the next one in here.
                /*************************************************************/
                pdf_obj *next = pdf_dict_get(ctx, current, PDF_NAME(Next));
                if (next == NULL)
                {
                    // There is no next one to pull in
                    if (prev != NULL)
                        pdf_dict_del(ctx, prev, PDF_NAME(Next));
                }
                else if (prev != NULL)
                {
                    pdf_dict_put(ctx, prev, PDF_NAME(Next), next);
                    pdf_dict_put(ctx, next, PDF_NAME(Prev), prev);
                }
                else
                {
                    pdf_dict_del(ctx, next, PDF_NAME(Prev));
                }
                current = next;
            }
            else
            {
                // Outline with invalid dest, but children. Just drop the dest.
                pdf_dict_del(ctx, current, PDF_NAME(Dest));
                pdf_dict_del(ctx, current, PDF_NAME(A));
                current = pdf_dict_get(ctx, current, PDF_NAME(Next));
            }
        }
        else
        {
            // Keep this one
            if (first == NULL)
                first = current;
            prev = current;
            current = pdf_dict_get(ctx, current, PDF_NAME(Next));
            count++;
        }
    }

    *pfirst = first;
    *plast = prev;

    return count;
}

int strip_outlines(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int *page_object_nums, pdf_obj *names_list)
{
    int nc;
    pdf_obj *first;
    pdf_obj *last;

    if (outlines == NULL)
        return 0;

    first = pdf_dict_get(ctx, outlines, PDF_NAME(First));
    if (first == NULL)
        nc = 0;
    else
        nc = strip_outline(ctx, doc, first, page_count, page_object_nums,
                           names_list, &first, &last);

    if (nc == 0)
    {
        pdf_dict_del(ctx, outlines, PDF_NAME(First));
        pdf_dict_del(ctx, outlines, PDF_NAME(Last));
        pdf_dict_del(ctx, outlines, PDF_NAME(Count));
    }
    else
    {
        int old_count = pdf_to_int(ctx, pdf_dict_get(ctx, outlines, PDF_NAME(Count)));
        pdf_dict_put(ctx, outlines, PDF_NAME(First), first);
        pdf_dict_put(ctx, outlines, PDF_NAME(Last), last);
        pdf_dict_put_drop(ctx, outlines, PDF_NAME(Count), pdf_new_int(ctx, old_count > 0 ? nc : -nc));
    }
    return nc;
}

//----------------------------------------------------------------------------
//   This is called by PyMuPDF:
//   liste = page numbers to retain
//----------------------------------------------------------------------------
void retainpages(fz_context *ctx, globals *glo, PyObject *liste)
{
    pdf_obj *oldroot, *root, *pages, *kids, *countobj, *olddests;
    Py_ssize_t argc = PySequence_Size(liste);
    pdf_document *doc = glo->doc;
    pdf_obj *names_list = NULL;
    pdf_obj *outlines;
    pdf_obj *ocproperties;
    int pagecount = pdf_count_pages(ctx, doc);

    int i;
    int *page_object_nums;

/******************************************************************************/
//    Keep only pages/type and (reduced) dest entries to avoid
//    references to dropped pages
/******************************************************************************/
    oldroot = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(Root));
    pages = pdf_dict_get(ctx, oldroot, PDF_NAME(Pages));
    olddests = pdf_load_name_tree(ctx, doc, PDF_NAME(Dests));
    outlines = pdf_dict_get(ctx, oldroot, PDF_NAME(Outlines));
    ocproperties = pdf_dict_get(ctx, oldroot, PDF_NAME(OCProperties));

    root = pdf_new_dict(ctx, doc, 3);
    pdf_dict_put(ctx, root, PDF_NAME(Type), pdf_dict_get(ctx, oldroot, PDF_NAME(Type)));
    pdf_dict_put(ctx, root, PDF_NAME(Pages), pdf_dict_get(ctx, oldroot, PDF_NAME(Pages)));
    if (outlines)
        pdf_dict_put(ctx, root, PDF_NAME(Outlines), outlines);
    if (ocproperties)
        pdf_dict_put(ctx, root, PDF_NAME(OCProperties), ocproperties);

    pdf_update_object(ctx, doc, pdf_to_num(ctx, oldroot), root);

    // Create a new kids array with only the pages we want to keep
    kids = pdf_new_array(ctx, doc, 1);

    // Retain pages specified
    Py_ssize_t page;
    fz_try(ctx)
    {
        for (page = 0; page < argc; page++)
            {
                i = (int) PyInt_AsLong(PySequence_ITEM(liste, page));
                if (i < 0 || i >= pagecount)
                    THROWMSG("invalid page number(s)");
                retainpage(ctx, doc, pages, kids, i);
            }
    }
    fz_catch(ctx) fz_rethrow(ctx);

    // Update page count and kids array
    countobj = pdf_new_int(ctx, pdf_array_len(ctx, kids));
    pdf_dict_put_drop(ctx, pages, PDF_NAME(Count), countobj);
    pdf_dict_put_drop(ctx, pages, PDF_NAME(Kids), kids);

    pagecount = pdf_count_pages(ctx, doc);
    page_object_nums = fz_calloc(ctx, pagecount, sizeof(*page_object_nums));
    for (i = 0; i < pagecount; i++)
    {
        pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, i);
        page_object_nums[i] = pdf_to_num(ctx, pageref);
    }

/******************************************************************************/
// If we had an old Dests tree (now reformed as an olddests dictionary),
// keep any entries in there that point to valid pages.
// This may mean we keep more than we need, but it is safe at least.
/******************************************************************************/
    if (olddests)
    {
        pdf_obj *names = pdf_new_dict(ctx, doc, 1);
        pdf_obj *dests = pdf_new_dict(ctx, doc, 1);
        int len = pdf_dict_len(ctx, olddests);

        names_list = pdf_new_array(ctx, doc, 32);

        for (i = 0; i < len; i++)
        {
            pdf_obj *key = pdf_dict_get_key(ctx, olddests, i);
            pdf_obj *val = pdf_dict_get_val(ctx, olddests, i);
            pdf_obj *dest = pdf_dict_get(ctx, val, PDF_NAME(D));

            dest = pdf_array_get(ctx, dest ? dest : val, 0);
            if (dest_is_valid_page(ctx, dest, page_object_nums, pagecount))
            {
                pdf_obj *key_str = pdf_new_string(ctx, pdf_to_name(ctx, key), strlen(pdf_to_name(ctx, key)));
                pdf_array_push_drop(ctx, names_list, key_str);
                pdf_array_push(ctx, names_list, val);
            }
        }

        pdf_dict_put(ctx, dests, PDF_NAME(Names), names_list);
        pdf_dict_put(ctx, names, PDF_NAME(Dests), dests);
        pdf_dict_put(ctx, root, PDF_NAME(Names), names);

        pdf_drop_obj(ctx, names);
        pdf_drop_obj(ctx, dests);
        pdf_drop_obj(ctx, olddests);
    }

/*****************************************************************************/
// Edit each pages /Annot list to remove any links pointing to nowhere.
/*****************************************************************************/
    for (i = 0; i < pagecount; i++)
    {
        pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, i);

        pdf_obj *annots = pdf_dict_get(ctx, pageref, PDF_NAME(Annots));

        int len = pdf_array_len(ctx, annots);
        int j;

        for (j = 0; j < len; j++)
        {
            pdf_obj *o = pdf_array_get(ctx, annots, j);

            if (!pdf_name_eq(ctx, pdf_dict_get(ctx, o, PDF_NAME(Subtype)), PDF_NAME(Link)))
                continue;

            if (!dest_is_valid(ctx, o, pagecount, page_object_nums, names_list))
            {
                // Remove this annotation
                pdf_array_delete(ctx, annots, j);
                len--;
                j--;
            }
        }
    }

    if (strip_outlines(ctx, doc, outlines, pagecount, page_object_nums, names_list) == 0)
    {
        pdf_dict_del(ctx, root, PDF_NAME(Outlines));
    }

    fz_free(ctx, page_object_nums);
    pdf_drop_obj(ctx, names_list);
    pdf_drop_obj(ctx, root);
}


//-----------------------------------------------------------------------------
// Make an XObject from a PDF page
// For a positive xref assume that that object can be used instead
//-----------------------------------------------------------------------------
pdf_obj *JM_xobject_from_page(fz_context *ctx, pdf_document *pdfout, pdf_document *pdfsrc, int pno, fz_rect *mediabox, fz_rect *cropbox, int xref, pdf_graft_map *gmap)
{
    fz_buffer *nres = NULL, *res = NULL;
    pdf_obj *xobj1, *contents = NULL, *resources = NULL, *o, *spageref;
    int i;
    fz_try(ctx)
    {
        if (pno < 0 || pno >= pdf_count_pages(ctx, pdfsrc))
            THROWMSG("invalid page number(s)");
        spageref = pdf_lookup_page_obj(ctx, pdfsrc, pno);
        pdf_obj *mb = pdf_dict_get_inheritable(ctx, spageref, PDF_NAME(MediaBox));
        if (mb)
            *mediabox = pdf_to_rect(ctx, mb);
        else 
            *mediabox = pdf_bound_page(ctx, pdf_load_page(ctx, pdfsrc, pno));
        o = pdf_dict_get_inheritable(ctx, spageref, PDF_NAME(CropBox));
        if (!o)
        {
            cropbox->x0 = mediabox->x0;
            cropbox->y0 = mediabox->y0;
            cropbox->x1 = mediabox->x1;
            cropbox->y1 = mediabox->y1;
        }
        else
            *cropbox = pdf_to_rect(ctx, o);

        if (xref > 0)        // we can reuse an XObject!
        {
            if (xref >= pdf_xref_len(ctx, pdfout))
                THROWMSG("xref out of range");
            xobj1 = pdf_new_indirect(ctx, pdfout, xref, 0);
        }
        else                 // need to create new XObject
        {
            // Deep-copy resources object of source page
            o = pdf_dict_get(ctx, spageref, PDF_NAME(Resources));
            if (gmap)        // use graftmap when possible
                resources = pdf_graft_mapped_object(ctx, gmap, o);
            else
                resources = pdf_graft_object(ctx, pdfout, o);
            
            // get spgage contents source; combine when several objects
            contents = pdf_dict_get(ctx, spageref, PDF_NAME(Contents));
            if (pdf_is_array(ctx, contents))     // more than one!
            {
                res = fz_new_buffer(ctx, 1024);
                for (i=0; i < pdf_array_len(ctx, contents); i++)
                {
                    nres = pdf_load_stream(ctx, pdf_array_get(ctx, contents, i));
                    fz_append_buffer(ctx, res, nres);
                    fz_drop_buffer(ctx, nres);
                }
            }
            else
            {
                res = pdf_load_stream(ctx, contents);
            }

            //-------------------------------------------------------------
            // create XObject representing the source page
            //-------------------------------------------------------------
            xobj1 = pdf_new_xobject(ctx, pdfout, *mediabox, fz_identity, NULL, res);
            // store spage contents
            JM_update_stream(ctx, pdfout, xobj1, res);
            fz_drop_buffer(ctx, res);

            // store spage resources
            pdf_dict_put_drop(ctx, xobj1, PDF_NAME(Resources), resources);
        }
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return xobj1;
}

//-----------------------------------------------------------------------------
// Insert a buffer as a new separate /Contents object of a page.
// 1. Create a new stream object from buffer 'newcont'
// 2. If /Contents already is an array, then just prepend or append this object
// 3. Create new array and put old content obj and new obj into it
//-----------------------------------------------------------------------------
int JM_insert_contents(fz_context *ctx, pdf_document *pdf,
                        pdf_obj *pageref, fz_buffer *newcont, int overlay)
{
    int xref = 0;
    fz_try(ctx)
    {
        pdf_obj *contents = pdf_dict_get(ctx, pageref, PDF_NAME(Contents));
        pdf_obj *newconts = pdf_add_stream(ctx, pdf, newcont, NULL, 0);
        xref = pdf_to_num(ctx, newconts);
        if (pdf_is_array(ctx, contents))
        {
            if (overlay)               // append new object
                pdf_array_push_drop(ctx, contents, newconts);
            else                       // prepend new object
                pdf_array_insert_drop(ctx, contents, newconts, 0);
        }
        else                           // make new array
        {
            pdf_obj *carr = pdf_new_array(ctx, pdf, 5);
            if (overlay)
            {
                if (contents) pdf_array_push(ctx, carr, contents);
                pdf_array_push_drop(ctx, carr, newconts);
            }
            else 
            {
                pdf_array_push_drop(ctx, carr, newconts);
                if (contents) pdf_array_push(ctx, carr, contents);
            }
            pdf_dict_put_drop(ctx, pageref, PDF_NAME(Contents), carr);
        }
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return xref;
}
/*-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Append / prepend a buffer to the /Contents of a page.
//-----------------------------------------------------------------------------
void JM_extend_contents(fz_context *ctx, pdf_document *pdfout,
                        pdf_obj *pageref, fz_buffer *newcont, int overlay)
{
    int i;
    fz_buffer *oldcont = NULL, *endcont = NULL;
    pdf_obj *contents = pdf_dict_get(ctx, pageref, PDF_NAME(Contents));
    fz_try(ctx)
    {
        if (pdf_is_array(ctx, contents))     // multiple contents objects!
        {   // choose the correct one (first / last)
            if (overlay == 1) i = pdf_array_len(ctx, contents) - 1;
            else  i = 0;
            contents = pdf_array_get(ctx, contents, i);
        }
        oldcont = pdf_load_stream(ctx, contents);     // old contents buffer

        // allocate result buffer
        endcont = fz_new_buffer(ctx, fz_buffer_storage(ctx, oldcont, NULL) +
                                     fz_buffer_storage(ctx, newcont, NULL));

        if (overlay == 1)                             // append new buffer
        {
            fz_append_buffer(ctx, endcont, oldcont);
            fz_append_buffer(ctx, endcont, newcont);
        }
        else                                          // prepend new buffer
        {
            fz_append_buffer(ctx, endcont, newcont);
            fz_append_buffer(ctx, endcont, oldcont);
        }
        fz_terminate_buffer(ctx, endcont);            // finalize result buffer
    
        // now update the content stream
        JM_update_stream(ctx, pdfout, contents, endcont);
    }
    fz_always(ctx)
    {
        fz_drop_buffer(ctx, endcont);
        fz_drop_buffer(ctx, oldcont);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return;
}
-----------------------------------------------------------------------------*/



//----------------------------------------------------------------------------
// convert (char *) to ASCII-only (char*) (which must be freed!)
//----------------------------------------------------------------------------
char *JM_ASCIIFromChar(char *in)
{
    if (!in) return NULL;
    size_t i, j = strlen(in) + 1;
    unsigned char *out = JM_Alloc(unsigned char, j);
    if (!out) return NULL;
    memcpy(out, in, j);
    for (i = 0; i < j-1; i++)
    {
        if (out[i] > 126)
        {
            out[i] = 63;
            continue;
        }
        if (out[i] < 32)
            out[i] = 32;
    }
    return (char *) out;
}

//----------------------------------------------------------------------------
// create an ASCII-only Python string of a (char*)
//----------------------------------------------------------------------------
PyObject *JM_UnicodeFromASCII(const char *in)
{
    char *c = JM_ASCIIFromChar((char *) in);
    PyObject *p = Py_BuildValue("s", c);
    JM_Free(c);
    return p;
}

//-----------------------------------------------------------------------------
// Store info of a font in Python list
//-----------------------------------------------------------------------------
void JM_gather_fonts(fz_context *ctx, pdf_document *pdf, pdf_obj *dict,
                    PyObject *fontlist)
{
    int i, n;
    n = pdf_dict_len(ctx, dict);
    for (i = 0; i < n; i++)
    {
        pdf_obj *fontdict = NULL;
        pdf_obj *subtype = NULL;
        pdf_obj *basefont = NULL;
        pdf_obj *name = NULL;
        pdf_obj *refname = NULL;
        pdf_obj *encoding = NULL;

        fontdict = pdf_dict_get_val(ctx, dict, i);
        if (!pdf_is_dict(ctx, fontdict))
        {
            PySys_WriteStdout("warning: not a font dict (%d 0 R)",
                              pdf_to_num(ctx, fontdict));
            continue;
        }
        refname = pdf_dict_get_key(ctx, dict, i);
        subtype = pdf_dict_get(ctx, fontdict, PDF_NAME(Subtype));
        basefont = pdf_dict_get(ctx, fontdict, PDF_NAME(BaseFont));
        if (!basefont || pdf_is_null(ctx, basefont))
            name = pdf_dict_get(ctx, fontdict, PDF_NAME(Name));
        else
            name = basefont;
        encoding = pdf_dict_get(ctx, fontdict, PDF_NAME(Encoding));
        if (pdf_is_dict(ctx, encoding))
            encoding = pdf_dict_get(ctx, encoding, PDF_NAME(BaseEncoding));
        int xref = pdf_to_num(ctx, fontdict);
        char *ext = "n/a";
        if (xref) ext = fontextension(ctx, pdf, xref);
        PyObject *entry = PyList_New(0);
        PyList_Append(entry, Py_BuildValue("i", xref));
        PyList_Append(entry, Py_BuildValue("s", ext));
        PyList_Append(entry, JM_UnicodeFromASCII(pdf_to_name(ctx, subtype)));
        PyList_Append(entry, JM_UnicodeFromASCII(pdf_to_name(ctx, name)));
        PyList_Append(entry, JM_UnicodeFromASCII(pdf_to_name(ctx, refname)));
        PyList_Append(entry, JM_UnicodeFromASCII(pdf_to_name(ctx, encoding)));
        PyList_Append(fontlist, entry);
        Py_CLEAR(entry);
    }
}

//-----------------------------------------------------------------------------
// Store info of an image in Python list
//-----------------------------------------------------------------------------
void JM_gather_images(fz_context *ctx, pdf_document *doc, pdf_obj *dict,
                     PyObject *imagelist)
{
    int i, n;
    n = pdf_dict_len(ctx, dict);
    for (i = 0; i < n; i++)
    {
        pdf_obj *imagedict, *smask;
        pdf_obj *refname = NULL;
        pdf_obj *type;
        pdf_obj *width;
        pdf_obj *height;
        pdf_obj *bpc = NULL;
        pdf_obj *filter = NULL;
        pdf_obj *cs = NULL;
        pdf_obj *altcs;

        imagedict = pdf_dict_get_val(ctx, dict, i);
        if (!pdf_is_dict(ctx, imagedict))
        {
            PySys_WriteStdout("warning: not an image dict (%d 0 R)",
                              pdf_to_num(ctx, imagedict));
            continue;
        }
        refname = pdf_dict_get_key(ctx, dict, i);

        type = pdf_dict_get(ctx, imagedict, PDF_NAME(Subtype));
        if (!pdf_name_eq(ctx, type, PDF_NAME(Image)))
            continue;
        
        int xref = pdf_to_num(ctx, imagedict);
        int gen = 0;
        smask = pdf_dict_get(ctx, imagedict, PDF_NAME(SMask));
        if (smask)
            gen = pdf_to_num(ctx, smask);
        filter = pdf_dict_get(ctx, imagedict, PDF_NAME(Filter));

        altcs = NULL;
        cs = pdf_dict_get(ctx, imagedict, PDF_NAME(ColorSpace));
        if (pdf_is_array(ctx, cs))
        {
            pdf_obj *cses = cs;
            cs = pdf_array_get(ctx, cses, 0);
            if (pdf_name_eq(ctx, cs, PDF_NAME(DeviceN)) ||
                pdf_name_eq(ctx, cs, PDF_NAME(Separation)))
            {
                altcs = pdf_array_get(ctx, cses, 2);
                if (pdf_is_array(ctx, altcs))
                    altcs = pdf_array_get(ctx, altcs, 0);
            }
        }

        width = pdf_dict_get(ctx, imagedict, PDF_NAME(Width));
        height = pdf_dict_get(ctx, imagedict, PDF_NAME(Height));
        bpc = pdf_dict_get(ctx, imagedict, PDF_NAME(BitsPerComponent));

        PyObject *entry = PyList_New(0);
        PyList_Append(entry, Py_BuildValue("i", xref));
        PyList_Append(entry, Py_BuildValue("i", gen));
        PyList_Append(entry, Py_BuildValue("i", pdf_to_int(ctx, width)));
        PyList_Append(entry, Py_BuildValue("i", pdf_to_int(ctx, height)));
        PyList_Append(entry, Py_BuildValue("i", pdf_to_int(ctx, bpc)));
        PyList_Append(entry, JM_UnicodeFromASCII(pdf_to_name(ctx, cs)));
        PyList_Append(entry, JM_UnicodeFromASCII(pdf_to_name(ctx, altcs)));
        PyList_Append(entry, JM_UnicodeFromASCII(pdf_to_name(ctx, refname)));
        PyList_Append(entry, JM_UnicodeFromASCII(pdf_to_name(ctx, filter)));
        PyList_Append(imagelist, entry);
        Py_CLEAR(entry);
    }
}

//-----------------------------------------------------------------------------
// Store info of a /Form in Python list
//-----------------------------------------------------------------------------
void JM_gather_forms(fz_context *ctx, pdf_document *doc, pdf_obj *dict,
                     PyObject *imagelist)
{
    int i, n;
    n = pdf_dict_len(ctx, dict);
    for (i = 0; i < n; i++)
    {
        pdf_obj *imagedict;
        pdf_obj *refname = NULL;
        pdf_obj *type;

        imagedict = pdf_dict_get_val(ctx, dict, i);
        if (!pdf_is_dict(ctx, imagedict))
        {
            PySys_WriteStdout("warning: not a form dict (%d 0 R)",
                              pdf_to_num(ctx, imagedict));
            continue;
        }
        refname = pdf_dict_get_key(ctx, dict, i);

        type = pdf_dict_get(ctx, imagedict, PDF_NAME(Subtype));
        if (!pdf_name_eq(ctx, type, PDF_NAME(Form)))
            continue;

        int xref = pdf_to_num(ctx, imagedict);

        PyObject *entry = PyList_New(0);
        PyList_Append(entry, Py_BuildValue("i", xref));
        PyList_Append(entry, JM_UnicodeFromASCII(pdf_to_name(ctx, refname)));
        PyList_Append(imagelist, entry);
        Py_CLEAR(entry);
    }
}

//-----------------------------------------------------------------------------
// Step through /Resources, looking up image or font information
//-----------------------------------------------------------------------------
void JM_scan_resources(fz_context *ctx, pdf_document *pdf, pdf_obj *rsrc,
                 PyObject *liste, int what)
{
    pdf_obj *font, *xobj, *subrsrc;
    int i, n;
    if (pdf_mark_obj(ctx, rsrc)) return;    // stop on cylic dependencies
    fz_try(ctx)
    {
        if (what == 1)            // look up fonts
        {
            font = pdf_dict_get(ctx, rsrc, PDF_NAME(Font));
            JM_gather_fonts(ctx, pdf, font, liste);
            n = pdf_dict_len(ctx, font);
            for (i = 0; i < n; i++)
            {
                pdf_obj *obj = pdf_dict_get_val(ctx, font, i);
                subrsrc = pdf_dict_get(ctx, obj, PDF_NAME(Resources));
                if (subrsrc)
                    JM_scan_resources(ctx, pdf, subrsrc, liste, what);
            }
        }

        xobj = pdf_dict_get(ctx, rsrc, PDF_NAME(XObject));

        if (what == 2)            // look up images
        {
            JM_gather_images(ctx, pdf, xobj, liste);
        }

        if (what == 3)            // look up forms
        {
            JM_gather_forms(ctx, pdf, xobj, liste);
        }

        n = pdf_dict_len(ctx, xobj);
        for (i = 0; i < n; i++)
        {
            pdf_obj *obj = pdf_dict_get_val(ctx, xobj, i);
            subrsrc = pdf_dict_get(ctx, obj, PDF_NAME(Resources));
            if (subrsrc)
                JM_scan_resources(ctx, pdf, subrsrc, liste, what);
        }
    }
    fz_always(ctx) pdf_unmark_obj(ctx, rsrc);
    fz_catch(ctx)  fz_rethrow(ctx);
}



//-----------------------------------------------------------------------------
// Convert any MuPDF document to a PDF
// Returns bytes object containing the PDF, created via 'write' function.
//-----------------------------------------------------------------------------
PyObject *JM_convert_to_pdf(fz_context *ctx, fz_document *doc, int fp, int tp, int rotate)
{
    pdf_document *pdfout = pdf_create_document(ctx);  // new PDF document
    int i, incr = 1, s = fp, e = tp;
    if (fp > tp)             // revert page sequence
    {
        incr = -1;           // count backwards
        s = tp;              // adjust ...
        e = fp;              // ... range
    }
    fz_rect mediabox;
    fz_device *dev = NULL;
    fz_buffer *contents = NULL;
    pdf_obj *resources = NULL;
    fz_page *page;
    fz_var(dev);
    fz_var(contents);
    fz_var(resources);
    fz_var(page);
    for (i = fp; INRANGE(i, s, e); i += incr)
    {   // interpret & write document pages as PDF pages
        fz_try(ctx)
        {
            page = fz_load_page(ctx, doc, i);
            mediabox = fz_bound_page(ctx, page);
            dev = pdf_page_write(ctx, pdfout, mediabox, &resources, &contents);
            fz_run_page(ctx, page, dev, fz_identity, NULL);
            fz_close_device(ctx, dev);
            fz_drop_device(ctx, dev);
            dev = NULL;
            pdf_obj *page_obj = pdf_add_page(ctx, pdfout, mediabox, rotate, resources, contents);
            pdf_insert_page(ctx, pdfout, -1, page_obj);
            pdf_drop_obj(ctx, page_obj);
        }
        fz_always(ctx)
        {
            pdf_drop_obj(ctx, resources);
            fz_drop_buffer(ctx, contents);
            fz_drop_device(ctx, dev);
        }
        fz_catch(ctx)
        {
            fz_drop_page(ctx, page);
            fz_rethrow(ctx);
        }
    }
    // PDF created - now write it to Python bytearray
    PyObject *r = NULL;
    fz_output *out = NULL;
    // prepare write options structure
    int errors = 0;
    pdf_write_options opts = { 0 };
    opts.do_garbage         = 4;
    opts.do_compress        = 1;
    opts.do_compress_images = 1;
    opts.do_compress_fonts  = 1;
    opts.do_sanitize        = 1;
    opts.do_incremental     = 0;
    opts.do_ascii           = 0;
    opts.do_decompress      = 0;
    opts.do_linear          = 0;
    opts.do_clean           = 1;
    opts.do_pretty          = 0;
    opts.continue_on_error  = 1;
    opts.errors = &errors;
    fz_try(ctx)
    {
        r = PyByteArray_FromStringAndSize("", 0);
        out = JM_OutFromBarray(gctx, r);
        pdf_write_document(ctx, pdfout, out, &opts);
    }
    fz_always(ctx) fz_drop_output(ctx, out);
    fz_catch(ctx)
    {
        Py_CLEAR(r);
        fz_rethrow(ctx);
    }
    return r;
}

SWIGINTERN void delete_fz_document_s(struct fz_document_s *self){
            DEBUGMSG1("document w/o close");
            fz_drop_document(gctx, self);
            DEBUGMSG2;
        }

SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
  if (PyBytes_Check(obj))
#else
  if (PyUnicode_Check(obj))
#endif
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
#if PY_VERSION_HEX>=0x03000000
#if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    if(alloc) *alloc = SWIG_NEWOBJ;
#endif
    PyBytes_AsStringAndSize(obj, &cstr, &len);
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) {
      if (alloc) {
	/* 
	   In python the user should not be able to modify the inner
	   string representation. To warranty that, if you define
	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
	   buffer is always returned.

	   The default behavior is just to return the pointer value,
	   so, be careful.
	*/ 
#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
	if (*alloc != SWIG_OLDOBJ) 
#else
	if (*alloc == SWIG_NEWOBJ) 
#endif
	{
	  *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
	*cptr = PyBytes_AsString(obj);
#else
	assert(0); /* Should never reach here with Unicode strings in Python 3 */
#endif
#else
	*cptr = SWIG_Python_str_AsChar(obj);
#endif
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    Py_XDECREF(obj);
#endif
    return SWIG_OK;
  } else {
#if defined(SWIG_PYTHON_2_UNICODE)
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
#error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
#endif
#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
#endif
#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}





#include <float.h>


#include <math.h>


/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
/* isfinite() is a macro for C99 */
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined __cplusplus && __cplusplus >= 201103L
/* Use a template so that this works whether isfinite() is std::isfinite() or
 * in the global namespace.  The reality seems to vary between compiler
 * versions.
 *
 * Make sure namespace std exists to avoid compiler warnings.
 *
 * extern "C++" is required as this fragment can end up inside an extern "C" { } block
 */
namespace std { }
extern "C++" template<typename T>
inline int SWIG_isfinite_func(T x) {
  using namespace std;
  return isfinite(x);
}
#  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif


/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


SWIGINTERN int
SWIG_AsVal_float (PyObject * obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if (SWIG_Float_Overflow_Check(v)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (float)(v);
    }
  }  
  return res;
}

SWIGINTERN struct fz_document_s *new_fz_document_s(char const *filename,PyObject *stream,char const *filetype,PyObject *rect,float width,float height,float fontsize){
            gctx->error->errcode = 0;       // reset any error code
            gctx->error->message[0] = 0;    // reset any error message
            struct fz_document_s *doc = NULL;
            fz_stream *data = NULL;
            char *streamdata;
            float w = width, h = height;
            fz_rect r = JM_rect_from_py(rect);
            if (!(fz_is_empty_rect(r) && !fz_is_infinite_rect(r)))
            {
                w = r.x1 - r.x0;
                h = r.y1 - r.y0;
            }

            size_t streamlen = JM_CharFromBytesOrArray(stream, &streamdata);
            fz_try(gctx)
            {
                if (streamlen > 0)
                {
                    data = fz_open_memory(gctx, streamdata, streamlen);
                    char *magic = (char *)filename;
                    if (!magic) magic = (char *)filetype;
                    doc = fz_open_document_with_stream(gctx, magic, data);
                }
                else
                {
                    if (filename)
                    {
                        if (!filetype || strlen(filetype) == 0) doc = fz_open_document(gctx, filename);
                        else
                        {
                            const fz_document_handler *handler;
                            handler = fz_recognize_document(gctx, filetype);
                            if (handler && handler->open)
                                doc = handler->open(gctx, filename);
                            else THROWMSG("unrecognized file type");
                        }
                    }
                    else
                    {
                        pdf_document *pdf = pdf_create_document(gctx);
                        pdf->dirty = 1;
                        doc = (fz_document *) pdf;
                    }
                }
            }
            fz_catch(gctx) return NULL;
            if (w > 0 && h > 0)
                fz_layout_document(gctx, doc, w, h, fontsize);
            return doc;
        }
SWIGINTERN void fz_document_s_close(struct fz_document_s *self){
            DEBUGMSG1("doc.close()");
            while(self->refs > 1) {
                fz_drop_document(gctx, self);
            }
            fz_drop_document(gctx, self);
            DEBUGMSG2;
        }

#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}

SWIGINTERN struct fz_page_s *fz_document_s_loadPage(struct fz_document_s *self,int number){
            struct fz_page_s *page = NULL;
            fz_try(gctx)
            {
                int pageCount = fz_count_pages(gctx, self);
                if (pageCount < 1) THROWMSG("document has no pages");
                int n = number;
                while (n < 0) n += pageCount;
                page = fz_load_page(gctx, self, n);
            }
            fz_catch(gctx) return NULL;
            return page;
        }
SWIGINTERN struct fz_outline_s *fz_document_s__loadOutline(struct fz_document_s *self){
            fz_outline *ol = NULL;
            fz_try(gctx) ol = fz_load_outline(gctx, self);
            fz_catch(gctx) return NULL;
            return ol;
        }
SWIGINTERN void fz_document_s__dropOutline(struct fz_document_s *self,struct fz_outline_s *ol){
            DEBUGMSG1("outline");
            fz_drop_outline(gctx, ol);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *fz_document_s_embeddedFileCount(struct fz_document_s *self){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            int i = -1;
            if (pdf) i = pdf_count_portfolio_entries(gctx, pdf);
            return Py_BuildValue("i", i);
        }
SWIGINTERN PyObject *fz_document_s_embeddedFileDel(struct fz_document_s *self,char *name){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            pdf_obj *names;
            int i, n, m;
            fz_var(names);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                // check presence of name
                if (JM_find_embedded(gctx, Py_BuildValue("s", name), pdf) < 0)
                    THROWMSG("name not found");

                names = JM_embedded_names(gctx, pdf);
                if (!pdf_is_array(gctx, names))
                    THROWMSG("could not find names array");
                n = pdf_array_len(gctx, names);

                //-------------------------------------------------------------
                // Every file has 2 entries: name and file descriptor.
                // First delete file descriptor, then the name entry.
                // Because it might be referenced elsewhere, we leave deletion
                // of stream object to garbage collection.
                //-------------------------------------------------------------
                for (i = 0; i < n; i += 2)
                {
                    char *test = (char *) pdf_to_text_string(gctx, pdf_array_get(gctx, names, i));
                    if (!strcmp(test, name))
                    {
                        pdf_array_delete(gctx, names, i + 1);
                        pdf_array_delete(gctx, names, i);
                    }
                }
                m = (n - pdf_array_len(gctx, names)) / 2;
            }
            fz_catch(gctx) return NULL;
            return Py_BuildValue("i", m);
        }
SWIGINTERN PyObject *fz_document_s_embeddedFileInfo(struct fz_document_s *self,PyObject *id){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            Py_ssize_t name_len = 0;
            int n = -1;
            char *name = NULL;
            char *sname = NULL;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                n = JM_find_embedded(gctx, id, pdf);
                if (n < 0) THROWMSG("entry not found");
            }
            fz_catch(gctx) return NULL;

            PyObject *infodict = PyDict_New();
            // name of file entry
            name = (char *) pdf_to_text_string(gctx, pdf_portfolio_entry_name(gctx, pdf, n));
            PyDict_SetItemString(infodict, "name", JM_UNICODE(name));

            pdf_obj *o = pdf_portfolio_entry_obj(gctx, pdf, n);

            name = (char *) pdf_to_text_string(gctx, pdf_dict_get(gctx, o, PDF_NAME(F)));
            PyDict_SetItemString(infodict, "filename", JM_UNICODE(name));

            name = (char *) pdf_to_text_string(gctx, pdf_dict_get(gctx, o, PDF_NAME(UF)));
            PyDict_SetItemString(infodict, "ufilename", JM_UNICODE(name));

            name = (char *) pdf_to_text_string(gctx, pdf_dict_get(gctx, o, PDF_NAME(Desc)));
            PyDict_SetItemString(infodict, "desc", JM_UNICODE(name));

            int len = -1, DL = -1;
            pdf_obj *ef = pdf_dict_get(gctx, o, PDF_NAME(EF));
            o = pdf_dict_getl(gctx, ef, PDF_NAME(F),
                                          PDF_NAME(Length), NULL);
            if (o) len = pdf_to_int(gctx, o);

            o = pdf_dict_getl(gctx, ef, PDF_NAME(F), PDF_NAME(DL), NULL);
            if (o) DL = pdf_to_int(gctx, o);
            else
            {
                o = pdf_dict_getl(gctx, ef, PDF_NAME(F), PDF_NAME(Params),
                                   PDF_NAME(Size), NULL);
                if (o) DL = pdf_to_int(gctx, o);
            }

            PyDict_SetItemString(infodict, "size", Py_BuildValue("i", DL));
            PyDict_SetItemString(infodict, "length", Py_BuildValue("i", len));
            return infodict;
        }
SWIGINTERN PyObject *fz_document_s_embeddedFileUpd(struct fz_document_s *self,PyObject *id,PyObject *buffer,char *filename,char *ufilename,char *desc){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx)
            {
                assert_PDF(pdf);

                int n = JM_find_embedded(gctx, id, pdf);
                if (n < 0) THROWMSG("entry not found");

                pdf_obj *entry = pdf_portfolio_entry_obj(gctx, pdf, n);
                pdf_obj *filespec = pdf_dict_getl(gctx, entry, PDF_NAME(EF),
                                                  PDF_NAME(F), NULL);

                char *data = NULL;
                size_t len = JM_CharFromBytesOrArray(buffer, &data);
                if (len > 0)
                {
                    if (!filespec) THROWMSG("/EF object not found");
                    res = fz_new_buffer_from_copied_data(gctx, data, len);
                    JM_update_stream(gctx, pdf, filespec, res);
                    // adjust /DL and /Size parameters
                    pdf_obj *l = pdf_new_int(gctx, (int64_t) len);
                    pdf_dict_put(gctx, filespec, PDF_NAME(DL), l);
                    pdf_dict_putl(gctx, filespec, l, PDF_NAME(Params), PDF_NAME(Size), NULL);
                }
                if (filename)
                    pdf_dict_put_text_string(gctx, entry, PDF_NAME(F), filename);

                if (ufilename)
                    pdf_dict_put_text_string(gctx, entry, PDF_NAME(UF), ufilename);

                if (desc)
                    pdf_dict_put_text_string(gctx, entry, PDF_NAME(Desc), desc);
            }
            fz_always(gctx)
                fz_drop_buffer(gctx, res);
            fz_catch(gctx)
                return NULL;
            pdf->dirty = 1;
            return NONE;
        }
SWIGINTERN PyObject *fz_document_s_embeddedFileGet(struct fz_document_s *self,PyObject *id){
            PyObject *cont = NULL;
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            fz_buffer *buf = NULL;
            fz_var(buf);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int i = JM_find_embedded(gctx, id, pdf);
                if (i < 0) THROWMSG("entry not found");
                buf = pdf_portfolio_entry(gctx, pdf, i);
                cont = JM_BinFromBuffer(gctx, buf);
            }
            fz_always(gctx) fz_drop_buffer(gctx, buf);
            fz_catch(gctx) return NULL;
            return cont;
        }
SWIGINTERN PyObject *fz_document_s_embeddedFileAdd(struct fz_document_s *self,PyObject *buffer,char const *name,char *filename,char *ufilename,char *desc){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            fz_buffer *data = NULL, *buf = NULL;
            char *buffdata;
            fz_var(data);
            fz_var(buf);
            int entry = 0;
            size_t size = 0;
            char *f = filename, *uf = ufilename, *d = desc;
            int name_len = (int) strlen(name);
            // make adjustments for omitted arguments
            if (!f) f = (char *)name;
            if (!uf) uf = f;
            if (!d) d = f;

            fz_try(gctx)
            {
                assert_PDF(pdf);
                size = JM_CharFromBytesOrArray(buffer, &buffdata);
                if (size < 1) THROWMSG("buffer not bytes / bytearray");

                // we do not allow duplicate names
                entry = JM_find_embedded(gctx, Py_BuildValue("s", name), pdf);
                if (entry >= 0) THROWMSG("name already exists");

                // first insert a dummy entry with no more than the name
                buf = fz_new_buffer(gctx, name_len + 1);   // has no real meaning
                fz_append_string(gctx, buf, name);         // fill something in
                fz_terminate_buffer(gctx, buf);            // to make it usable
                pdf_add_portfolio_entry(gctx, pdf,         // insert the entry.
                        name, name_len,                    // Except the name,
                        name, name_len,                    // everything will
                        name, name_len,                    // be overwritten
                        name, name_len,
                        buf);
                fz_drop_buffer(gctx, buf);                 // kick stupid buffer
                buf = NULL;
                //-------------------------------------------------------------
                // now modify the entry just created:
                // (1) allow unicode values for filenames and description
                // (2) deflate the file content
                //-------------------------------------------------------------
                // locate the entry again
                entry = JM_find_embedded(gctx, Py_BuildValue("s", name), pdf);
                // (1) insert the real metadata
                pdf_obj *o = pdf_portfolio_entry_obj(gctx, pdf, entry);
                pdf_dict_put_text_string(gctx, o, PDF_NAME(F),    f);
                pdf_dict_put_text_string(gctx, o, PDF_NAME(UF),  uf);
                pdf_dict_put_text_string(gctx, o, PDF_NAME(Desc), d);
                // (2) insert the real file contents
                pdf_obj *filespec = pdf_dict_getl(gctx, o, PDF_NAME(EF),
                                                  PDF_NAME(F), NULL);
                data = fz_new_buffer_from_copied_data(gctx, buffdata, size);
                JM_update_stream(gctx, pdf, filespec, data);
                // finally update some size attributes
                pdf_obj *l = pdf_new_int(gctx, (int64_t) size);
                pdf_dict_put(gctx, filespec, PDF_NAME(DL), l);
                pdf_dict_putl(gctx, filespec, l, PDF_NAME(Params), PDF_NAME(Size), NULL);
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, buf);
                fz_drop_buffer(gctx, data);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return NONE;
        }
SWIGINTERN PyObject *fz_document_s_convertToPDF(struct fz_document_s *self,int from_page,int to_page,int rotate){
            PyObject *doc = NULL;
            fz_try(gctx)
            {
                int fp = from_page, tp = to_page, srcCount = fz_count_pages(gctx, self);
                if (pdf_specifics(gctx, self))
                    THROWMSG("use select+write or insertPDF for PDF docs instead");
                if (fp < 0) fp = 0;
                if (fp > srcCount - 1) fp = srcCount - 1;
                if (tp < 0) tp = srcCount - 1;
                if (tp > srcCount - 1) tp = srcCount - 1;
                doc = JM_convert_to_pdf(gctx, self, fp, tp, rotate);
            }
            fz_catch(gctx) return NULL;
            return doc;
        }
SWIGINTERN PyObject *fz_document_s_pageCount(struct fz_document_s *self){
            return Py_BuildValue("i", fz_count_pages(gctx, self));
        }
SWIGINTERN char *fz_document_s__getMetadata(struct fz_document_s *self,char const *key){
            int vsize;
            char *value;
            vsize = fz_lookup_metadata(gctx, self, key, NULL, 0)+1;
            if(vsize > 1)
            {
                value = JM_Alloc(char, vsize);
                fz_lookup_metadata(gctx, self, key, value, vsize);
                return value;
            }
            else
                return NULL;
        }

SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj((char *)(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
      return PyBytes_FromStringAndSize(carray, (Py_ssize_t)(size));
#else
#if PY_VERSION_HEX >= 0x03010000
      return PyUnicode_DecodeUTF8(carray, (Py_ssize_t)(size), "surrogateescape");
#else
      return PyUnicode_FromStringAndSize(carray, (Py_ssize_t)(size));
#endif
#endif
#else
      return PyString_FromStringAndSize(carray, (Py_ssize_t)(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}

SWIGINTERN PyObject *fz_document_s_needsPass(struct fz_document_s *self){
            return Py_BuildValue("i", fz_needs_password(gctx, self));
        }
SWIGINTERN PyObject *fz_document_s_resolveLink(struct fz_document_s *self,char *uri){
            if (!uri) return NONE;
            float xp = 0.0f, yp = 0.0f;
            int pno = -1;
            fz_try(gctx)
                pno = fz_resolve_link(gctx, self, uri, &xp, &yp);
            fz_catch(gctx)
                return NONE;
            if (pno < 0) return NONE;
            return Py_BuildValue("iff", pno, xp, yp);
        }
SWIGINTERN PyObject *fz_document_s_layout(struct fz_document_s *self,PyObject *rect,float width,float height,float fontsize){
            if (!fz_is_document_reflowable(gctx, self)) return NONE;
            fz_try(gctx)
            {
                float w = width, h = height;
                fz_rect r = JM_rect_from_py(rect);
                if (!fz_is_empty_rect(r) && !fz_is_infinite_rect(r))
                {
                    w = r.x1 - r.x0;
                    h = r.y1 - r.y0;
                }
                if (w <= 0.0f || h <= 0.0f)
                        THROWMSG("invalid page size");
                fz_layout_document(gctx, self, w, h, fontsize);
            }
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_document_s_makeBookmark(struct fz_document_s *self,int pno){
            if (!fz_is_document_reflowable(gctx, self)) return NONE;
            int n = pno, cp = fz_count_pages(gctx, self);
            while(n < 0) n += cp;
            long long mark = (long long) fz_make_bookmark(gctx, self, n);
            return PyLong_FromLongLong(mark);
        }

#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_long_SS_long (PyObject *obj, long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    long long v = PyLong_AsLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    long v;
    res = SWIG_AsVal_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    const double mant_min = -mant_max;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, mant_min, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, mant_min, mant_max)) {
      if (val) *val = (long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif

SWIGINTERN PyObject *fz_document_s_findBookmark(struct fz_document_s *self,long long bookmark){
            int i = -1;
            if (fz_is_document_reflowable(gctx, self))
            {
                fz_bookmark m = (fz_bookmark) bookmark;
                i = fz_lookup_bookmark(gctx, self, m);
            }
            return Py_BuildValue("i", i);
        }
SWIGINTERN PyObject *fz_document_s_isReflowable(struct fz_document_s *self){
            return JM_BOOL(fz_is_document_reflowable(gctx, self));
        }
SWIGINTERN PyObject *fz_document_s__deleteObject(struct fz_document_s *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (!INRANGE(xref, 1, pdf_xref_len(gctx, pdf)-1))
                    THROWMSG("xref out of range");
                pdf_delete_object(gctx, pdf, xref);
            }
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_document_s__getPDFroot(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            int xref = 0;
            if (!pdf) return Py_BuildValue("i", xref);
            fz_try(gctx)
            {
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf),
                                             PDF_NAME(Root));
                xref = pdf_to_num(gctx, root);
            }
            fz_catch(gctx) {;}
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *fz_document_s__getPDFfileid(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) return NONE;
            PyObject *idlist = PyList_New(0);
            fz_buffer *buffer = NULL;
            char *hex;
            pdf_obj *o;
            int n, i, len;
            PyObject *bytes;
            fz_try(gctx)
            {
                pdf_obj *identity = pdf_dict_get(gctx, pdf_trailer(gctx, pdf),
                                             PDF_NAME(ID));
                if (identity)
                {
                    n = pdf_array_len(gctx, identity);
                    for (i = 0; i < n; i++)
                    {
                        o = pdf_array_get(gctx, identity, i);
                        len = pdf_to_str_len(gctx, o);
                        buffer = fz_new_buffer(gctx, 2 * len);
                        fz_buffer_storage(gctx, buffer, &hex);
                        hexlify(len, (unsigned char *) pdf_to_str_buf(gctx, o), (unsigned char *) hex);
                        PyList_Append(idlist, Py_BuildValue("s", hex));
                        Py_CLEAR(bytes);
                        fz_drop_buffer(gctx, buffer);
                        buffer = NULL;
                    }
                }
            }
            fz_catch(gctx) fz_drop_buffer(gctx, buffer);
            return idlist;
        }
SWIGINTERN PyObject *fz_document_s_isPDF(struct fz_document_s *self){
            if (pdf_specifics(gctx, self)) Py_RETURN_TRUE;
            else Py_RETURN_FALSE;
        }
SWIGINTERN PyObject *fz_document_s__hasXrefStream(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) Py_RETURN_FALSE;
            if (pdf->has_xref_streams) Py_RETURN_TRUE;
            Py_RETURN_FALSE;
        }
SWIGINTERN PyObject *fz_document_s__hasXrefOldStyle(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) Py_RETURN_FALSE;
            if (pdf->has_old_style_xrefs) Py_RETURN_TRUE;
            Py_RETURN_FALSE;
        }
SWIGINTERN PyObject *fz_document_s_isDirty(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) Py_RETURN_FALSE;
            return JM_BOOL(pdf_has_unsaved_changes(gctx, pdf));
        }
SWIGINTERN PyObject *fz_document_s__getGCTXerrcode(struct fz_document_s *self){
            return Py_BuildValue("i", fz_caught(gctx));
        }
SWIGINTERN PyObject *fz_document_s__getGCTXerrmsg(struct fz_document_s *self){
            return Py_BuildValue("s", fz_caught_message(gctx));
        }
SWIGINTERN PyObject *fz_document_s_authenticate(struct fz_document_s *self,char *password){
            return Py_BuildValue("i", fz_authenticate_password(gctx, self, (const char *) password));
        }
SWIGINTERN PyObject *fz_document_s_save(struct fz_document_s *self,char *filename,int garbage,int clean,int deflate,int incremental,int ascii,int expand,int linear,int pretty,int decrypt){
            int errors = 0;
            pdf_write_options opts = { 0 };
            opts.do_incremental     = incremental;
            opts.do_ascii           = ascii;
            opts.do_compress        = deflate;
            opts.do_compress_images = deflate;
            opts.do_compress_fonts  = deflate;
            opts.do_decompress      = expand;
            opts.do_garbage         = garbage;
            opts.do_linear          = linear;
            opts.do_clean           = clean;
            opts.do_pretty          = pretty;
            opts.do_sanitize        = clean;
            opts.continue_on_error  = 1;
            opts.errors = &errors;
            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                JM_embedded_clean(gctx, pdf);
                JM_save_document(gctx, pdf, filename, &opts, decrypt);
                pdf->dirty = 0;
            }
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_document_s_write(struct fz_document_s *self,int garbage,int clean,int deflate,int ascii,int expand,int linear,int pretty,int decrypt){
            PyObject *r = NULL;
            fz_output *out = NULL;
            fz_buffer *res = NULL;
            int errors = 0;
            pdf_write_options opts = { 0 };
            opts.do_incremental     = 0;
            opts.do_ascii           = ascii;
            opts.do_compress        = deflate;
            opts.do_compress_images = deflate;
            opts.do_compress_fonts  = deflate;
            opts.do_decompress      = expand;
            opts.do_garbage         = garbage;
            opts.do_linear          = linear;
            opts.do_clean           = clean;
            opts.do_pretty          = pretty;
            opts.do_sanitize        = clean;
            opts.continue_on_error  = 1;
            opts.errors = &errors;
            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_var(out);
            fz_var(r);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (fz_count_pages(gctx, self) < 1)
                    THROWMSG("cannot save with zero pages");
                JM_embedded_clean(gctx, pdf);
                res = fz_new_buffer(gctx, 8192);
                out = fz_new_output_with_buffer(gctx, res);
                JM_write_document(gctx, pdf, out, &opts, decrypt);
                r = JM_BinFromBuffer(gctx, res);
                pdf->dirty = 0;
            }
            fz_always(gctx)
                {
                    fz_drop_buffer(gctx, res);
                    fz_drop_output(gctx, out);
                }
            fz_catch(gctx)
            {
                return NULL;
            }
            return r;
        }
SWIGINTERN PyObject *fz_document_s_insertPDF(struct fz_document_s *self,struct fz_document_s *docsrc,int from_page,int to_page,int start_at,int rotate,int links){
            pdf_document *pdfout = pdf_specifics(gctx, self);
            pdf_document *pdfsrc = pdf_specifics(gctx, docsrc);
            int outCount = fz_count_pages(gctx, self);
            int srcCount = fz_count_pages(gctx, docsrc);

            // local copies of page numbers
            int fp = from_page, tp = to_page, sa = start_at;

            // normalize page numbers
            fp = MAX(fp, 0);                // -1 = first page
            fp = MIN(fp, srcCount - 1);     // but do not exceed last page

            if (tp < 0) tp = srcCount - 1;  // -1 = last page
            tp = MIN(tp, srcCount - 1);     // but do not exceed last page

            if (sa < 0) sa = outCount;      // -1 = behind last page
            sa = MIN(sa, outCount);         // but that is also the limit

            fz_try(gctx)
            {
                if (!pdfout || !pdfsrc) THROWMSG("source or target not a PDF");
                merge_range(gctx, pdfout, pdfsrc, fp, tp, sa, rotate);
            }
            fz_catch(gctx) return NULL;
            pdfout->dirty = 1;
            return NONE;
        }
SWIGINTERN int fz_document_s_insertPage(struct fz_document_s *self,int pno,PyObject *text,float fontsize,float width,float height,int idx,char *fontname,char *fontfile,int set_simple,PyObject *color){
            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_rect mediabox = { 0, 0, 595, 842 };    // ISO-A4 portrait values
            mediabox.x1 = width;
            mediabox.y1 = height;
            pdf_obj *resources = NULL, *page_obj = NULL;
            fz_buffer *contents = NULL;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (pno < -1) THROWMSG("invalid page number(s)");
                // create /Resources and /Contents objects
                resources = pdf_add_object_drop(gctx, pdf, pdf_new_dict(gctx, pdf, 1));
                contents = fz_new_buffer(gctx, 10);
                fz_append_string(gctx, contents, "");
                fz_terminate_buffer(gctx, contents);
                page_obj = pdf_add_page(gctx, pdf, mediabox, 0, resources, contents);
                pdf_insert_page(gctx, pdf, pno , page_obj);
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, contents);
                pdf_drop_obj(gctx, page_obj);
            }
            fz_catch(gctx) return -1;
            pdf->dirty = 1;
            return 0;
        }

SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}

SWIGINTERN PyObject *fz_document_s_select(struct fz_document_s *self,PyObject *pyliste){
            // preparatory stuff:
            // (1) get underlying pdf document,
            // (2) transform Python list into integer array
            
            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (!PySequence_Check(pyliste))
                    THROWMSG("sequence required");
                if (PySequence_Size(pyliste) < 1)
                    THROWMSG("invalid sequ. length");        
                // now call retainpages (code copy of fz_clean_file.c)
                globals glo = {0};
                glo.ctx = gctx;
                glo.doc = pdf;
                retainpages(gctx, &glo, pyliste);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return NONE;
        }
SWIGINTERN PyObject *fz_document_s_permissions(struct fz_document_s *self){
            PyObject *p = JM_BOOL(fz_has_permission(gctx, self, FZ_PERMISSION_PRINT));
            PyObject *e = JM_BOOL(fz_has_permission(gctx, self, FZ_PERMISSION_EDIT));
            PyObject *c = JM_BOOL(fz_has_permission(gctx, self, FZ_PERMISSION_COPY));
            PyObject *n = JM_BOOL(fz_has_permission(gctx, self, FZ_PERMISSION_ANNOTATE));
            PyObject *res = PyDict_New();
            PyDict_SetItemString(res, "print", p);
            PyDict_SetItemString(res, "edit", e);
            PyDict_SetItemString(res, "copy", c);
            PyDict_SetItemString(res, "note", n);
            return res;
        }
SWIGINTERN PyObject *fz_document_s__getCharWidths(struct fz_document_s *self,int xref,char *bfname,char *ext,int ordering,int limit,int idx){
            pdf_document *pdf = pdf_specifics(gctx, self);
            PyObject *wlist = NULL;
            int i, glyph, mylimit;
            mylimit = limit;
            if (mylimit < 256) mylimit = 256;
            int cwlen = 0;
            int lang = 0;
            const char *data;
            int size, index;
            fz_font *font = NULL, *fb_font= NULL;
            fz_buffer *buf = NULL;

            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (ordering >= 0)
                {
                    data = fz_lookup_cjk_font(gctx, ordering, &size, &index);
                    font = fz_new_font_from_memory(gctx, NULL, data, size, index, 0);
                    goto weiter;
                }
                data = fz_lookup_base14_font(gctx, bfname, &size);
                if (data)
                {
                    font = fz_new_font_from_memory(gctx, bfname, data, size, 0, 0);
                    goto weiter;
                }
                buf = fontbuffer(gctx, pdf, xref);
                if (!buf) THROWMSG("xref is not a supported font");
                font = fz_new_font_from_buffer(gctx, NULL, buf, idx, 0);

                weiter:;
                wlist = PyList_New(0);
                float adv;
                for (i = 0; i < mylimit; i++)
                {
                    glyph = fz_encode_character(gctx, font, i);
                    adv = fz_advance_glyph(gctx, font, glyph, 0);
                    if (ordering >= 0)
                        glyph = i;


                    if (glyph > 0)
                    {
                        PyList_Append(wlist, Py_BuildValue("(i, f)", glyph, adv));
                    }
                    else
                    {
                        PyList_Append(wlist, Py_BuildValue("(i, f)", glyph, 0.0));
                    }
                }
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, buf);
                fz_drop_font(gctx, font);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return wlist;
        }
SWIGINTERN PyObject *fz_document_s__getPageObjNumber(struct fz_document_s *self,int pno){
            int pageCount = fz_count_pages(gctx, self);
            pdf_document *pdf = pdf_specifics(gctx, self);
            int n = pno;
            while (n < 0) n += pageCount;
            pdf_obj *pageref = NULL;
            fz_var(pageref);
            fz_try(gctx)
            {
                if (n >= pageCount) THROWMSG("invalid page number(s)");
                assert_PDF(pdf);
                pageref = pdf_lookup_page_obj(gctx, pdf, n);
            }
            fz_catch(gctx) return NULL;

            return Py_BuildValue("ii", pdf_to_num(gctx, pageref),
                                       pdf_to_gen(gctx, pageref));
        }
SWIGINTERN PyObject *fz_document_s__getPageInfo(struct fz_document_s *self,int pno,int what){
            pdf_document *pdf = pdf_specifics(gctx, self);
            int pageCount = fz_count_pages(gctx, self);
            pdf_obj *pageref, *rsrc;
            PyObject *liste = NULL;         // returned object
            int n = pno;                    // pno < 0 is allowed
            while (n < 0) n += pageCount;
            fz_var(liste);
            fz_try(gctx)
            {
                if (n >= pageCount) THROWMSG("invalid page number(s)");
                assert_PDF(pdf);
                pageref = pdf_lookup_page_obj(gctx, pdf, n);
                rsrc = pdf_dict_get(gctx, pageref, PDF_NAME(Resources));
                if (!pageref || !rsrc) THROWMSG("cannot retrieve page info");
                liste = PyList_New(0);
                JM_scan_resources(gctx, pdf, rsrc, liste, what);
            }
            fz_catch(gctx)
            {
                Py_XDECREF(liste);
                return NULL;
            }
            return liste;
        }
SWIGINTERN PyObject *fz_document_s_extractFont(struct fz_document_s *self,int xref,int info_only){
            pdf_document *pdf = pdf_specifics(gctx, self);
            
            fz_try(gctx) assert_PDF(pdf);
            fz_catch(gctx) return NULL;

            fz_buffer *buffer = NULL;
            pdf_obj *obj, *basefont, *bname;
            PyObject *bytes = PyBytes_FromString("");
            char *ext = NULL;
            char *fontname = NULL;
            PyObject *nulltuple = Py_BuildValue("sssO", "", "", "", bytes);
            PyObject *tuple;
            Py_ssize_t len = 0;
            fz_try(gctx)
            {
                obj = pdf_load_object(gctx, pdf, xref);
                pdf_obj *type = pdf_dict_get(gctx, obj, PDF_NAME(Type));
                pdf_obj *subtype = pdf_dict_get(gctx, obj, PDF_NAME(Subtype));
                if(pdf_name_eq(gctx, type, PDF_NAME(Font)) && 
                   strncmp(pdf_to_name(gctx, subtype), "CIDFontType", 11) != 0)
                {
                    basefont = pdf_dict_get(gctx, obj, PDF_NAME(BaseFont));
                    if (!basefont || pdf_is_null(gctx, basefont))
                        bname = pdf_dict_get(gctx, obj, PDF_NAME(Name));
                    else
                        bname = basefont;
                    ext = fontextension(gctx, pdf, xref);
                    if (strcmp(ext, "n/a") != 0 && !info_only)
                    {
                        buffer = fontbuffer(gctx, pdf, xref);
                        bytes = JM_BinFromBuffer(gctx, buffer);
                        fz_drop_buffer(gctx, buffer);
                    }
                    fontname = (char *) JM_ASCIIFromChar((char *) pdf_to_name(gctx, bname));
                    tuple = Py_BuildValue("sssO",
                                fontname,
                                ext,
                                pdf_to_name(gctx, subtype),
                                bytes);
                }
                else
                {
                    tuple = nulltuple;
                }
            }
            fz_always(gctx)
            {
                JM_PyErr_Clear;
                JM_Free(fontname);
            }

            fz_catch(gctx)
            {
                tuple = Py_BuildValue("sssO", "invalid-name", "", "", bytes);
            }
            return tuple;
        }
SWIGINTERN PyObject *fz_document_s_extractImage(struct fz_document_s *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (!INRANGE(xref, 1, pdf_xref_len(gctx, pdf)-1))
                    THROWMSG("xref out of range");
            }
            fz_catch(gctx) return NULL;

            fz_buffer *buffer = NULL, *freebuf = NULL;
            fz_var(freebuf);
            fz_pixmap *pix = NULL;
            fz_var(pix);
            pdf_obj *obj = NULL;
            PyObject *rc = NULL;
            unsigned char ext[5];
            fz_image *image = NULL;
            fz_var(image);
            fz_output *out = NULL;
            fz_var(out);
            fz_compressed_buffer *cbuf = NULL;
            int type = 0, n = 0, xres = 0, yres = 0;
            int smask = 0, width = 0, height = 0;
            fz_try(gctx)
            {
                obj = pdf_new_indirect(gctx, pdf, xref, 0);
                pdf_obj *subtype = pdf_dict_get(gctx, obj, PDF_NAME(Subtype));
                if (pdf_name_eq(gctx, subtype, PDF_NAME(Image)))
                {
                    image = pdf_load_image(gctx, pdf, obj);
                    cbuf = fz_compressed_image_buffer(gctx, image);
                    type = cbuf == NULL ? FZ_IMAGE_UNKNOWN : cbuf->params.type;
                    // ensure returning a PNG for unsupported images ----------
                    if (type < FZ_IMAGE_BMP) type = FZ_IMAGE_UNKNOWN;

                    pdf_obj *o = pdf_dict_get(gctx, obj, PDF_NAME(SMask));
                    if (o) smask = pdf_to_num(gctx, o);

                    o = pdf_dict_get(gctx, obj, PDF_NAME(Width));
                    if (o) width = pdf_to_int(gctx, o);

                    o = pdf_dict_get(gctx, obj, PDF_NAME(Height));
                    if (o) height = pdf_to_int(gctx, o);

                    n = fz_colorspace_n(gctx, image->colorspace);
                    fz_image_resolution(image, &xres, &yres);
                    if (type != FZ_IMAGE_UNKNOWN)
                    {
                        buffer = cbuf->buffer;   // we will return this buffer
                        switch(type)
                        {
                            case(FZ_IMAGE_BMP):  strcpy(ext, "bmp");  break;
                            case(FZ_IMAGE_GIF):  strcpy(ext, "gif");  break;
                            case(FZ_IMAGE_JPEG): strcpy(ext, "jpeg"); break;
                            case(FZ_IMAGE_JPX):  strcpy(ext, "jpx");  break;
                            case(FZ_IMAGE_JXR):  strcpy(ext, "jxr");  break;
                            case(FZ_IMAGE_PNM):  strcpy(ext, "pnm");  break;
                            case(FZ_IMAGE_TIFF): strcpy(ext, "tiff"); break;
                            default:             strcpy(ext, "png");  break;
                        }
                    }
                    else     // we need a pixmap for making the PNG buffer
                    {
                        pix = fz_get_pixmap_from_image(gctx, image,
                                                       NULL, NULL, NULL, NULL);
                        n = pix->n;
                        // only gray & rgb pixmaps support PNG!
                        if (pix->colorspace &&
                            pix->colorspace != fz_device_gray(gctx) &&
                            pix->colorspace != fz_device_rgb(gctx))
                        {
                            fz_pixmap *pix2 = fz_convert_pixmap(gctx, pix,
                                     fz_device_rgb(gctx), NULL, NULL, NULL, 1);
                            fz_drop_pixmap(gctx, pix);
                            pix = pix2;
                        }

                        freebuf = fz_new_buffer(gctx, 2048);
                        out = fz_new_output_with_buffer(gctx, freebuf);
                        fz_write_pixmap_as_png(gctx, out, pix);
                        buffer = freebuf;
                        strcpy(ext, "png");
                    }
                    PyObject *bytes = JM_BinFromBuffer(gctx, buffer);
                    rc = Py_BuildValue("{s:s,s:i,s:i,s:i,s:i,s:i,s:i,s:O}",
                                       "ext", ext,
                                       "smask", smask,
                                       "width", width,
                                       "height", height,
                                       "colorspace", n,
                                       "xres", xres,
                                       "yres", yres,
                                       "image", bytes);
                    Py_CLEAR(bytes);
                }
                else
                    rc = PyDict_New();
            }
            fz_always(gctx)
            {
                fz_drop_image(gctx, image);
                fz_drop_buffer(gctx, freebuf);
                fz_drop_output(gctx, out);
                fz_drop_pixmap(gctx, pix);
                pdf_drop_obj(gctx, obj);
            }
            fz_catch(gctx) {;}
            return rc;
        }
SWIGINTERN PyObject *fz_document_s__delToC(struct fz_document_s *self){
            PyObject *xrefs = PyList_New(0);          // create Python list

            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) return xrefs;                   // not a pdf

            pdf_obj *root, *olroot, *first;
            int xref_count, olroot_xref, i, xref;

            // get the main root
            root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
            // get the outline root
            olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
            if (!olroot) return xrefs;                // no outlines or some problem

            first = pdf_dict_get(gctx, olroot, PDF_NAME(First)); // first outline

            xrefs = JM_outline_xrefs(gctx, first, xrefs);
            xref_count = (int) PyList_Size(xrefs);

            olroot_xref = pdf_to_num(gctx, olroot);        // delete OL root
            pdf_delete_object(gctx, pdf, olroot_xref);     // delete OL root
            pdf_dict_del(gctx, root, PDF_NAME(Outlines));  // delete OL root

            for (i = 0; i < xref_count; i++)
            {
                xref = (int) PyInt_AsLong(PyList_GetItem(xrefs, i));
                pdf_delete_object(gctx, pdf, xref);      // delete outline item
            }
            PyList_Append(xrefs, Py_BuildValue("i", olroot_xref));
            pdf->dirty = 1;
            return xrefs;
        }
SWIGINTERN PyObject *fz_document_s_isFormPDF(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) Py_RETURN_FALSE;           // not a PDF
            pdf_obj *form = NULL;
            pdf_obj *fields = NULL;
            int have_form = 0;                   // preset indicator
            fz_try(gctx)
            {
                form = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root), PDF_NAME(AcroForm), NULL);
                if (form)                        // form obj exists
                {
                    fields = pdf_dict_get(gctx, form, PDF_NAME(Fields));
                    if (fields && pdf_array_len(gctx, fields) > 0) have_form = 1;
                }
            }
            fz_catch(gctx) Py_RETURN_FALSE;      // any problem yields false
            if (!have_form) Py_RETURN_FALSE;     // no form / no fields
            Py_RETURN_TRUE;
        }
SWIGINTERN PyObject *fz_document_s_FormFonts(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) return NONE;           // not a PDF
            pdf_obj *fonts = NULL;
            PyObject *liste = PyList_New(0);
            fz_try(gctx)
            {
                fonts = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root), PDF_NAME(AcroForm), PDF_NAME(DR), PDF_NAME(Font), NULL);
                if (fonts && pdf_is_dict(gctx, fonts))       // fonts exist
                {
                    int i, n = pdf_dict_len(gctx, fonts);
                    for (i = 0; i < n; i++)
                    {
                        pdf_obj *f = pdf_dict_get_key(gctx, fonts, i);
                        PyList_Append(liste, Py_BuildValue("s", pdf_to_name(gctx, f)));
                    }
                }
            }
            fz_catch(gctx) NONE;       // any problem yields None
            return liste;
        }
SWIGINTERN PyObject *fz_document_s__addFormFont(struct fz_document_s *self,char *name,char *font){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) NONE;           // not a PDF
            pdf_obj *fonts = NULL;
            fz_try(gctx)
            {
                fonts = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root),
                             PDF_NAME(AcroForm), PDF_NAME(DR), PDF_NAME(Font), NULL);
                if (!fonts || !pdf_is_dict(gctx, fonts))
                    THROWMSG("PDF has no form fonts yet");
                pdf_obj *k = pdf_new_name(gctx, (const char *) name);
                pdf_obj *v = JM_pdf_obj_from_str(gctx, pdf, font);
                pdf_dict_put(gctx, fonts, k, v);
            }
            fz_catch(gctx) NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_document_s__getOLRootNumber(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_try(gctx) assert_PDF(pdf);
            fz_catch(gctx) return NULL;
            
            pdf_obj *root, *olroot, *ind_obj;
            // get main root
            root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
            // get outline root
            olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
            if (!olroot)
            {
                olroot = pdf_new_dict(gctx, pdf, 4);
                pdf_dict_put(gctx, olroot, PDF_NAME(Type), PDF_NAME(Outlines));
                ind_obj = pdf_add_object(gctx, pdf, olroot);
                pdf_dict_put(gctx, root, PDF_NAME(Outlines), ind_obj);
                olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
                pdf_drop_obj(gctx, ind_obj);
                pdf->dirty = 1;
            }
            return Py_BuildValue("i", pdf_to_num(gctx, olroot));
        }
SWIGINTERN PyObject *fz_document_s__getNewXref(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self); /* conv doc to pdf*/
            fz_try(gctx) assert_PDF(pdf);
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return Py_BuildValue("i", pdf_create_object(gctx, pdf));
        }
SWIGINTERN PyObject *fz_document_s__getXrefLength(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            int xreflen = 0;
            if (pdf) xreflen = pdf_xref_len(gctx, pdf);
            return Py_BuildValue("i", xreflen);
        }
SWIGINTERN PyObject *fz_document_s__getXmlMetadataXref(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self); // get pdf document
            pdf_obj *xml;
            int xref = 0;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                if (!root) THROWMSG("could not load root object");
                xml = pdf_dict_gets(gctx, root, "Metadata");
                if (xml) xref = pdf_to_num(gctx, xml);
            }
            fz_catch(gctx) {;}
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *fz_document_s__delXmlMetadata(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self); // get pdf document
            fz_try(gctx)
            {
                assert_PDF(pdf);
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                if (root) pdf_dict_dels(gctx, root, "Metadata");
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return NONE;
        }
SWIGINTERN PyObject *fz_document_s__getXrefString(struct fz_document_s *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, self); // conv doc to pdf
            pdf_obj *obj = NULL;
            fz_buffer *res = NULL;
            fz_output *out = NULL;
            PyObject *text = NULL;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                res = fz_new_buffer(gctx, 1024);
                out = fz_new_output_with_buffer(gctx, res);
                obj = pdf_load_object(gctx, pdf, xref);
                pdf_print_obj(gctx, out, pdf_resolve_indirect(gctx, obj), 1);
                text = JM_StrFromBuffer(gctx, res);
            }
            fz_always(gctx)
            {
                pdf_drop_obj(gctx, obj);
                fz_drop_output(gctx, out);
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) return NULL;
            return text;
        }
SWIGINTERN PyObject *fz_document_s__getXrefStream(struct fz_document_s *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, self);
            PyObject *r = NONE;
            pdf_obj *obj = NULL;
            fz_var(obj);
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                obj = pdf_new_indirect(gctx, pdf, xref, 0);
                if (pdf_is_stream(gctx, obj))
                {
                    res = pdf_load_stream_number(gctx, pdf, xref);
                    r = JM_BinFromBuffer(gctx, res);
                }
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
                pdf_drop_obj(gctx, obj);
            }
            fz_catch(gctx)
            {
                Py_CLEAR(r);
                return NULL;
            }
            return r;
        }
SWIGINTERN PyObject *fz_document_s__updateObject(struct fz_document_s *self,int xref,char *text,struct fz_page_s *page){
            pdf_obj *new_obj;
            pdf_document *pdf = pdf_specifics(gctx, self);     // get pdf doc
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                // create new object with passed-in string
                new_obj = JM_pdf_obj_from_str(gctx, pdf, text);
                pdf_update_object(gctx, pdf, xref, new_obj);
                pdf_drop_obj(gctx, new_obj);
                if (page) refresh_link_table(gctx, pdf_page_from_fz_page(gctx, page));
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return NONE;
        }
SWIGINTERN PyObject *fz_document_s__updateStream(struct fz_document_s *self,int xref,PyObject *stream,int new){
            pdf_obj *obj = NULL;
            fz_var(obj);
            fz_buffer *res = NULL;
            fz_var(res);
            pdf_document *pdf = pdf_specifics(gctx, self);     // get pdf doc
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                // get the object
                obj = pdf_new_indirect(gctx, pdf, xref, 0);
                if (!new && !pdf_is_stream(gctx, obj))
                    THROWMSG("xref not a stream object");
                res = JM_BufferFromBytes(gctx, stream);
                if (!res) THROWMSG("stream must be bytes or bytearray");
                JM_update_stream(gctx, pdf, obj, res);
                
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
                pdf_drop_obj(gctx, obj);
            }
            fz_catch(gctx)
                return NULL;
            pdf->dirty = 1;
            return NONE;
        }
SWIGINTERN PyObject *fz_document_s__setMetadata(struct fz_document_s *self,char *text){
            pdf_obj *info, *new_info, *new_info_ind;
            int info_num = 0;               // will contain xref no of info object
            pdf_document *pdf = pdf_specifics(gctx, self);     // get pdf doc
            fz_try(gctx) {
                assert_PDF(pdf);
                // create new /Info object based on passed-in string
                new_info = JM_pdf_obj_from_str(gctx, pdf, text);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            // replace existing /Info object
            info = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Info));
            if (info)
            {
                info_num = pdf_to_num(gctx, info);    // get xref no of old info
                pdf_update_object(gctx, pdf, info_num, new_info);  // insert new
                pdf_drop_obj(gctx, new_info);
                return NONE;
            }
            // create new indirect object from /Info object
            new_info_ind = pdf_add_object(gctx, pdf, new_info);
            // put this in the trailer dictionary
            pdf_dict_put_drop(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Info), new_info_ind);
            return NONE;
        }
SWIGINTERN void delete_fz_page_s(struct fz_page_s *self){
            DEBUGMSG1("page");
            fz_drop_page(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *fz_page_s_bound(struct fz_page_s *self){
            fz_rect rect = fz_bound_page(gctx, self);
            return JM_py_from_rect(rect);
        }
SWIGINTERN PyObject *fz_page_s_run(struct fz_page_s *self,struct DeviceWrapper *dw,PyObject *m){
            fz_try(gctx) fz_run_page(gctx, self, dw->device, JM_matrix_from_py(m), NULL);
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_page_s_getSVGimage(struct fz_page_s *self,PyObject *matrix){
            fz_rect mediabox = fz_bound_page(gctx, self);
            fz_device *dev = NULL;
            fz_buffer *res = NULL;
            PyObject *text = NULL;
            fz_matrix ctm = JM_matrix_from_py(matrix);
            fz_cookie *cookie = NULL;
            fz_output *out = NULL;
            fz_separations *seps = NULL;
            fz_var(out);
            fz_var(dev);
            fz_var(res);
            fz_rect tbounds = mediabox;
            tbounds = fz_transform_rect(tbounds, ctm);

            fz_try(gctx)
            {
                res = fz_new_buffer(gctx, 1024);
                out = fz_new_output_with_buffer(gctx, res);
                dev = fz_new_svg_device(gctx, out, tbounds.x1-tbounds.x0, tbounds.y1-tbounds.y0, FZ_SVG_TEXT_AS_PATH, 1);
                fz_run_page(gctx, self, dev, ctm, cookie);
                fz_close_device(gctx, dev);
                text = JM_StrFromBuffer(gctx, res);
            }
            fz_always(gctx)
            {
                fz_drop_device(gctx, dev);
                fz_drop_output(gctx, out);
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return text;
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addLineAnnot(struct fz_page_s *self,PyObject *p1,PyObject *p2){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            float col[3] = {0, 0, 0};
            float width  = 1.0f;
            fz_point a = JM_point_from_py(p1);
            fz_point b = JM_point_from_py(p2);
            fz_rect r  = {MIN(a.x, b.x), MIN(a.y, b.y), MAX(a.x, b.x), MAX(a.y, b.y)};
            fz_var(annot);
            fz_try(gctx)
            {
                assert_PDF(page);
                pdf_document *pdf = page->doc;
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_LINE);
                pdf_set_annot_line(gctx, annot, a, b);
                pdf_set_annot_border(gctx, annot, width);
                pdf_set_annot_color(gctx, annot, 3, col);
                r = fz_expand_rect(r, 3 * width);
                pdf_set_annot_rect(gctx, annot, r);
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            fz_annot *fzannot = (fz_annot *) annot;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addTextAnnot(struct fz_page_s *self,PyObject *point,char *text){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            fz_point pos = JM_point_from_py(point);
            fz_var(annot);
            fz_try(gctx)
            {
                assert_PDF(page);
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_TEXT);
                pdf_set_text_annot_position(gctx, annot, pos);
                pdf_set_annot_contents(gctx, annot, text);
                pdf_set_annot_icon_name(gctx, annot, "Note");
                float col[3] = {0.9f, 0.9f, 0.0f};
                pdf_set_annot_color(gctx, annot, 3, col);
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            fz_annot *fzannot = (fz_annot *) annot;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addInkAnnot(struct fz_page_s *self,PyObject *list){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            PyObject *p = NULL, *sublist = NULL;
            pdf_obj *inklist = NULL, *stroke = NULL;
            fz_matrix ctm, inv_ctm;
            double x, y;
            fz_point point;
            fz_var(annot);
            fz_try(gctx)
            {
                assert_PDF(page);
                if (!PySequence_Check(list)) THROWMSG("arg must be a sequence");
                pdf_page_transform(gctx, page, NULL, &ctm);
                inv_ctm = fz_invert_matrix(ctm);
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_INK);
                Py_ssize_t i, j, n0 = PySequence_Size(list), n1;
                inklist = pdf_new_array(gctx, annot->page->doc, n0);
                for (j = 0; j < n0; j++)
                {
                    sublist = PySequence_ITEM(list, j);
                    n1 = PySequence_Size(sublist);
                    stroke = pdf_new_array(gctx, annot->page->doc, 2 * n1);
                    for (i = 0; i < n1; i++)
                    {
                        p = PySequence_ITEM(sublist, i);
                        if (!PySequence_Check(p) || PySequence_Size(p) != 2)
                            THROWMSG("3rd level entries must be pairs of floats");
                        x = PyFloat_AsDouble(PySequence_ITEM(p, 0));
                        if (PyErr_Occurred())
                            THROWMSG("invalid point coordinate");
                        y = PyFloat_AsDouble(PySequence_ITEM(p, 1));
                        if (PyErr_Occurred())
                            THROWMSG("invalid point coordinate");
                        Py_CLEAR(p);
                        point = fz_transform_point(fz_make_point(x, y), inv_ctm);
                        pdf_array_push_real(gctx, stroke, point.x);
                        pdf_array_push_real(gctx, stroke, point.y);
                    }
                    pdf_array_push_drop(gctx, inklist, stroke);
                    stroke = NULL;
                    Py_CLEAR(sublist);
                }
                pdf_dict_put_drop(gctx, annot->obj, PDF_NAME(InkList), inklist);
                inklist = NULL;
                pdf_dirty_annot(gctx, annot);
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx)
            {
                Py_CLEAR(p);
                Py_CLEAR(sublist);
                return NULL;
            }

            fz_annot *fzannot = (fz_annot *) annot;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addStampAnnot(struct fz_page_s *self,PyObject *rect,int stamp){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            pdf_obj *stamp_id[] = {PDF_NAME(Approved), PDF_NAME(AsIs),
                                   PDF_NAME(Confidential), PDF_NAME(Departmental),
                                   PDF_NAME(Experimental), PDF_NAME(Expired),
                                   PDF_NAME(Final), PDF_NAME(ForComment),
                                   PDF_NAME(ForPublicRelease), PDF_NAME(NotApproved),
                                   PDF_NAME(NotForPublicRelease), PDF_NAME(Sold),
                                   PDF_NAME(TopSecret), PDF_NAME(Draft)};
            int n = nelem(stamp_id);
            pdf_obj *name = stamp_id[0];
            fz_var(annot);
            fz_try(gctx)
            {
                assert_PDF(page);
                if (INRANGE(stamp, 0, n-1))
                    name = stamp_id[stamp];
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_STAMP);
                pdf_set_annot_rect(gctx, annot, JM_rect_from_py(rect));
                pdf_dict_put(gctx, annot->obj, PDF_NAME(Name), name);
                pdf_set_annot_contents(gctx, annot,
                        pdf_dict_get_name(gctx, annot->obj, PDF_NAME(Name)));
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            fz_annot *fzannot = (fz_annot *) annot;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addFileAnnot(struct fz_page_s *self,PyObject *point,PyObject *buffer,char *filename,char *ufilename,char *desc){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_annot *fzannot = NULL;
            pdf_annot *annot = NULL;
            char *data = NULL, *uf = ufilename, *d = desc;
            if (!ufilename) uf = filename;
            if (!desc) d = filename;
            size_t len = 0;
            fz_buffer *filebuf = NULL;
            fz_point p = JM_point_from_py(point);
            fz_rect r = {p.x, p.y, p.x + 20, p.y + 30};
            fz_var(annot);
            fz_try(gctx)
            {
                assert_PDF(page);
                annot = pdf_create_annot(gctx, page, ANNOT_FILEATTACHMENT);
                pdf_set_annot_rect(gctx, annot, r);
                pdf_set_annot_icon_name(gctx, annot, "PushPin");
                len = JM_CharFromBytesOrArray(buffer, &data);
                filebuf = fz_new_buffer_from_shared_data(gctx, data, len);
                pdf_obj *val = JM_embed_file(gctx, page->doc, filebuf,
                                             filename, uf, d);
                pdf_dict_put(gctx, annot->obj, PDF_NAME(FS), val);
                pdf_dict_put_text_string(gctx, annot->obj, PDF_NAME(Contents), filename);
                float col[3] = {0.9f, 0.9f, 0.0f};
                pdf_set_annot_color(gctx, annot, 3, col);
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            fzannot = (fz_annot *) annot;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addStrikeoutAnnot(struct fz_page_s *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_annot *annot = NULL;
            fz_var(annot);
            fz_quad quad = JM_quad_from_py(rect);
            fz_try(gctx)
            {
                assert_PDF(page);
                annot = JM_AnnotTextmarker(gctx, page, quad, PDF_ANNOT_STRIKE_OUT);
            }
            fz_catch(gctx) return NULL;
            return fz_keep_annot(gctx, annot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addUnderlineAnnot(struct fz_page_s *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_annot *annot = NULL;
            fz_var(annot);
            fz_quad quad = JM_quad_from_py(rect);
            fz_try(gctx)
            {
                assert_PDF(page);
                annot = JM_AnnotTextmarker(gctx, page, quad, PDF_ANNOT_UNDERLINE);
            }
            fz_catch(gctx) return NULL;
            return fz_keep_annot(gctx, annot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addSquigglyAnnot(struct fz_page_s *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_annot *annot = NULL;
            fz_var(annot);
            fz_quad quad = JM_quad_from_py(rect);
            fz_try(gctx)
            {
                assert_PDF(page);
                annot = JM_AnnotTextmarker(gctx, page, quad, PDF_ANNOT_SQUIGGLY);
            }
            fz_catch(gctx) return NULL;
            return fz_keep_annot(gctx, annot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addHighlightAnnot(struct fz_page_s *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_annot *annot = NULL;
            fz_var(annot);
            fz_quad quad = JM_quad_from_py(rect);
            fz_try(gctx)
            {
                assert_PDF(page);
                annot = JM_AnnotTextmarker(gctx, page, quad, PDF_ANNOT_HIGHLIGHT);
            }
            fz_catch(gctx) return NULL;
            return fz_keep_annot(gctx, annot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addRectAnnot(struct fz_page_s *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_annot *fzannot = NULL;
            fz_var(fzannot);
            fz_try(gctx)
            {
                assert_PDF(page);
                fzannot = JM_AnnotCircleOrRect(gctx, page, rect, PDF_ANNOT_SQUARE);
            }
            fz_catch(gctx) return NULL;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addCircleAnnot(struct fz_page_s *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_annot *fzannot = NULL;
            fz_var(fzannot);
            fz_try(gctx)
            {
                assert_PDF(page);
                fzannot = JM_AnnotCircleOrRect(gctx, page, rect, PDF_ANNOT_CIRCLE);
            }
            fz_catch(gctx) return NULL;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addPolylineAnnot(struct fz_page_s *self,PyObject *points){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_annot *fzannot = NULL;
            fz_var(fzannot);
            fz_try(gctx)
            {
                assert_PDF(page);
                fzannot = JM_AnnotMultiline(gctx, page, points, PDF_ANNOT_POLY_LINE);
            }
            fz_catch(gctx) return NULL;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addPolygonAnnot(struct fz_page_s *self,PyObject *points){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_annot *fzannot = NULL;
            fz_var(fzannot);
            fz_try(gctx)
            {
                assert_PDF(page);
                fzannot = JM_AnnotMultiline(gctx, page, points, PDF_ANNOT_POLYGON);
            }
            fz_catch(gctx) return NULL;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s_addFreetextAnnot(struct fz_page_s *self,PyObject *rect,char *text,float fontsize,char *fontname,PyObject *color,int rotate){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            float bcol[3] = {1.0f, 1.0f, 1.0f};    // border, box color: white
            float col[4] = {0.0f, 0.0f, 0.0f, 0.0f}; // std. text color: black
            int ncol = 3;
            JM_color_FromSequence(color, &ncol,  col);
            fz_rect r = JM_rect_from_py(rect);
            pdf_annot *annot = NULL;
            fz_var(annot);
            fz_try(gctx)
            {
                assert_PDF(page);
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_FREE_TEXT);
                pdf_set_annot_contents(gctx, annot, text);
                pdf_set_annot_color(gctx, annot, 3, bcol); // set rect colors
                pdf_dict_put_int(gctx, annot->obj, PDF_NAME(Rotate), rotate);

                pdf_set_text_annot_position(gctx, annot, fz_make_point(r.x0, r.y0));
                pdf_set_annot_rect(gctx, annot, r);
                // insert the default appearance string
                JM_make_annot_DA(gctx, annot, ncol, col, fontname, fontsize);
                pdf_update_annot(gctx, annot);
            }
            fz_always(gctx) {;}
            fz_catch(gctx) return NULL;
            fz_annot *fzannot = (fz_annot *) annot;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_annot_s *fz_page_s__addWidget(struct fz_page_s *self,PyObject *Widget){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_document *pdf = page->doc;
            pdf_annot *annot = NULL;
            pdf_widget *widget = NULL;
            fz_var(annot);
            fz_try(gctx)
            {
                //-------------------------------------------------------------
                // create the widget - only need type and field name for this
                //-------------------------------------------------------------
                int field_type = (int) PyInt_AsLong(PyObject_GetAttrString(Widget,
                                                    "field_type"));
                JM_PyErr_Clear;

                char *field_name = JM_Python_str_AsChar(PyObject_GetAttrString(Widget,
                                                        "field_name"));
                JM_PyErr_Clear;

                widget = pdf_create_widget(gctx, pdf, page, field_type, field_name);
                JM_Python_str_DelForPy3(field_name);
                JM_PyErr_Clear;
                annot = (pdf_annot *) widget;

                //-------------------------------------------------------------
                // now field exists, adjust its properties
                //-------------------------------------------------------------
                JM_set_widget_properties(gctx, annot, Widget, field_type);
            }
            fz_always(gctx) JM_PyErr_Clear;
            fz_catch(gctx) return NULL;
            fz_annot *fzannot = (fz_annot *) annot;
            return fz_keep_annot(gctx, fzannot);
        }
SWIGINTERN struct fz_display_list_s *fz_page_s_getDisplayList(struct fz_page_s *self){
            fz_display_list *dl = NULL;
            fz_try(gctx) dl = fz_new_display_list_from_page(gctx, self);
            fz_catch(gctx) return NULL;
            return dl;
        }
SWIGINTERN PyObject *fz_page_s_setCropBox(struct fz_page_s *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_try(gctx)
            {
                assert_PDF(page);
                fz_rect mediabox = pdf_bound_page(gctx, page);
                pdf_obj *o = pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(MediaBox));
                if (o) mediabox = pdf_to_rect(gctx, o);
                fz_rect cropbox = fz_empty_rect;
                fz_rect r = JM_rect_from_py(rect);
                cropbox.x0 = r.x0;
                cropbox.y0 = mediabox.y1 - r.y1;
                cropbox.x1 = r.x1;
                cropbox.y1 = mediabox.y1 - r.y0;
                pdf_dict_put_drop(gctx, page->obj, PDF_NAME(CropBox),
                                  pdf_new_rect(gctx, page->doc, cropbox));
            }
            fz_catch(gctx) return NULL;
            page->doc->dirty = 1;
            return NONE;
        }
SWIGINTERN struct fz_link_s *fz_page_s_loadLinks(struct fz_page_s *self){
            fz_link *l = NULL;
            fz_try(gctx) l = fz_load_links(gctx, self);
            fz_catch(gctx) return NULL;
            return l;
        }
SWIGINTERN struct fz_annot_s *fz_page_s_firstAnnot(struct fz_page_s *self){
            fz_annot *annot;
            fz_try(gctx) annot = fz_first_annot(gctx, self);
            fz_catch(gctx) annot = NULL;
            if (annot) fz_keep_annot(gctx, annot);
            return annot;
        }
SWIGINTERN void fz_page_s_deleteLink(struct fz_page_s *self,PyObject *linkdict){
            if (!linkdict) return;               // have no parameter
            if (!PyDict_Check(linkdict)) return; // have no dictionary
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page) return;                   // have no PDF
            int xref = (int) PyInt_AsLong(PyDict_GetItemString(linkdict, "xref"));
            if (xref < 1) return;                // invalid xref
            pdf_obj *annots = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
            if (!annots) return;                 // have no annotations
            int len = pdf_array_len(gctx, annots);
            int i, oxref = 0;
            for (i = 0; i < len; i++)
            {
                oxref = pdf_to_num(gctx, pdf_array_get(gctx, annots, i));
                if (xref == oxref) break;        // found xref in annotations
            }
            if (xref != oxref) return;           // xref not in annotations
            pdf_array_delete(gctx, annots, i);   // delete entry in annotations
            pdf_delete_object(gctx, page->doc, xref);      // delete link object
            pdf_dict_put(gctx, page->obj, PDF_NAME(Annots), annots);
            refresh_link_table(gctx, page);            // reload link / annot tables
            page->doc->dirty = 1;
            return;
        }
SWIGINTERN struct fz_annot_s *fz_page_s_deleteAnnot(struct fz_page_s *self,struct fz_annot_s *fannot){
            if (!fannot) return NULL;
            fz_annot *nextannot = fz_next_annot(gctx, fannot);  // store next
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page)                 // no PDF, just return next annotation
                {
                if (nextannot) fz_keep_annot(gctx, nextannot);
                return nextannot;
                }
            pdf_annot *pannot = pdf_annot_from_fz_annot(gctx, fannot);
            pdf_delete_annot(gctx, page, pannot);
            if (nextannot) fz_keep_annot(gctx, nextannot);
            page->doc->dirty = 1;
            return nextannot;
        }
SWIGINTERN PyObject *fz_page_s_MediaBoxSize(struct fz_page_s *self){
            PyObject *p = JM_py_from_point(fz_make_point(0, 0));
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page) return p;
            fz_rect r = fz_empty_rect;
            pdf_obj *o = pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(MediaBox));
            if (!o) return p;

            r = pdf_to_rect(gctx, o);
            return JM_py_from_point(fz_make_point(r.x1 - r.x0, r.y1 - r.y0));
        }
SWIGINTERN PyObject *fz_page_s_CropBoxPosition(struct fz_page_s *self){
            PyObject *p = JM_py_from_point(fz_make_point(0, 0));
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page) return p;                 // not a PDF
            pdf_obj *o = pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(CropBox));
            if (!o) return p;                    // no CropBox specified
            fz_rect cbox = pdf_to_rect(gctx, o);
            return JM_py_from_point(fz_make_point(cbox.x0, cbox.y0));;
        }
SWIGINTERN int fz_page_s_rotation(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page) return -1;
            return pdf_to_int(gctx, pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(Rotate)));
        }
SWIGINTERN PyObject *fz_page_s_setRotation(struct fz_page_s *self,int rot){
            fz_try(gctx)
            {
                pdf_page *page = pdf_page_from_fz_page(gctx, self);
                assert_PDF(page);
                if (rot % 90) THROWMSG("rotation not multiple of 90");
                pdf_dict_put_int(gctx, page->obj, PDF_NAME(Rotate), (int64_t) rot);
                page->doc->dirty = 1;
            }
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_page_s__addAnnot_FromString(struct fz_page_s *self,PyObject *linklist){
            pdf_obj *annots, *annots_arr, *annot, *ind_obj, *new_array;
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            PyObject *txtpy;
            char *text;
            int lcount = (int) PySequence_Size(linklist); // new object count
            if (lcount < 1) return NONE;
            int i;
            fz_try(gctx)
            {
                assert_PDF(page);                // make sure we have a PDF
                // get existing annots array
                annots = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
                if (annots)
                    {
                        if (pdf_is_indirect(gctx, annots))
                            annots_arr = pdf_resolve_indirect(gctx, annots);
                        else annots_arr = annots;
                    }
                else
                    annots_arr = NULL;
                int new_len = lcount;
                if (annots_arr) new_len += pdf_array_len(gctx, annots_arr);
                // allocate new array of old plus new size
                new_array = pdf_new_array(gctx, page->doc, new_len);
                if (annots_arr)
                {   // copy existing annots to new array
                    for (i = 0; i < pdf_array_len(gctx, annots_arr); i++)
                            pdf_array_push(gctx, new_array, pdf_array_get(gctx, annots_arr, i));
                }
            }
            fz_catch(gctx) return NULL;

            // extract object sources from Python list and store as annotations
            for (i = 0; i < lcount; i++)
            {
                fz_try(gctx)
                {
                    text = NULL;
                    txtpy = PySequence_ITEM(linklist, (Py_ssize_t) i);
                    text = JM_Python_str_AsChar(txtpy);
                    if (!text) THROWMSG("non-string linklist item");
                    annot = JM_pdf_obj_from_str(gctx, page->doc, text);
                    JM_Python_str_DelForPy3(text);
                    ind_obj = pdf_add_object(gctx, page->doc, annot);
                    pdf_array_push_drop(gctx, new_array, ind_obj);
                    pdf_drop_obj(gctx, annot);
                }
                fz_catch(gctx)
                {
                    if (text)
                        PySys_WriteStderr("%s (%i): '%s'\n", fz_caught_message(gctx), i, text);
                    else
                        PySys_WriteStderr("%s (%i)\n", fz_caught_message(gctx), i);
                    JM_Python_str_DelForPy3(text);
                    PyErr_Clear();
                }
            }
            fz_try(gctx)
            {
                pdf_dict_put_drop(gctx, page->obj, PDF_NAME(Annots), new_array);
                refresh_link_table(gctx, page);
            }
            fz_catch(gctx) return NULL;
            page->doc->dirty = 1;
            return NONE;
        }
SWIGINTERN PyObject *fz_page_s__getLinkXrefs(struct fz_page_s *self){
            pdf_obj *annots, *annots_arr, *link, *obj;
            int i, lcount;
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            PyObject *linkxrefs = PyList_New(0);
            if (!page) return linkxrefs;         // empty list for non-PDF
            annots = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
            if (!annots) return linkxrefs;
            if (pdf_is_indirect(gctx, annots))
                annots_arr = pdf_resolve_indirect(gctx, annots);
            else
                annots_arr = annots;
            lcount = pdf_array_len(gctx, annots_arr);
            for (i = 0; i < lcount; i++)
            {
                link = pdf_array_get(gctx, annots_arr, i);
                obj = pdf_dict_get(gctx, link, PDF_NAME(Subtype));
                if (pdf_name_eq(gctx, obj, PDF_NAME(Link)))
                    PyList_Append(linkxrefs, Py_BuildValue("i", pdf_to_num(gctx, link)));
            }
            return linkxrefs;
        }
SWIGINTERN PyObject *fz_page_s__cleanContents(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot;
            fz_try(gctx)
            {
                assert_PDF(page);
                pdf_clean_page_contents(gctx, page->doc, page, NULL, NULL, NULL, 1, 0);
                for (annot = pdf_first_annot(gctx, page); annot != NULL; annot = pdf_next_annot(gctx, annot))
                {
                    pdf_clean_annot_contents(gctx, page->doc, annot, NULL, NULL, NULL, 1, 0);
                }
            }
            fz_catch(gctx) return NULL;
            page->doc->dirty = 1;
            return NONE;
        }
SWIGINTERN PyObject *fz_page_s__showPDFpage(struct fz_page_s *self,PyObject *rect,struct fz_document_s *docsrc,int pno,int overlay,int keep_proportion,int reuse_xref,PyObject *clip,struct pdf_graft_map_s *graftmap,char *_imgname){
            int xref = reuse_xref;
            pdf_obj *xobj1, *xobj2, *resources, *o;
            fz_buffer *res, *nres;
            fz_rect mediabox;
            fz_rect cropbox;
            fz_rect rrect = JM_rect_from_py(rect);
            fz_try(gctx)
            {
                pdf_page *tpage = pdf_page_from_fz_page(gctx, self);
                assert_PDF(tpage);
                if (fz_is_infinite_rect(rrect) || fz_is_empty_rect(rrect))
                    THROWMSG("rect must be finite and not empty");
                pdf_obj *tpageref = tpage->obj;
                pdf_document *pdfout = tpage->doc;    // target PDF
                pdf_document *pdfsrc = pdf_specifics(gctx, docsrc);
                assert_PDF(pdfsrc);

                //-------------------------------------------------------------
                // make XObject of source page and get its xref
                //-------------------------------------------------------------
                xobj1 = JM_xobject_from_page(gctx, pdfout, pdfsrc, pno,
                                             &mediabox, &cropbox, xref, graftmap);
                xref = pdf_to_num(gctx, xobj1);

                //-------------------------------------------------------------
                // Calculate /Matrix and /BBox of the referencing XObject
                //-------------------------------------------------------------
                fz_rect rclip = JM_rect_from_py(clip);
                if (!fz_is_infinite_rect(rclip))   // set cropbox if clip given
                {
                    cropbox.x0 = rclip.x0;
                    cropbox.y0 = mediabox.y1 - rclip.y1;
                    cropbox.x1 = rclip.x1;
                    cropbox.y1 = mediabox.y1 - rclip.y0;
                }
                fz_matrix mat = fz_identity;
                fz_rect prect = fz_bound_page(gctx, self);
                fz_rect r = fz_empty_rect;
                o = pdf_dict_get_inheritable(gctx, tpageref, PDF_NAME(CropBox));

                if (o)
                {
                    r = pdf_to_rect(gctx, o);
                    prect.x0 = r.x0;
                    prect.y0 = r.y0;
                }
                o = pdf_dict_get_inheritable(gctx, tpageref, PDF_NAME(MediaBox));
                
                if (o)
                {
                    r = pdf_to_rect(gctx, o);
                    prect.x1 = r.x1;
                    prect.y1 = r.y1;
                }
                
                float W = rrect.x1 - rrect.x0;
                float H = rrect.y1 - rrect.y0;
                float fw = W / (cropbox.x1 - cropbox.x0);
                float fh = H / (cropbox.y1 - cropbox.y0);
                if ((fw < fh) && keep_proportion)     // zoom factors in matrix
                    fh = fw;
                float X = rrect.x0 + prect.x0 - fw*cropbox.x0;
                float Y = prect.y1 - (rrect.y1 + prect.y0 + fh*cropbox.y0);
                mat.a = fw;
                mat.d = fh;
                mat.e = X;
                mat.f = Y;

                //-------------------------------------------------------------
                // create referencing XObject (controls actual display)
                //-------------------------------------------------------------
                // fill reference to xobj1 into its /Resources
                //-------------------------------------------------------------
                pdf_obj *subres1 = pdf_new_dict(gctx, pdfout, 5);
                pdf_dict_puts(gctx, subres1, "fullpage", xobj1);
                pdf_obj *subres  = pdf_new_dict(gctx, pdfout, 5);
                pdf_dict_put_drop(gctx, subres, PDF_NAME(XObject), subres1);

                res = fz_new_buffer(gctx, 50);
                fz_append_string(gctx, res, "/fullpage Do");

                xobj2 = pdf_new_xobject(gctx, pdfout, cropbox, mat, subres, res);

                pdf_drop_obj(gctx, subres);
                fz_drop_buffer(gctx, res);

                //-------------------------------------------------------------
                // update target page:
                //-------------------------------------------------------------
                // 1. resources object
                //-------------------------------------------------------------
                resources = pdf_dict_get(gctx, tpageref, PDF_NAME(Resources));
                subres = pdf_dict_get(gctx, resources, PDF_NAME(XObject));
                if (!subres)           // has no XObject dict yet: create one
                {
                    subres = pdf_new_dict(gctx, pdfout, 10);
                    pdf_dict_putl(gctx, tpageref, subres, PDF_NAME(Resources), PDF_NAME(XObject), NULL);
                }

                pdf_dict_puts(gctx, subres, _imgname, xobj2);

                //-------------------------------------------------------------
                // 2. contents object
                //-------------------------------------------------------------
                nres = fz_new_buffer(gctx, 50);       // buffer for Do-command
                fz_append_string(gctx, nres, " q /");    // Do-command
                fz_append_string(gctx, nres, _imgname);
                fz_append_string(gctx, nres, " Do Q ");

                JM_insert_contents(gctx, pdfout, tpageref, nres, overlay);
                fz_drop_buffer(gctx, nres);
            }
            fz_catch(gctx) return NULL;
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *fz_page_s_insertImage(struct fz_page_s *self,PyObject *rect,char const *filename,struct fz_pixmap_s *pixmap,PyObject *stream,int overlay,char *_imgname){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_document *pdf;
            fz_pixmap *pm = NULL;
            fz_pixmap *pix = NULL;
            fz_image *mask = NULL;
            fz_separations *seps = NULL;
            pdf_obj *resources, *subres, *ref;
            fz_buffer *res = NULL, *nres = NULL,  *imgbuf = NULL;

            char *streamdata = NULL;
            size_t streamlen = JM_CharFromBytesOrArray(stream, &streamdata);

            const char *template = "\nq %g 0 0 %g %g %g cm /%s Do Q ";
            char *cont = NULL;
            Py_ssize_t name_len = 0;
            fz_image *zimg = NULL, *image = NULL;
            int parm_count = 0;
            if (filename)      parm_count++;
            if (pixmap)        parm_count++;
            if (streamlen > 0) parm_count++;
            fz_try(gctx)
            {
                assert_PDF(page);
                if (parm_count != 1)
                    THROWMSG("need exactly one of filename, pixmap or stream");

                fz_rect rect_py = JM_rect_from_py(rect);
                if (fz_is_empty_rect(rect_py) || fz_is_infinite_rect(rect_py))
                    THROWMSG("rect must be finite and not empty");

                // calculate coordinates for image matrix
                fz_rect prect = fz_bound_page(gctx, self); // page rectangle
                
                fz_rect r = fz_empty_rect;           // modify where necessary
                pdf_obj *o = pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(CropBox));
                if (o)
                {   // set top-left of page rect to new values
                    r = pdf_to_rect(gctx, o);
                    prect.x0 = r.x0;
                    prect.y0 = r.y0;
                }
                o = pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(MediaBox));
                if (o)
                {   // set bottom-right to new values
                    r = pdf_to_rect(gctx, o);
                    prect.x1 = r.x1;
                    prect.y1 = r.y1;
                }
                // adjust rect.x0, rect.y0 by CropBox start
                float X = rect_py.x0 + prect.x0;
                float Y = prect.y1 - (rect_py.y1 + prect.y0);
                float W = rect_py.x1 - rect_py.x0;
                float H = rect_py.y1 - rect_py.y0;

                pdf = page->doc;

                // get objects "Resources" & "XObject"
                resources = pdf_dict_get(gctx, page->obj, PDF_NAME(Resources));
                subres = pdf_dict_get(gctx, resources, PDF_NAME(XObject));
                if (!subres)           // has no XObject yet, create one
                {
                    subres = pdf_new_dict(gctx, pdf, 10);
                    pdf_dict_putl_drop(gctx, page->obj, subres, PDF_NAME(Resources), PDF_NAME(XObject), NULL);
                }

                // create the image
                if (filename || streamlen > 0)
                {
                    if (filename)
                        image = fz_new_image_from_file(gctx, filename);
                    else
                    {
                        imgbuf = fz_new_buffer_from_shared_data(gctx,
                                                   streamdata, streamlen);
                        image = fz_new_image_from_buffer(gctx, imgbuf);
                    }
                    pix = fz_get_pixmap_from_image(gctx, image, NULL, NULL, 0, 0);
                    if (pix->alpha == 1)
                    {   // have alpha, therefore create a mask
                        pm = fz_convert_pixmap(gctx, pix, NULL, NULL, NULL, NULL, 1);
                        pm->alpha = 0;
                        pm->colorspace = fz_keep_colorspace(gctx, fz_device_gray(gctx));
                        mask = fz_new_image_from_pixmap(gctx, pm, NULL);
                        zimg = fz_new_image_from_pixmap(gctx, pix, mask);
                        fz_drop_image(gctx, image);
                        image = zimg;
                        zimg = NULL;
                    }
                }
                if (pixmap)
                {
                    if (pixmap->alpha == 0)
                        image = fz_new_image_from_pixmap(gctx, pixmap, NULL);
                    else
                    {   // pixmap has alpha, therefore create a mask
                        pm = fz_convert_pixmap(gctx, pixmap, NULL, NULL, NULL, NULL, 1);
                        pm->alpha = 0;
                        pm->colorspace = fz_keep_colorspace(gctx, fz_device_gray(gctx));
                        mask = fz_new_image_from_pixmap(gctx, pm, NULL);
                        image = fz_new_image_from_pixmap(gctx, pixmap, mask);
                    }
                }
                // put image in PDF
                ref = pdf_add_image(gctx, pdf, image, 0);
                pdf_dict_puts(gctx, subres, _imgname, ref);  // store ref-name

                // prep contents stream buffer with invoking command
                nres = fz_new_buffer(gctx, 50);
                fz_append_printf(gctx, nres, template, W, H, X, Y, _imgname);
                JM_insert_contents(gctx, pdf, page->obj, nres, overlay);
                fz_drop_buffer(gctx, nres);
            }
            fz_always(gctx)
            {
                fz_drop_image(gctx, image);
                fz_drop_image(gctx, mask);
                fz_drop_pixmap(gctx, pix);
                fz_drop_pixmap(gctx, pm);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return NONE;
        }
SWIGINTERN PyObject *fz_page_s__insertFont(struct fz_page_s *self,char *fontname,char *bfname,char *fontfile,PyObject *fontbuffer,int set_simple,int idx,int wmode,int serif,int encoding,int ordering){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_document *pdf;
            pdf_obj *resources, *fonts, *font_obj;
            fz_font *font;
            const char *data = NULL;
            int size, ixref = 0, index = 0, simple = 0;
            PyObject *value;
            PyObject *exto = NULL;
            fz_try(gctx)
            {
                assert_PDF(page);
                pdf = page->doc;
                // get the objects /Resources, /Resources/Font
                resources = pdf_dict_get(gctx, page->obj, PDF_NAME(Resources));
                fonts = pdf_dict_get(gctx, resources, PDF_NAME(Font));
                if (!fonts)       // page has no fonts yet
                {
                    fonts = pdf_new_dict(gctx, pdf, 10);
                    pdf_dict_putl_drop(gctx, page->obj, fonts, PDF_NAME(Resources), PDF_NAME(Font), NULL);
                }

                //-------------------------------------------------------------
                // check for CJK font
                //-------------------------------------------------------------
                if (ordering > -1) data = fz_lookup_cjk_font(gctx, ordering, &size, &index);
                if (data)
                {
                    font = fz_new_font_from_memory(gctx, NULL, data, size, index, 0);
                    font_obj = pdf_add_cjk_font(gctx, pdf, font, ordering, wmode, serif);
                    exto = Py_BuildValue("s", "n/a");
                    simple = 0;
                    goto weiter;
                }

                //-------------------------------------------------------------
                // check for PDF Base-14 font
                //-------------------------------------------------------------
                if (bfname) data = fz_lookup_base14_font(gctx, bfname, &size);
                if (data)
                {
                    font = fz_new_font_from_memory(gctx, bfname, data, size, 0, 0);
                    font_obj = pdf_add_simple_font(gctx, pdf, font, encoding);
                    exto = Py_BuildValue("s", "n/a");
                    simple = 1;
                    goto weiter;
                }

                if (fontfile)
                    font = fz_new_font_from_file(gctx, NULL, fontfile, idx, 0);
                else
                {
                    size = (int) JM_CharFromBytesOrArray(fontbuffer, &data);
                    if (!size) THROWMSG("one of fontfile, fontbuffer must be given");
                    font = fz_new_font_from_memory(gctx, NULL, data, size, idx, 0);
                }

                if (!set_simple)
                {
                    font_obj = pdf_add_cid_font(gctx, pdf, font);
                    simple = 0;
                }
                else
                {
                    font_obj = pdf_add_simple_font(gctx, pdf, font, encoding);
                    simple = 2;
                }

                weiter: ;
                ixref = pdf_to_num(gctx, font_obj);

                PyObject *name = Py_BuildValue("s", pdf_to_name(gctx,
                            pdf_dict_get(gctx, font_obj, PDF_NAME(BaseFont))));

                PyObject *subt = Py_BuildValue("s", pdf_to_name(gctx,
                            pdf_dict_get(gctx, font_obj, PDF_NAME(Subtype))));

                if (!exto)
                    exto = Py_BuildValue("s", fontextension(gctx, pdf, ixref));

                value = Py_BuildValue("[i, {s:O, s:O, s:O, s:O, s:i}]",
                                      ixref,
                                      "name", name,        // base font name
                                      "type", subt,        // subtype
                                      "ext", exto,         // file extension
                                      "simple", JM_BOOL(simple), // simple font?
                                      "ordering", ordering); // CJK font?
                Py_CLEAR(exto);
                Py_CLEAR(name);
                Py_CLEAR(subt);

                // resources and fonts objects will contain named reference to font
                pdf_dict_puts(gctx, fonts, fontname, font_obj);
                pdf_drop_obj(gctx, font_obj);
                fz_drop_font(gctx, font);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return value;
        }
SWIGINTERN PyObject *fz_page_s__getTransformation(struct fz_page_s *self){
            fz_matrix ctm = fz_identity;
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page) return JM_py_from_matrix(ctm);
            fz_try(gctx) pdf_page_transform(gctx, page, NULL, &ctm);
            fz_catch(gctx) {;}
            return JM_py_from_matrix(ctm);
        }
SWIGINTERN PyObject *fz_page_s__getContents(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            PyObject *list = NULL;
            pdf_obj *contents = NULL, *icont = NULL;
            int i, xref;
            fz_try(gctx)
            {
                assert_PDF(page);           // only works for PDF
                contents = pdf_dict_get(gctx, page->obj, PDF_NAME(Contents));
                list = PyList_New(0);       // init an empty list
                if (pdf_is_array(gctx, contents))     // may be several
                {   for (i=0; i < pdf_array_len(gctx, contents); i++)
                    {
                        icont = pdf_array_get(gctx, contents, i);
                        xref = pdf_to_num(gctx, icont);
                        PyList_Append(list,  Py_BuildValue("i", xref));
                    }
                }
                else if (contents)          // at most 1 object there
                {
                    xref = pdf_to_num(gctx, contents);
                    PyList_Append(list, Py_BuildValue("i", xref));
                }
            }
            fz_catch(gctx) return NULL;
            return list;
        }
SWIGINTERN PyObject *fz_page_s__setContents(struct fz_page_s *self,int xref){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_obj *contents = NULL;
            
            fz_try(gctx)
            {
                assert_PDF(page);           // only works for PDF

                if (!INRANGE(xref, 1, pdf_xref_len(gctx, page->doc) - 1))
                    THROWMSG("xref out of range");

                contents = pdf_new_indirect(gctx, page->doc, xref, 0);
                if (!pdf_is_stream(gctx, contents))
                    THROWMSG("xref is not a stream");

                pdf_dict_put_drop(gctx, page->obj, PDF_NAME(Contents), contents);
            }
            fz_catch(gctx) return NULL;
            page->doc->dirty = 1;
            return NONE;
        }
SWIGINTERN void delete_fz_pixmap_s(struct fz_pixmap_s *self){
            DEBUGMSG1("pixmap");
            fz_drop_pixmap(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_0(struct fz_colorspace_s *cs,PyObject *bbox,int alpha){
            fz_pixmap *pm = NULL;
            fz_separations *seps = NULL;
            fz_try(gctx)
                pm = fz_new_pixmap_with_bbox(gctx, cs, JM_irect_from_py(bbox), seps, alpha);
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_1(struct fz_colorspace_s *cs,struct fz_pixmap_s *spix){
            fz_pixmap *pm = NULL;
            fz_try(gctx)
            {
                if (!fz_pixmap_colorspace(gctx, spix))
                    THROWMSG("cannot copy pixmap with NULL colorspace");
                pm = fz_convert_pixmap(gctx, spix, cs, NULL, NULL, NULL, 1);
            }
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_2(struct fz_pixmap_s *spix,float w,float h,PyObject *clip){
            fz_pixmap *pm = NULL;
            fz_try(gctx)
            {
                fz_irect bbox = JM_irect_from_py(clip);
                if (!fz_is_infinite_irect(bbox))
                {
                    pm = fz_scale_pixmap(gctx, spix, spix->x, spix->y, w, h, &bbox);
                }
                else 
                    pm = fz_scale_pixmap(gctx, spix, spix->x, spix->y, w, h, NULL);
            }
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_3(struct fz_pixmap_s *spix,int alpha){
            fz_pixmap *pm = NULL;
            int n, w, h, i;
            fz_separations *seps = NULL;
            fz_try(gctx)
            {
                if (!INRANGE(alpha, 0, 1))
                    THROWMSG("illegal alpha value");
                fz_colorspace *cs = fz_pixmap_colorspace(gctx, spix);
                if (!cs && !alpha)
                    THROWMSG("cannot drop alpha for 'NULL' colorspace");
                n = fz_pixmap_colorants(gctx, spix);
                w = fz_pixmap_width(gctx, spix);
                h = fz_pixmap_height(gctx, spix);
                pm = fz_new_pixmap(gctx, cs, w, h, seps, alpha);
                pm->x = spix->x;
                pm->y = spix->y;
                pm->xres = spix->xres;
                pm->yres = spix->yres;

                // copy samples data ------------------------------------------
                unsigned char *sptr = spix->samples;
                unsigned char *tptr = pm->samples;
                if (spix->alpha == pm->alpha)    // identical samples ---------
                    memcpy(tptr, sptr, w * h * (n + alpha));
                else
                {
                    for (i = 0; i < w * h; i++)
                    {
                        memcpy(tptr, sptr, n);
                        tptr += n;
                        if (pm->alpha)
                        {
                            tptr[0] = 255;
                            tptr++;
                        }
                        sptr += n + spix->alpha;
                    }
                }
            }
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_4(struct fz_colorspace_s *cs,int w,int h,PyObject *samples,int alpha){
            char *data = NULL;
            int n = fz_colorspace_n(gctx, cs);
            int stride = (n + alpha)*w;
            fz_separations *seps = NULL;
            fz_pixmap *pm = NULL;
            size_t size = JM_CharFromBytesOrArray(samples, &data);
            fz_try(gctx)
            {
                if (size < 1) THROWMSG("invalid arg type samples");
                if (stride * h != size) THROWMSG("invalid arg len samples");
                pm = fz_new_pixmap_with_data(gctx, cs, w, h, seps, alpha, stride, data);
            }
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_5(char *filename){
            fz_image *img = NULL;
            fz_pixmap *pm = NULL;
            fz_try(gctx) {
                if (!filename) THROWMSG("invalid argument type");
                img = fz_new_image_from_file(gctx, filename);
                pm = fz_get_pixmap_from_image(gctx, img, NULL, NULL, NULL, NULL);
            }
            fz_always(gctx) fz_drop_image(gctx, img);
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_6(PyObject *imagedata){
            size_t size = 0;
            char *streamdata;
            fz_buffer *data = NULL;
            fz_image *img = NULL;
            fz_pixmap *pm = NULL;
            fz_try(gctx)
            {
                size = JM_CharFromBytesOrArray(imagedata, &streamdata);
                if (size < 1) THROWMSG("invalid argument type");
                data = fz_new_buffer_from_shared_data(gctx,
                              streamdata, size);
                img = fz_new_image_from_buffer(gctx, data);
                pm = fz_get_pixmap_from_image(gctx, img, NULL, NULL, NULL, NULL);
            }
            fz_always(gctx)
            {
                fz_drop_image(gctx, img);
            }
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_7(struct fz_document_s *doc,int xref){
            fz_image *img = NULL;
            fz_pixmap *pix = NULL;
            pdf_obj *ref = NULL;
            pdf_obj *type;
            pdf_document *pdf = pdf_specifics(gctx, doc);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                ref = pdf_new_indirect(gctx, pdf, xref, 0);
                type = pdf_dict_get(gctx, ref, PDF_NAME(Subtype));
                if (!pdf_name_eq(gctx, type, PDF_NAME(Image)))
                    THROWMSG("xref not an image");
                img = pdf_load_image(gctx, pdf, ref);
                pix = fz_get_pixmap_from_image(gctx, img, NULL, NULL, NULL, NULL);
            }
            fz_always(gctx)
            {
                fz_drop_image(gctx, img);
                pdf_drop_obj(gctx, ref);
            }
            fz_catch(gctx)
            {
                fz_drop_pixmap(gctx, pix);
                return NULL;
            }
            return pix;
        }
SWIGINTERN void fz_pixmap_s_shrink(struct fz_pixmap_s *self,int factor){
            if (factor < 1)
            {
                JM_Warning("ignoring shrink factor < 1");
                return;
            }
            fz_subsample_pixmap(gctx, self, factor);
        }
SWIGINTERN void fz_pixmap_s_gammaWith(struct fz_pixmap_s *self,float gamma){
            if (!fz_pixmap_colorspace(gctx, self))
            {
                JM_Warning("colorspace invalid for function");
                return;
            }
            fz_gamma_pixmap(gctx, self, gamma);
        }
SWIGINTERN void fz_pixmap_s_tintWith(struct fz_pixmap_s *self,int red,int green,int blue){
            fz_tint_pixmap(gctx, self, red, green, blue);
        }
SWIGINTERN void fz_pixmap_s_clearWith__SWIG_0(struct fz_pixmap_s *self){
            fz_clear_pixmap(gctx, self);
        }
SWIGINTERN void fz_pixmap_s_clearWith__SWIG_1(struct fz_pixmap_s *self,int value){
            fz_clear_pixmap_with_value(gctx, self, value);
        }
SWIGINTERN void fz_pixmap_s_clearWith__SWIG_2(struct fz_pixmap_s *self,int value,PyObject *bbox){
            fz_clear_pixmap_rect_with_value(gctx, self, value, JM_irect_from_py(bbox));
        }
SWIGINTERN PyObject *fz_pixmap_s_copyPixmap(struct fz_pixmap_s *self,struct fz_pixmap_s *src,PyObject *bbox){
            fz_try(gctx)
            {
                if (!fz_pixmap_colorspace(gctx, src))
                    THROWMSG("cannot copy pixmap with NULL colorspace");
                fz_copy_pixmap_rect(gctx, self, src, JM_irect_from_py(bbox), NULL);
            }
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_pixmap_s_setAlpha(struct fz_pixmap_s *self,PyObject *alphavalues){
            fz_try(gctx)
            {
                if (self->alpha == 0) THROWMSG("pixmap has no alpha");
                int n = fz_pixmap_colorants(gctx, self);
                int w = fz_pixmap_width(gctx, self);
                int h = fz_pixmap_height(gctx, self);
                int balen = w * h * (n+1);
                unsigned char *data = NULL;
                int data_len = 0;
                if (alphavalues)
                {
                    data_len = (int) JM_CharFromBytesOrArray(alphavalues, &data);
                    if (data_len && data_len < w * h)
                        THROWMSG("not enough alpha values");
                }
                int i = 0, k = 0;
                while (i < balen)
                {
                    if (data_len) self->samples[i+n] = data[k];
                    else          self->samples[i+n] = 255;
                    i += n+1;
                    k += 1;
                }
            }
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_pixmap_s__getImageData(struct fz_pixmap_s *self,int format){
            fz_output *out = NULL;
            fz_buffer *res = NULL;
            // the following will be returned:
            PyObject *barray = NULL;
            fz_try(gctx)
            {
                size_t size = fz_pixmap_stride(gctx, self) * self->h;
                res = fz_new_buffer(gctx, size);
                out = fz_new_output_with_buffer(gctx, res);
                out->seek = JM_SeekDummy;        // ignore seek calls
                switch(format)
                {
                    case(1):
                        fz_write_pixmap_as_png(gctx, out, self);
                        break;
                    case(2):
                        fz_write_pixmap_as_pnm(gctx, out, self);
                        break;
                    case(3):
                        fz_write_pixmap_as_pam(gctx, out, self);
                        break;
                    case(4):
                        fz_write_pixmap_as_tga(gctx, out, self);
                        break;
                    case(5):           // Adobe Photoshop Document
                        fz_write_pixmap_as_psd(gctx, out, self);
                        break;
                    case(6):           // Postscript format
                        fz_write_pixmap_as_ps(gctx, out, self);
                        break;
                    default:
                        fz_write_pixmap_as_png(gctx, out, self);
                        break;
                }
                barray = JM_BinFromBuffer(gctx, res);
            }
            fz_always(gctx)
            {
                fz_drop_output(gctx, out);
                fz_drop_buffer(gctx, res);
            }

            fz_catch(gctx)
            {
                return NULL;
            }
            return barray;
        }
SWIGINTERN PyObject *fz_pixmap_s__writeIMG(struct fz_pixmap_s *self,char *filename,int format){
            fz_try(gctx) {
                switch(format)
                {
                    case(1):
                        fz_save_pixmap_as_png(gctx, self, filename);
                        break;
                    case(2):
                        fz_save_pixmap_as_pnm(gctx, self, filename);
                        break;
                    case(3):
                        fz_save_pixmap_as_pam(gctx, self, filename);
                        break;
                    case(4):
                        fz_save_pixmap_as_tga(gctx, self, filename);
                        break;
                    case(5): // Adobe Photoshop Document
                        fz_save_pixmap_as_psd(gctx, self, filename);
                        break;
                    case(6): // Postscript
                        fz_save_pixmap_as_ps(gctx, self, filename, 0);
                        break;
                    default:
                        fz_save_pixmap_as_png(gctx, self, filename);
                        break;
                }
            }
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN void fz_pixmap_s_invertIRect(struct fz_pixmap_s *self,PyObject *irect){
            if (!fz_pixmap_colorspace(gctx, self))
                {
                    JM_Warning("ignored for stencil pixmap");
                    return;
                }

            fz_irect r = JM_irect_from_py(irect);
            if (!fz_is_infinite_irect(r))
                fz_invert_pixmap_rect(gctx, self, r);
            else
                fz_invert_pixmap(gctx, self);
        }
SWIGINTERN PyObject *fz_pixmap_s_pixel(struct fz_pixmap_s *self,int x,int y){
            PyObject *p = NULL;
            fz_try(gctx)
            {
                if (!INRANGE(x, 0, self->w - 1) || !INRANGE(y, 0, self->h - 1))
                    THROWMSG("coordinates outside image");
                int n = self->n;
                int stride = fz_pixmap_stride(gctx, self);
                int j, i = stride * y + n * x;
                p = PyList_New(n);
                for (j=0; j < n; j++)
                {
                    PyList_SetItem(p, j, Py_BuildValue("i", self->samples[i + j]));
                }
            }
            fz_catch(gctx) return NULL;
            return p;
        }
SWIGINTERN PyObject *fz_pixmap_s_setPixel(struct fz_pixmap_s *self,int x,int y,PyObject *value){
            fz_try(gctx)
            {
                if (!INRANGE(x, 0, self->w - 1) || !INRANGE(y, 0, self->h - 1))
                    THROWMSG("coordinates outside image");
                int n = self->n;
                if (!PySequence_Check(value) || PySequence_Size(value) != n)
                    THROWMSG("bad pixel value");
                int i, j;
                unsigned char c[5];
                for (j = 0; j < n; j++)
                {
                    i = (int) PyInt_AsLong(PySequence_ITEM(value, j));
                    if (!INRANGE(i, 0, 255)) THROWMSG("bad pixel component");
                    c[j] = (unsigned char) i;
                }
                int stride = fz_pixmap_stride(gctx, self);
                i = stride * y + n * x;
                for (j = 0; j < n; j++)
                {
                    self->samples[i + j] = c[j];
                }
            }
            fz_catch(gctx)
            {
                PyErr_Clear();
                return NULL;
            }
            return NONE;
        }
SWIGINTERN int fz_pixmap_s_stride(struct fz_pixmap_s *self){
            return fz_pixmap_stride(gctx, self);
        }
SWIGINTERN int fz_pixmap_s_alpha(struct fz_pixmap_s *self){
            return self->alpha;
        }
SWIGINTERN struct fz_colorspace_s *fz_pixmap_s_colorspace(struct fz_pixmap_s *self){
            return fz_pixmap_colorspace(gctx, self);
        }
SWIGINTERN PyObject *fz_pixmap_s_irect(struct fz_pixmap_s *self){
            return JM_py_from_irect(fz_pixmap_bbox(gctx, self));
        }
SWIGINTERN int fz_pixmap_s_size(struct fz_pixmap_s *self){
            return (int) fz_pixmap_size(gctx, self);
        }
SWIGINTERN PyObject *fz_pixmap_s_samples(struct fz_pixmap_s *self){
            return PyBytes_FromStringAndSize((const char *)self->samples, (Py_ssize_t) (self->w)*(self->h)*(self->n));
        }

    #define CS_RGB  1
    #define CS_GRAY 2
    #define CS_CMYK 3

SWIGINTERN void delete_fz_colorspace_s(struct fz_colorspace_s *self){
            DEBUGMSG1("colorspace");
            fz_drop_colorspace(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN struct fz_colorspace_s *new_fz_colorspace_s(int type){
            switch(type) {
                case 2:
                    return fz_device_gray(gctx);
                    break;
                case 3:
                    return fz_device_cmyk(gctx);
                    break;
                case 1:
                default:
                    return fz_device_rgb(gctx);
                    break;
            }
        }
SWIGINTERN PyObject *fz_colorspace_s_n(struct fz_colorspace_s *self){
            return Py_BuildValue("i", fz_colorspace_n(gctx, self));
        }
SWIGINTERN PyObject *fz_colorspace_s__name(struct fz_colorspace_s *self){
            return Py_BuildValue("s", fz_colorspace_name(gctx, self));
        }
SWIGINTERN struct DeviceWrapper *new_DeviceWrapper__SWIG_0(struct fz_pixmap_s *pm,PyObject *clip){
            struct DeviceWrapper *dw = NULL;
            fz_try(gctx) {
                dw = (struct DeviceWrapper *)calloc(1, sizeof(struct DeviceWrapper));
                fz_irect bbox = JM_irect_from_py(clip);
                if (fz_is_infinite_irect(bbox))
                    dw->device = fz_new_draw_device(gctx, fz_identity, pm);
                else
                    dw->device = fz_new_draw_device_with_bbox(gctx, fz_identity, pm, &bbox);
            }
            fz_catch(gctx) return NULL;
            return dw;
        }
SWIGINTERN struct DeviceWrapper *new_DeviceWrapper__SWIG_1(struct fz_display_list_s *dl){
            struct DeviceWrapper *dw = NULL;
            fz_try(gctx) {
                dw = (struct DeviceWrapper *)calloc(1, sizeof(struct DeviceWrapper));
                dw->device = fz_new_list_device(gctx, dl);
                dw->list = dl;
                fz_keep_display_list(gctx, dl);
            }
            fz_catch(gctx) return NULL;
            return dw;
        }
SWIGINTERN struct DeviceWrapper *new_DeviceWrapper__SWIG_2(struct fz_stext_page_s *tp,int flags){
            struct DeviceWrapper *dw = NULL;
            fz_try(gctx) {
                dw = (struct DeviceWrapper *)calloc(1, sizeof(struct DeviceWrapper));
                fz_stext_options opts;
                opts.flags = flags;
                dw->device = fz_new_stext_device(gctx, tp, &opts);
            }
            fz_catch(gctx) return NULL;
            return dw;
        }
SWIGINTERN void delete_DeviceWrapper(struct DeviceWrapper *self){
            fz_display_list *list = self->list;
            DEBUGMSG1("device");
            fz_close_device(gctx, self->device);
            fz_drop_device(gctx, self->device);
            DEBUGMSG2;
            if(list)
            {
                DEBUGMSG1("display list after device");
                fz_drop_display_list(gctx, list);
                DEBUGMSG2;
            }
        }
SWIGINTERN PyObject *fz_outline_s_uri(struct fz_outline_s *self){
            return Py_BuildValue("s", self->uri);
        }
SWIGINTERN PyObject *fz_outline_s_isExternal(struct fz_outline_s *self){
            if (!self->uri) Py_RETURN_FALSE;
            return JM_BOOL(fz_is_external_link(gctx, self->uri));
        }
SWIGINTERN void delete_fz_annot_s(struct fz_annot_s *self){
            DEBUGMSG1("annot");
            fz_drop_annot(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *fz_annot_s_rect(struct fz_annot_s *self){
            fz_rect r = fz_bound_annot(gctx, self);
            return JM_py_from_rect(r);
        }
SWIGINTERN PyObject *fz_annot_s_xref(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            int i = 0;
            if(annot) i = pdf_to_num(gctx, annot->obj);
            return Py_BuildValue("i", i);
        }
SWIGINTERN PyObject *fz_annot_s__getAP(struct fz_annot_s *self){
            PyObject *r = NONE;
            fz_buffer *res = NULL;
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;
            fz_try(gctx)
            {
                pdf_obj *ap = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                                              PDF_NAME(N), NULL);
                
                if (pdf_is_stream(gctx, ap))  res = pdf_load_stream(gctx, ap);
                if (res) r = JM_BinFromBuffer(gctx, res);
            }
            fz_always(gctx) fz_drop_buffer(gctx, res);
            fz_catch(gctx) return NONE;
            return r;
        }
SWIGINTERN PyObject *fz_annot_s__setAP(struct fz_annot_s *self,PyObject *ap,int rect){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx)
            {
                assert_PDF(annot);
                pdf_obj *apobj = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                                              PDF_NAME(N), NULL);
                if (!apobj) THROWMSG("annot has no /AP/N object");
                if (!pdf_is_stream(gctx, apobj))
                    THROWMSG("/AP/N object is no stream");
                char *c = NULL;
                size_t len = JM_CharFromBytesOrArray(ap, &c);
                if (!c) THROWMSG("invalid /AP stream argument");
                res = fz_new_buffer_from_copied_data(gctx, c, strlen(c));
                JM_update_stream(gctx, annot->page->doc, apobj, res);
                if (rect)
                {
                    fz_rect bbox = pdf_dict_get_rect(gctx, annot->obj, PDF_NAME(Rect));
                    pdf_dict_put_rect(gctx, apobj, PDF_NAME(BBox), bbox);
                    annot->ap = NULL;
                }
            }
            fz_always(gctx)
                fz_drop_buffer(gctx, res);
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN void fz_annot_s_setRect(struct fz_annot_s *self,PyObject *rect){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return;
            fz_try(gctx)
            {
                pdf_set_annot_rect(gctx, annot, JM_rect_from_py(rect));
            }
            fz_catch(gctx) {;}
            return;
        }
SWIGINTERN PyObject *fz_annot_s_vertices(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;                  // not a PDF!
            PyObject *res = NONE;
            pdf_obj *o;
            //----------------------------------------------------------------
            // The following objects occur in different annotation types.
            // So we are sure that o != NULL occurs at most once.
            // Every pair of floats is one point, that needs to be separately
            // transformed with the page transformation matrix.
            //----------------------------------------------------------------
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(Vertices));
            if (o) goto weiter;
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(L));
            if (o) goto weiter;
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(QuadPoints));
            if (o) goto weiter;
            o = pdf_dict_gets(gctx, annot->obj, "CL");
            if (o) goto weiter;
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(InkList));
            if (o) goto weiter;
            return res;

            weiter:;
            int i, n;
            fz_point point;             // point object to work with
            fz_matrix page_ctm;         // page transformation matrix
            pdf_page_transform(gctx, annot->page, NULL, &page_ctm);
            res = PyList_New(0);        // create Python list
            n = pdf_array_len(gctx, o);
            for (i = 0; i < n; i += 2)
            {
                point.x = pdf_to_real(gctx, pdf_array_get(gctx, o, i));
                point.y = pdf_to_real(gctx, pdf_array_get(gctx, o, i+1));
                point = fz_transform_point(point, page_ctm);
                PyList_Append(res, Py_BuildValue("ff", point.x, point.y));
            }

            return res;
        }
SWIGINTERN PyObject *fz_annot_s_colors(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;
            return JM_annot_colors(gctx, annot->obj);
        }
SWIGINTERN PyObject *fz_annot_s_update(struct fz_annot_s *self,float fontsize,PyObject *text_color,PyObject *border_color,PyObject *fill_color,int rotate){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;
            int type = pdf_annot_type(gctx, annot);
            fz_try(gctx)
            {
                pdf_dirty_annot(gctx, annot); // enforce MuPDF /AP formatting
                if (type == PDF_ANNOT_FREE_TEXT && rotate >= 0)
                    pdf_dict_put_int(gctx, annot->obj, PDF_NAME(Rotate), rotate);
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx)
            {
                PySys_WriteStderr("cannot update annot: '%s'\n", fz_caught_message(gctx));
                Py_RETURN_FALSE;
            }

            // check /AP object
            pdf_obj *ap = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                                        PDF_NAME(N), NULL);
            if (!ap)
            {
                PySys_WriteStderr("annot has no /AP onject!\n");
                Py_RETURN_FALSE;
            }

            // get opacity
            pdf_obj *ca = pdf_dict_get(gctx, annot->obj, PDF_NAME(CA));
            if (!ca)              // no opacity given
                Py_RETURN_TRUE;

            pdf_obj *alp0 = pdf_new_dict(gctx, annot->page->doc, 2);
            pdf_dict_put(gctx, alp0, PDF_NAME(CA), ca);
            pdf_dict_put(gctx, alp0, PDF_NAME(ca), ca);
            pdf_obj *extg = pdf_new_dict(gctx, annot->page->doc, 1);
            pdf_dict_puts_drop(gctx, extg, "Alp0", alp0);
            pdf_dict_putl_drop(gctx, ap, extg, PDF_NAME(Resources),
                               PDF_NAME(ExtGState), NULL);
            pdf_dict_putl_drop(gctx, annot->obj, ap, PDF_NAME(AP), PDF_NAME(N), NULL);
            annot->ap = NULL;

            Py_RETURN_TRUE;
        }
SWIGINTERN void fz_annot_s_setColors(struct fz_annot_s *self,PyObject *colors){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return;
            if (!PyDict_Check(colors)) return;
            if (pdf_annot_type(gctx, annot) == PDF_ANNOT_WIDGET)
            {
                JM_Warning("use 'updateWidget' to change form fields");
                return;
            }
            PyObject *ccol, *icol;
            ccol = PyDict_GetItemString(colors, "stroke");
            icol = PyDict_GetItemString(colors, "fill");
            int i, n;
            float col[4];
            n = 0;
            if (ccol)
                if (PySequence_Check(ccol))
                    n = (int) PySequence_Size(ccol);
            if (n>0)
            {
                for (i=0; i<n; i++)
                    col[i] = (float) PyFloat_AsDouble(PySequence_ITEM(ccol, i));
                fz_try(gctx)
                    pdf_set_annot_color(gctx, annot, n, col);
                fz_catch(gctx)
                    JM_Warning("cannot set stroke color for this annot type");
            }
            n = 0;
            if (icol)
                if (PySequence_Check(icol))
                    n = (int) PySequence_Size(icol);
            if (n>0)
            {
                if (!pdf_annot_has_interior_color(gctx, annot))
                {
                    JM_Warning("annot type has no fill color");
                    return;
                }
                for (i=0; i<n; i++)
                    col[i] = (float) PyFloat_AsDouble(PySequence_ITEM(icol, i));
                fz_try(gctx)
                    pdf_set_annot_interior_color(gctx, annot, n, col);
                fz_catch(gctx)
                    JM_Warning("cannot set fill color for this annot type");
            }
            return;
        }
SWIGINTERN PyObject *fz_annot_s_lineEnds(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;                   // no a PDF
            int i = pdf_annot_type(gctx, annot);
            // return nothing for invalid annot types
            if (!INRANGE(i, 2, 7)) return NONE;
            if (INRANGE(i, 4, 5)) return NONE;
            PyObject *res = Py_BuildValue("[ii]", 0, 0); // stanard
            pdf_obj *o = pdf_dict_gets(gctx, annot->obj, "LE");
            if (!o) return res;                       // no LE: empty dict
            char *lstart = NULL;
            char *lend = NULL;
            if (pdf_is_name(gctx, o)) lstart = (char *) pdf_to_name(gctx, o);
            else if (pdf_is_array(gctx, o))
                {
                lstart = (char *) pdf_to_name(gctx, pdf_array_get(gctx, o, 0));
                if (pdf_array_len(gctx, o) > 1)
                    lend   = (char *) pdf_to_name(gctx, pdf_array_get(gctx, o, 1));
                }
            PyList_SetItem(res, 0, Py_BuildValue("i", JM_le_value(gctx, lstart)));
            PyList_SetItem(res, 1, Py_BuildValue("i", JM_le_value(gctx, lend)));
            return res;
        }
SWIGINTERN void fz_annot_s_setLineEnds(struct fz_annot_s *self,int start,int end){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return;
            if (pdf_annot_has_line_ending_styles(gctx, annot))
                pdf_set_annot_line_ending_styles(gctx, annot, start, end);
            else
                JM_Warning("annot type has no line ends");
        }
SWIGINTERN PyObject *fz_annot_s_type(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;             // not a PDF
            int type = pdf_annot_type(gctx, annot);
            const char *c = pdf_string_from_annot_type(gctx, type);
            pdf_obj *o = pdf_dict_gets(gctx, annot->obj, "IT");
            if (!o || !pdf_is_name(gctx, o))
                return Py_BuildValue("is", type, c);         // no IT entry
            const char *it = pdf_to_name(gctx, o);
            return Py_BuildValue("iss", type, c, it);
        }
SWIGINTERN PyObject *fz_annot_s_opacity(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            double opy = -1.0f;
            if (annot)
            {
                pdf_obj *ca = pdf_dict_get(gctx, annot->obj, PDF_NAME(CA));
                if (pdf_is_number(gctx, ca))
                    opy = pdf_to_real(gctx, ca);
            }
            return Py_BuildValue("f", opy);
        }
SWIGINTERN void fz_annot_s_setOpacity(struct fz_annot_s *self,float opacity){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return;             // not a PDF
            if (INRANGE(opacity, 0.0f, 1.0f))
                pdf_set_annot_opacity(gctx, annot, opacity);
            else
                pdf_set_annot_opacity(gctx, annot, 1.0f);
        }
SWIGINTERN PyObject *fz_annot_s_widget_type(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            int wtype;
            if (!annot) return NONE;             // not a PDF

            wtype = pdf_field_type(gctx, pdf_get_bound_document(gctx, annot->obj), annot->obj);
            switch(wtype)
            {
                case(PDF_WIDGET_TYPE_PUSHBUTTON):
                    return Py_BuildValue("is", wtype, "PushButton");
                case(PDF_WIDGET_TYPE_CHECKBOX):
                    return Py_BuildValue("is", wtype, "CheckBox");
                case(PDF_WIDGET_TYPE_RADIOBUTTON):
                    return Py_BuildValue("is", wtype, "RadioButton");
                case(PDF_WIDGET_TYPE_TEXT):
                    return Py_BuildValue("is", wtype, "Text");
                case(PDF_WIDGET_TYPE_LISTBOX):
                    return Py_BuildValue("is", wtype, "ListBox");
                case(PDF_WIDGET_TYPE_COMBOBOX):
                    return Py_BuildValue("is", wtype, "ComboBox");
                case(PDF_WIDGET_TYPE_SIGNATURE):
                    return Py_BuildValue("is", wtype, "Signature");
                default:
                    return NONE;
            }
        }
SWIGINTERN PyObject *fz_annot_s_widget_value(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;             // not a PDF
            if (pdf_annot_type(gctx, annot) != PDF_ANNOT_WIDGET)
                return NONE;
            int wtype = pdf_field_type(gctx, pdf_get_bound_document(gctx, annot->obj), annot->obj);
            switch(wtype)
            {
                case(PDF_WIDGET_TYPE_PUSHBUTTON):
                    return JM_pushbtn_state(gctx, annot);
                case(PDF_WIDGET_TYPE_CHECKBOX):
                    return JM_checkbox_state(gctx, annot);
                case(PDF_WIDGET_TYPE_RADIOBUTTON):
                    return JM_radiobtn_state(gctx, annot);
                case(PDF_WIDGET_TYPE_TEXT):
                    return JM_text_value(gctx, annot);
                case(PDF_WIDGET_TYPE_LISTBOX):
                    return JM_listbox_value(gctx, annot);
                case(PDF_WIDGET_TYPE_COMBOBOX):
                    return JM_combobox_value(gctx, annot);
                case(PDF_WIDGET_TYPE_SIGNATURE):
                    return JM_signature_value(gctx, annot);
                default:
                    return NONE;
            }
        }
SWIGINTERN PyObject *fz_annot_s_widget_name(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;
            if (pdf_annot_type(gctx, annot) != PDF_ANNOT_WIDGET)
                return NONE;
            return PyString_FromString(pdf_field_name(gctx,
                                       pdf_get_bound_document(gctx, annot->obj),
                                       annot->obj));
        }
SWIGINTERN PyObject *fz_annot_s_widget_choices(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;
            if (pdf_annot_type(gctx, annot) != PDF_ANNOT_WIDGET)
                return NONE;
            return JM_choice_options(gctx, annot);
        }
SWIGINTERN PyObject *fz_annot_s_fileInfo(struct fz_annot_s *self){
            PyObject *res = PyDict_New();             // create Python dict
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            char *filename = NULL;
            char *desc = NULL;
            int length = -1, size = -1;
            pdf_obj *stream = NULL, *o = NULL, *fs = NULL;

            fz_try(gctx)
            {
                assert_PDF(annot);
                int type = (int) pdf_annot_type(gctx, annot);
                if (type != 16)
                    THROWMSG("not a file attachment annot");
                stream = pdf_dict_getl(gctx, annot->obj, PDF_NAME(FS),
                                   PDF_NAME(EF), PDF_NAME(F), NULL);
                if (!stream) THROWMSG("bad PDF: file entry not found");
            }
            fz_catch(gctx) return NULL;

            fs = pdf_dict_get(gctx, annot->obj, PDF_NAME(FS));

            o = pdf_dict_get(gctx, fs, PDF_NAME(UF));
            if (o) filename = (char *) pdf_to_text_string(gctx, o);
            else
            {
                o = pdf_dict_get(gctx, fs, PDF_NAME(F));
                if (o) filename = (char *) pdf_to_text_string(gctx, o);
            }

            o = pdf_dict_get(gctx, fs, PDF_NAME(Desc));
            if (o) desc = (char *) pdf_to_text_string(gctx, o);

            o = pdf_dict_get(gctx, stream, PDF_NAME(Length));
            if (o) length = pdf_to_int(gctx, o);

            o = pdf_dict_getl(gctx, stream, PDF_NAME(Params),
                                PDF_NAME(Size), NULL);
            if (o) size = pdf_to_int(gctx, o);

            PyDict_SetItemString(res, "filename", JM_UNICODE(filename));
            PyDict_SetItemString(res, "desc", JM_UNICODE(desc));
            PyDict_SetItemString(res, "length", Py_BuildValue("i", length));
            PyDict_SetItemString(res, "size", Py_BuildValue("i", size));
            return res;
        }
SWIGINTERN PyObject *fz_annot_s_fileGet(struct fz_annot_s *self){
            PyObject *res = NULL;
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            pdf_obj *stream = NULL;
            fz_buffer *buf = NULL;
            fz_var(buf);
            fz_try(gctx)
            {
                assert_PDF(annot);
                int type = (int) pdf_annot_type(gctx, annot);
                if (type != 16)
                    THROWMSG("not a file attachment annot");
                stream = pdf_dict_getl(gctx, annot->obj, PDF_NAME(FS),
                                   PDF_NAME(EF), PDF_NAME(F), NULL);
                if (!stream) THROWMSG("bad PDF: file entry not found");
                buf = pdf_load_stream(gctx, stream);
                res = JM_BinFromBuffer(gctx, buf);
            }
            fz_always(gctx) fz_drop_buffer(gctx, buf);
            fz_catch(gctx) return NULL;
            return res;
        }
SWIGINTERN PyObject *fz_annot_s_fileUpd(struct fz_annot_s *self,PyObject *buffer,char *filename,char *ufilename,char *desc){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            pdf_document *pdf = NULL;       // to be filled in
            char *data = NULL;              // for new file content
            fz_buffer *res = NULL;          // for compressed content
            pdf_obj *stream = NULL, *fs = NULL;
            int64_t size = 0;
            fz_try(gctx)
            {
                assert_PDF(annot);          // must be a PDF
                pdf = annot->page->doc;     // this is the PDF
                int type = (int) pdf_annot_type(gctx, annot);
                if (type != 16)
                    THROWMSG("not a file attachment annot");
                stream = pdf_dict_getl(gctx, annot->obj, PDF_NAME(FS),
                                   PDF_NAME(EF), PDF_NAME(F), NULL);
                // the object for file content
                if (!stream) THROWMSG("bad PDF: file entry not found");
                
                fs = pdf_dict_get(gctx, annot->obj, PDF_NAME(FS));

                // file content is ignored if not bytes / bytearray
                size = (int64_t) JM_CharFromBytesOrArray(buffer, &data);
                if (size > 0)
                {
                    pdf_obj *s = pdf_new_int(gctx, size);
                    pdf_dict_put(gctx, stream, PDF_NAME(Filter),
                                 PDF_NAME(FlateDecode));

                    pdf_dict_putl_drop(gctx, stream, s,
                                       PDF_NAME(Params), PDF_NAME(Size), NULL);
                    res = JM_deflatebuf(gctx, data, size);
                    pdf_update_stream(gctx, pdf, stream, res, 1);
                }

                if (filename)               // new filename given
                {
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(F), filename);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(F), filename);
                }

                if (ufilename)
                {
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(UF), filename);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(UF), filename);
                }

                if (desc)                   // new description given
                {
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(Desc), desc);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(Desc), desc);
                }
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return NONE;
        }
SWIGINTERN PyObject *fz_annot_s_info(struct fz_annot_s *self){
            PyObject *res = PyDict_New();
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return res;                   // not a PDF
            pdf_obj *o;
            char *c;
            c = (char *) pdf_annot_contents(gctx, annot);
            PyDict_SetItemString(res, "content", JM_UNICODE(c));

            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(Name));
            c = (char *) pdf_to_name(gctx, o);
            PyDict_SetItemString(res, "name", JM_UNICODE(c));

            // Title, author
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(T));
            c = (char *) pdf_to_text_string(gctx, o);
            PyDict_SetItemString(res, "title", JM_UNICODE(c));

            // CreationDate
            o = pdf_dict_gets(gctx, annot->obj, "CreationDate");
            c = (char *) pdf_to_text_string(gctx, o);
            PyDict_SetItemString(res, "creationDate", JM_UNICODE(c));

            // ModDate
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(M));
            c = (char *) pdf_to_text_string(gctx, o);
            PyDict_SetItemString(res, "modDate", JM_UNICODE(c));

            // Subj
            o = pdf_dict_gets(gctx, annot->obj, "Subj");
            c = (char *) pdf_to_text_string(gctx, o);
            PyDict_SetItemString(res, "subject", JM_UNICODE(c));

            return res;
        }
SWIGINTERN PyObject *fz_annot_s_setInfo(struct fz_annot_s *self,PyObject *info){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            char *uc = NULL;

            // use this to indicate a 'markup' annot type
            int is_markup = pdf_annot_has_author(gctx, annot);
            fz_var(is_markup);
            fz_var(annot);
            fz_try(gctx)
            {
                assert_PDF(annot);
                if (!PyDict_Check(info))
                    THROWMSG("info not a dict");

                // contents
                uc = JM_Python_str_AsChar(PyDict_GetItemString(info, "content"));
                if (uc)
                {
                    pdf_set_annot_contents(gctx, annot, uc);
                    JM_Python_str_DelForPy3(uc);
                }

                if (is_markup)
                {
                    // title (= author)
                    uc = JM_Python_str_AsChar(PyDict_GetItemString(info, "title"));
                    if (uc)
                    {
                        pdf_set_annot_author(gctx, annot, uc);
                        JM_Python_str_DelForPy3(uc);
                    }

                    // creation date
                    uc = JM_Python_str_AsChar(PyDict_GetItemString(info,
                                              "creationDate"));
                    if (uc)
                    {
                        pdf_dict_put_text_string(gctx, annot->obj,
                                                 PDF_NAME(CreationDate), uc);
                        JM_Python_str_DelForPy3(uc);
                    }

                    // mod date
                    uc = JM_Python_str_AsChar(PyDict_GetItemString(info, "modDate"));
                    if (uc)
                    {
                        pdf_dict_put_text_string(gctx, annot->obj,
                                                 PDF_NAME(M), uc);
                        JM_Python_str_DelForPy3(uc);
                    }

                    // subject
                    uc = JM_Python_str_AsChar(PyDict_GetItemString(info, "subject"));
                    if (uc)
                    {
                        pdf_dict_puts_drop(gctx, annot->obj, "Subj",
                                           pdf_new_text_string(gctx, uc));
                        JM_Python_str_DelForPy3(uc);
                    }
                }
            }
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_annot_s_border(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;                   // not a PDF
            return JM_annot_border(gctx, annot->obj);
        }
SWIGINTERN PyObject *fz_annot_s_setBorder(struct fz_annot_s *self,PyObject *border){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (!annot) return NONE;                   // not a PDF
            return JM_annot_set_border(gctx, border, annot->page->doc, annot->obj);
        }
SWIGINTERN int fz_annot_s_flags(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (annot) return pdf_annot_flags(gctx, annot);
            return -1;
        }
SWIGINTERN PyObject *fz_annot_s__cleanContents(struct fz_annot_s *self){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            fz_try(gctx)
            {
                assert_PDF(annot);
                pdf_clean_annot_contents(gctx, annot->page->doc, annot,
                                         NULL, NULL, NULL, 1, 0);
            }
            fz_catch(gctx) return NULL;
            pdf_dirty_annot(gctx, annot);
            return NONE;
        }
SWIGINTERN void fz_annot_s_setFlags(struct fz_annot_s *self,int flags){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            if (annot)
            {
                pdf_set_annot_flags(gctx, annot, flags);
                pdf_dirty_annot(gctx, annot);
            }
        }
SWIGINTERN struct fz_annot_s *fz_annot_s_next(struct fz_annot_s *self){
            fz_annot *annot = fz_next_annot(gctx, self);
            if (annot)
                fz_keep_annot(gctx, annot);
            return annot;
        }
SWIGINTERN struct fz_pixmap_s *fz_annot_s_getPixmap(struct fz_annot_s *self,PyObject *matrix,struct fz_colorspace_s *colorspace,int alpha){
            fz_matrix ctm = JM_matrix_from_py(matrix);
            struct fz_colorspace_s *cs = fz_device_rgb(gctx);
            fz_pixmap *pix = NULL;
            if (colorspace) cs = colorspace;

            fz_try(gctx)
                pix = fz_new_pixmap_from_annot(gctx, self, ctm, cs, alpha);
            fz_catch(gctx) return NULL;
            return pix;
        }
SWIGINTERN PyObject *fz_annot_s__updateWidget(struct fz_annot_s *self,PyObject *Widget){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            pdf_document *pdf = pdf_get_bound_document(gctx, annot->obj);
            fz_try(gctx)
            {
                int field_type = (int) PyInt_AsLong(PyObject_GetAttrString(Widget,
                                                    "field_type"));
                JM_set_widget_properties(gctx, annot, Widget, field_type);
            }
            fz_always(gctx)
            {
                JM_PyErr_Clear;
            }
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_annot_s__getWidget(struct fz_annot_s *self,PyObject *Widget){
            pdf_annot *annot = pdf_annot_from_fz_annot(gctx, self);
            pdf_document *pdf = annot->page->doc;
            pdf_widget *tw = (pdf_widget *) annot;
            Py_ssize_t i = 0, n = 0;
            fz_try(gctx)
            {
                char *border_style = pdf_field_border_style(gctx, pdf, annot->obj);
                PyObject_SetAttrString(Widget, "border_style",
                                       Py_BuildValue("s", border_style));

                float border_width = pdf_to_real(gctx, pdf_dict_getl(gctx, annot->obj,
                                      PDF_NAME(BS), PDF_NAME(W), NULL));
                if (border_width == 0.0f) border_width = 1.0f;
                PyObject_SetAttrString(Widget, "border_width",
                                       Py_BuildValue("f", border_width));

                pdf_obj *dashes = pdf_dict_getl(gctx, annot->obj,
                                      PDF_NAME(BS), PDF_NAME(D), NULL);
                if (pdf_is_array(gctx, dashes))
                {
                    n = (Py_ssize_t) pdf_array_len(gctx, dashes);
                    PyObject *d = PyList_New(n);
                    for (i = 0; i < n; i++)
                        PyList_SetItem(d, i, Py_BuildValue("i", pdf_to_int(gctx,
                                      pdf_array_get(gctx, dashes, (int) i))));

                    PyObject_SetAttrString(Widget, "border_dashes", d);
                    Py_CLEAR(d);
                }

                int text_maxlen = pdf_to_int(gctx, pdf_dict_get_inheritable(gctx, annot->obj, PDF_NAME(MaxLen)));
                PyObject_SetAttrString(Widget, "text_maxlen",
                                       Py_BuildValue("i", text_maxlen));

                // entry ignored for new / updated widgets
                int text_type = pdf_text_widget_content_type(gctx, pdf, tw);
                PyObject_SetAttrString(Widget, "text_type",
                                       Py_BuildValue("i", text_type));

                pdf_obj *bgcol = pdf_dict_getl(gctx, annot->obj,
                                               PDF_NAME(MK), PDF_NAME(BG), NULL);
                if (pdf_is_array(gctx, bgcol))
                {
                    n = (Py_ssize_t) pdf_array_len(gctx, bgcol);
                    PyObject *col = PyList_New(n);
                    for (i = 0; i < n; i++)
                        PyList_SetItem(col, i, Py_BuildValue("f",
                        pdf_to_real(gctx, pdf_array_get(gctx, bgcol, (int) i))));

                    PyObject_SetAttrString(Widget, "fill_color", col);
                    Py_CLEAR(col);
                }

                pdf_obj *bccol = pdf_dict_getl(gctx, annot->obj, PDF_NAME(MK), PDF_NAME(BC), NULL);

                if (pdf_is_array(gctx, bccol))
                {
                    n = (Py_ssize_t) pdf_array_len(gctx, bccol);
                    PyObject *col = PyList_New(n);
                    for (i = 0; i < n; i++)
                        PyList_SetItem(col, i, Py_BuildValue("f",
                        pdf_to_real(gctx, pdf_array_get(gctx, bccol, (int) i))));

                    PyObject_SetAttrString(Widget, "border_color", col);
                    Py_CLEAR(col);
                }

                char *da = pdf_to_str_buf(gctx, pdf_dict_get_inheritable(gctx,
                                                annot->obj, PDF_NAME(DA)));
                PyObject_SetAttrString(Widget, "_text_da", Py_BuildValue("s", da));

                pdf_obj *ca = pdf_dict_getl(gctx, annot->obj,
                                            PDF_NAME(MK), PDF_NAME(CA), NULL);
                if (ca)
                    PyObject_SetAttrString(Widget, "button_caption",
                                 JM_UNICODE(pdf_to_str_buf(gctx, ca)));

                int field_flags = pdf_get_field_flags(gctx, pdf, annot->obj);
                PyObject_SetAttrString(Widget, "field_flags",
                                       Py_BuildValue("i", field_flags));
                
                // call Py method to reconstruct text color, font name, size
                PyObject *call = PyObject_CallMethod(Widget,
                                                     "_parse_da", NULL);
                Py_XDECREF(call);

            }
            fz_always(gctx) PyErr_Clear();
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN void delete_fz_link_s(struct fz_link_s *self){
            DEBUGMSG1("link");
            fz_drop_link(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *fz_link_s__border(struct fz_link_s *self,struct fz_document_s *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, doc);
            if (!pdf) return NONE;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) return NONE;
            PyObject *b = JM_annot_border(gctx, link_obj);
            pdf_drop_obj(gctx, link_obj);
            return b;
        }
SWIGINTERN PyObject *fz_link_s__setBorder(struct fz_link_s *self,PyObject *border,struct fz_document_s *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, doc);
            if (!pdf) return NONE;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) return NONE;
            PyObject *b = JM_annot_set_border(gctx, border, pdf, link_obj);
            pdf_drop_obj(gctx, link_obj);
            return b;
        }
SWIGINTERN PyObject *fz_link_s__colors(struct fz_link_s *self,struct fz_document_s *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, doc);
            if (!pdf) return NONE;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) return NONE;
            PyObject *b = JM_annot_colors(gctx, link_obj);
            pdf_drop_obj(gctx, link_obj);
            return b;
        }
SWIGINTERN PyObject *fz_link_s__setColors(struct fz_link_s *self,PyObject *colors,struct fz_document_s *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, doc);
            pdf_obj *arr = NULL;
            int i;
            if (!pdf) return NONE;
            if (!PyDict_Check(colors)) return NONE;
            float scol[4] = {0.0f, 0.0f, 0.0f, 0.0f};
            int nscol = 0;
            float fcol[4] = {0.0f, 0.0f, 0.0f, 0.0f};
            int nfcol = 0;
            PyObject *stroke = PyDict_GetItemString(colors, "stroke");
            PyObject *fill = PyDict_GetItemString(colors, "fill");
            JM_color_FromSequence(stroke, &nscol, scol);
            JM_color_FromSequence(fill, &nfcol, fcol);
            if (!nscol && !nfcol) return NONE;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) return NONE;
            if (nscol > 0)
            {
                arr = pdf_new_array(gctx, pdf, nscol);
                for (i = 0; i < nscol; i++)
                    pdf_array_push_real(gctx, arr, scol[i]);
                pdf_dict_put_drop(gctx, link_obj, PDF_NAME(C), arr);
            }
            if (nfcol > 0) JM_Warning("this annot type has no fill color)");
            pdf_drop_obj(gctx, link_obj);
            return NONE;
        }
SWIGINTERN PyObject *fz_link_s_uri(struct fz_link_s *self){
            return Py_BuildValue("s", self->uri);
        }
SWIGINTERN PyObject *fz_link_s_isExternal(struct fz_link_s *self){
            if (!self->uri) Py_RETURN_FALSE;
            return JM_BOOL(fz_is_external_link(gctx, self->uri));
        }
SWIGINTERN PyObject *fz_link_s_rect(struct fz_link_s *self){
            return JM_py_from_rect(self->rect);
        }
SWIGINTERN struct fz_link_s *fz_link_s_next(struct fz_link_s *self){
            fz_keep_link(gctx, self->next);
            return self->next;
        }
SWIGINTERN void delete_fz_display_list_s(struct fz_display_list_s *self){
            DEBUGMSG1("display list");
            fz_drop_display_list(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN struct fz_display_list_s *new_fz_display_list_s(PyObject *mediabox){
            struct fz_display_list_s *dl = NULL;
            fz_try(gctx)
                dl = fz_new_display_list(gctx, JM_rect_from_py(mediabox));
            fz_catch(gctx) return NULL;
            return dl;
        }
SWIGINTERN PyObject *fz_display_list_s_run(struct fz_display_list_s *self,struct DeviceWrapper *dw,PyObject *m,PyObject *area){
            fz_try(gctx)
            {
                fz_run_display_list(gctx, self, dw->device,
                    JM_matrix_from_py(m), JM_rect_from_py(area), NULL);
            }
            fz_catch(gctx) return NULL;
            return NONE;
        }
SWIGINTERN PyObject *fz_display_list_s_rect(struct fz_display_list_s *self){
            return JM_py_from_rect(fz_bound_display_list(gctx, self));
        }
SWIGINTERN struct fz_pixmap_s *fz_display_list_s_getPixmap(struct fz_display_list_s *self,PyObject *matrix,struct fz_colorspace_s *colorspace,int alpha,PyObject *clip){
            struct fz_colorspace_s *cs = NULL;
            fz_pixmap *pix = NULL;

            if (colorspace) cs = colorspace;
            else cs = fz_device_rgb(gctx);

            fz_try(gctx)
            {
                pix = JM_pixmap_from_display_list(gctx, self, matrix, cs, alpha, clip);
            }
            fz_catch(gctx) return NULL;
            return pix;
        }
SWIGINTERN struct fz_stext_page_s *fz_display_list_s_getTextPage(struct fz_display_list_s *self,int flags){
            struct fz_stext_page_s *tp = NULL;
            fz_try(gctx)
            {
                fz_stext_options stext_options = { 0 };
                stext_options.flags = flags;
                tp = fz_new_stext_page_from_display_list(gctx, self, &stext_options);
            }
            fz_catch(gctx) return NULL;
            return tp;
        }
SWIGINTERN struct fz_stext_page_s *new_fz_stext_page_s(PyObject *mediabox){
            struct fz_stext_page_s *tp = NULL;
            fz_try(gctx)
                tp = fz_new_stext_page(gctx, JM_rect_from_py(mediabox));
            fz_catch(gctx) return NULL;
            return tp;
        }
SWIGINTERN void delete_fz_stext_page_s(struct fz_stext_page_s *self){
            DEBUGMSG1("text page");
            fz_drop_stext_page(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *fz_stext_page_s_search(struct fz_stext_page_s *self,char const *needle,int hit_max,int quads){
            fz_quad *result = NULL;
            PyObject *liste = PyList_New(0);
            int i, mymax = hit_max;
            if (mymax < 1) mymax = 16;
            result = JM_Alloc(fz_quad, (mymax+1));
            struct fz_quad_s *quad = (struct fz_quad_s *) result;
            int count = fz_search_stext_page(gctx, self, needle, result, hit_max);
            for (i = 0; i < count; i++)
            {
                PyList_Append(liste,
                              Py_BuildValue("(ff),(ff),(ff),(ff)",
                                            quad->ul.x, quad->ul.y,
                                            quad->ur.x, quad->ur.y,
                                            quad->ll.x, quad->ll.y,
                                            quad->lr.x, quad->lr.y));
                quad += 1;
            }
            JM_Free(result);
            return liste;
        }
SWIGINTERN PyObject *fz_stext_page_s__extractTextBlocks_AsList(struct fz_stext_page_s *self){
            fz_stext_block *block;
            fz_stext_line *line;
            fz_stext_char *ch;
            int block_n = 0;
            PyObject *lines = PyList_New(0);
            PyObject *text = NULL, *litem;
            fz_buffer *res = NULL;
            for (block = self->first_block; block; block = block->next)
            {
                fz_rect blockrect = block->bbox;
                if (block->type == FZ_STEXT_BLOCK_TEXT)
                {
                    fz_try(gctx)
                    {
                        res = fz_new_buffer(gctx, 1024);
                        int line_n = 0;
                        float last_y0 = 0.0;
                        for (line = block->u.t.first_line; line; line = line->next)
                        {
                            fz_rect linerect = line->bbox;
                            // append line no. 2 with new-line 
                            if (line_n > 0)
                            {
                                if (linerect.y0 != last_y0)
                                    fz_append_string(gctx, res, "\n");
                                else
                                    fz_append_string(gctx, res, " ");
                            }
                            last_y0 = linerect.y0;
                            line_n++;
                            for (ch = line->first_char; ch; ch = ch->next)
                            {
                                fz_append_rune(gctx, res, ch->c);
                                linerect = fz_union_rect(linerect, JM_char_bbox(line, ch));
                            }
                            blockrect = fz_union_rect(blockrect, linerect);
                        }
                        text = JM_StrFromBuffer(gctx, res);
                    }
                    fz_always(gctx)
                    {
                        fz_drop_buffer(gctx, res);
                        res = NULL;
                    }
                    fz_catch(gctx) return NULL;
                }
                else
                {
                    fz_image *img = block->u.i.image;
                    fz_colorspace *cs = img->colorspace;
                    text = PyUnicode_FromFormat("<image: %s, width %d, height %d, bpc %d>", fz_colorspace_name(gctx, cs), img->w, img->h, img->bpc);
                    blockrect = fz_union_rect(blockrect, block->bbox);
                }
                litem = Py_BuildValue("ffffOii", blockrect.x0, blockrect.y0,
                                      blockrect.x1, blockrect.y1,
                                      text, block_n, block->type);
                PyList_Append(lines, litem);
                Py_CLEAR(litem);
                Py_CLEAR(text);
                block_n++;
            }
            return lines;
        }
SWIGINTERN PyObject *fz_stext_page_s__extractTextWords_AsList(struct fz_stext_page_s *self){
            fz_stext_block *block;
            fz_stext_line *line;
            fz_stext_char *ch;
            fz_buffer *buff = NULL;
            size_t buflen = 0;
            int block_n = 0, line_n, word_n;
            fz_rect wbbox = {0,0,0,0};          // word bbox
            PyObject *lines = PyList_New(0);
            for (block = self->first_block; block; block = block->next)
            {
                if (block->type != FZ_STEXT_BLOCK_TEXT)
                {
                    block_n++;
                    continue;
                }
                line_n = 0;
                for (line = block->u.t.first_line; line; line = line->next)
                {
                    word_n = 0;                       // word counter per line
                    buff = NULL;                      // reset word buffer
                    buflen = 0;                       // reset char counter
                    for (ch = line->first_char; ch; ch = ch->next)
                    {
                        if (ch->c == 32 && buflen == 0)
                            continue;                 // skip spaces at line start
                        if (ch->c == 32)
                        {   // --> finish the word
                            word_n = JM_append_word(gctx, lines, buff, &wbbox,
                                                    block_n, line_n, word_n);
                            fz_drop_buffer(gctx, buff);
                            buff = NULL;
                            buflen = 0;               // reset char counter
                            continue;
                        }
                        // append one unicode character to the word
                        if (!buff) buff = fz_new_buffer(gctx, 64);
                        fz_append_rune(gctx, buff, ch->c);
                        buflen++;
                        // enlarge word bbox
                        wbbox = fz_union_rect(wbbox, JM_char_bbox(line, ch));
                    }
                    if (buff)                         // store any remaining word
                    {
                        word_n = JM_append_word(gctx, lines, buff, &wbbox,
                                                block_n, line_n, word_n);
                        fz_drop_buffer(gctx, buff);
                        buff = NULL;
                        buflen = 0;
                    }
                    line_n++;
                }
                block_n++;
            }
            return lines;
        }
SWIGINTERN PyObject *fz_stext_page_s__extractText(struct fz_stext_page_s *self,int format){
            fz_buffer *res = NULL;
            fz_output *out = NULL;
            PyObject *text = NULL;
            fz_var(res);
            fz_var(out);
            fz_try(gctx)
            {
                res = fz_new_buffer(gctx, 1024);
                out = fz_new_output_with_buffer(gctx, res);
                switch(format)
                {
                    case(1):
                        fz_print_stext_page_as_html(gctx, out, self);
                        break;
                    case(2):
                        text = JM_stext_page_as_dict(gctx, self, 0);
                        break;
                    case(3):
                        fz_print_stext_page_as_xml(gctx, out, self);
                        break;
                    case(4):
                        fz_print_stext_page_as_xhtml(gctx, out, self);
                        break;
                    case(5):
                        text = JM_stext_page_as_dict(gctx, self, 0);
                        break;
                    case(6):
                        text = JM_stext_page_as_dict(gctx, self, 1);
                        break;
                    default:
                        JM_print_stext_page_as_text(gctx, out, self);
                        break;
                }
                if (!text) text = JM_StrFromBuffer(gctx, res);
                
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
                fz_drop_output(gctx, out);
            }
            fz_catch(gctx) return NULL;

            return text;
        }
SWIGINTERN void delete_pdf_graft_map_s(struct pdf_graft_map_s *self){
            DEBUGMSG1("graftmap");
            pdf_drop_graft_map(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN struct pdf_graft_map_s *new_pdf_graft_map_s(struct fz_document_s *doc){
            pdf_graft_map *map = NULL;
            fz_try(gctx)
            {
                pdf_document *dst = pdf_specifics(gctx, doc);
                assert_PDF(dst);
                map = pdf_new_graft_map(gctx, dst);
            }
            fz_catch(gctx) return NULL;
            return map;
        }
SWIGINTERN PyObject *Tools_gen_id(struct Tools *self){
            JM_UNIQUE_ID += 1;
            if (JM_UNIQUE_ID < 0) JM_UNIQUE_ID = 1;
            return Py_BuildValue("i", JM_UNIQUE_ID);
        }
SWIGINTERN PyObject *Tools_store_shrink(struct Tools *self,int percent){
            if (percent >= 100)
            {
                fz_empty_store(gctx);
                return Py_BuildValue("i", 0);
            }
            if (percent > 0) fz_shrink_store(gctx, 100 - percent);
            return Py_BuildValue("i", (int) gctx->store->size);
        }
SWIGINTERN PyObject *Tools_store_size(struct Tools *self){
            return Py_BuildValue("i", (int) gctx->store->size);
        }
SWIGINTERN PyObject *Tools_store_maxsize(struct Tools *self){
            return Py_BuildValue("i", (int) gctx->store->max);
        }
SWIGINTERN PyObject *Tools_fitz_config(struct Tools *self){
            return JM_fitz_config();
        }
SWIGINTERN void Tools_glyph_cache_empty(struct Tools *self){
            fz_purge_glyph_cache(gctx);
        }
SWIGINTERN PyObject *Tools__insert_contents(struct Tools *self,struct fz_page_s *fzpage,PyObject *newcont,int overlay){
            fz_buffer *contbuf = NULL;
            int xref = 0;
            pdf_page *page = pdf_page_from_fz_page(gctx, fzpage);
            fz_try(gctx)
            {
                assert_PDF(page);
                contbuf = JM_BufferFromBytes(gctx, newcont);
                xref = JM_insert_contents(gctx, page->doc, page->obj, contbuf, overlay);
                page->doc->dirty = 1;
            }
            fz_always(gctx) fz_drop_buffer(gctx, contbuf);
            fz_catch(gctx) return NULL;
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Tools_fitz_stdout(struct Tools *self){
            return Py_BuildValue("s", PyByteArray_AS_STRING(JM_output_log));
        }
SWIGINTERN void Tools_fitz_stdout_reset(struct Tools *self){
            Py_CLEAR(JM_output_log);
            JM_output_log = PyByteArray_FromStringAndSize("", 0);
        }
SWIGINTERN PyObject *Tools_fitz_stderr(struct Tools *self){
            return Py_BuildValue("s", PyByteArray_AS_STRING(JM_error_log));
        }
SWIGINTERN void Tools_fitz_stderr_reset(struct Tools *self){
            Py_CLEAR(JM_error_log);
            JM_error_log  = PyByteArray_FromStringAndSize("", 0);
        }
SWIGINTERN PyObject *Tools_mupdf_version(struct Tools *self){
            return Py_BuildValue("s", FZ_VERSION);
        }
SWIGINTERN PyObject *Tools__transform_rect(struct Tools *self,PyObject *rect,PyObject *matrix){
            return JM_py_from_rect(fz_transform_rect(JM_rect_from_py(rect), JM_matrix_from_py(matrix)));
        }
SWIGINTERN PyObject *Tools__intersect_rect(struct Tools *self,PyObject *r1,PyObject *r2){
            return JM_py_from_rect(fz_intersect_rect(JM_rect_from_py(r1),
                                                     JM_rect_from_py(r2)));
        }
SWIGINTERN PyObject *Tools__include_point_in_rect(struct Tools *self,PyObject *r,PyObject *p){
            return JM_py_from_rect(fz_include_point_in_rect(JM_rect_from_py(r),
                                                     JM_point_from_py(p)));
        }
SWIGINTERN PyObject *Tools__union_rect(struct Tools *self,PyObject *r1,PyObject *r2){
            return JM_py_from_rect(fz_union_rect(JM_rect_from_py(r1),
                                                 JM_rect_from_py(r2)));
        }
SWIGINTERN PyObject *Tools__concat_matrix(struct Tools *self,PyObject *m1,PyObject *m2){
            return JM_py_from_matrix(fz_concat(JM_matrix_from_py(m1),
                                                 JM_matrix_from_py(m2)));
        }
SWIGINTERN PyObject *Tools__invert_matrix(struct Tools *self,PyObject *matrix){
            fz_matrix src = JM_matrix_from_py(matrix);
            float a = src.a;
            float det = a * src.d - src.b * src.c;
            if (det < -JM_EPS || det > JM_EPS)
            {
                fz_matrix dst;
                float rdet = 1 / det;
                dst.a = src.d * rdet;
                dst.b = -src.b * rdet;
                dst.c = -src.c * rdet;
                dst.d = a * rdet;
                a = -src.e * dst.a - src.f * dst.c;
                dst.f = -src.e * dst.b - src.f * dst.d;
                dst.e = a;
                return Py_BuildValue("(i, O)", 0, JM_py_from_matrix(dst));
            }
            return Py_BuildValue("(i, ())", 1);
        }
SWIGINTERN float Tools_measure_string(struct Tools *self,char const *text,char const *fontname,float fontsize){
            fz_font *font = fz_new_base14_font(gctx, fontname);
            float w = 0;
            while (*text)
            {
                int c, g;
                text += fz_chartorune(&c, text);
                c = pdf_winansi_from_unicode(c);
                if (c < 0) c = 0xB7;
                g = fz_encode_character(gctx, font, c);
                w += fz_advance_glyph(gctx, font, g, 0);
            }
            return w * fontsize;
        }

  #define SWIG_From_double   PyFloat_FromDouble 


SWIGINTERNINLINE PyObject *
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}

#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_delete_Document(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Document",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Document" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  delete_fz_document_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Document(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) NULL ;
  PyObject *arg2 = (PyObject *) NULL ;
  char *arg3 = (char *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  float arg5 = (float) 0 ;
  float arg6 = (float) 0 ;
  float arg7 = (float) 11 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  float val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  struct fz_document_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"|OOOOOOO:new_Document",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Document" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
  }
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Document" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (obj3) {
    arg4 = obj3;
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_float(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Document" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_float(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Document" "', argument " "6"" of type '" "float""'");
    } 
    arg6 = (float)(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_float(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Document" "', argument " "7"" of type '" "float""'");
    } 
    arg7 = (float)(val7);
  }
  {
    result = (struct fz_document_s *)new_fz_document_s((char const *)arg1,arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_document_s, SWIG_POINTER_NEW |  0 );
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_close(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document_close",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_close" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  fz_document_s_close(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_loadPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_page_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:Document_loadPage",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_loadPage" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_loadPage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct fz_page_s *)fz_document_s_loadPage(arg1,arg2);
    if(result==NULL)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_page_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__loadOutline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_outline_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__loadOutline",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__loadOutline" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (struct fz_outline_s *)fz_document_s__loadOutline(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_outline_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__dropOutline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  struct fz_outline_s *arg2 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document__dropOutline",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__dropOutline" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__dropOutline" "', argument " "2"" of type '" "struct fz_outline_s *""'"); 
  }
  arg2 = (struct fz_outline_s *)(argp2);
  fz_document_s__dropOutline(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_embeddedFileCount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document_embeddedFileCount",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_embeddedFileCount" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_embeddedFileCount(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_embeddedFileDel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document_embeddedFileDel",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_embeddedFileDel" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_embeddedFileDel" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    result = (PyObject *)fz_document_s_embeddedFileDel(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_embeddedFileInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document_embeddedFileInfo",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_embeddedFileInfo" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  arg2 = obj1;
  {
    result = (PyObject *)fz_document_s_embeddedFileInfo(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_embeddedFileUpd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO|OOOO:Document_embeddedFileUpd",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_embeddedFileUpd" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  arg2 = obj1;
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document_embeddedFileUpd" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (obj4) {
    res5 = SWIG_AsCharPtrAndSize(obj4, &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Document_embeddedFileUpd" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (obj5) {
    res6 = SWIG_AsCharPtrAndSize(obj5, &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Document_embeddedFileUpd" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  {
    result = (PyObject *)fz_document_s_embeddedFileUpd(arg1,arg2,arg3,arg4,arg5,arg6);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_embeddedFileGet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document_embeddedFileGet",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_embeddedFileGet" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  arg2 = obj1;
  {
    result = (PyObject *)fz_document_s_embeddedFileGet(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_embeddedFileAdd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO|OOO:Document_embeddedFileAdd",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_embeddedFileAdd" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  arg2 = obj1;
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document_embeddedFileAdd" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  if (obj3) {
    res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document_embeddedFileAdd" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (obj4) {
    res5 = SWIG_AsCharPtrAndSize(obj4, &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Document_embeddedFileAdd" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (obj5) {
    res6 = SWIG_AsCharPtrAndSize(obj5, &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Document_embeddedFileAdd" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  {
    result = (PyObject *)fz_document_s_embeddedFileAdd(arg1,arg2,(char const *)arg3,arg4,arg5,arg6);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_convertToPDF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|OOO:Document_convertToPDF",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_convertToPDF" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_convertToPDF" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_convertToPDF" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_convertToPDF" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)fz_document_s_convertToPDF(arg1,arg2,arg3,arg4);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_pageCount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document_pageCount",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_pageCount" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_pageCount(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getMetadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document__getMetadata",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getMetadata" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__getMetadata" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  result = (char *)fz_document_s__getMetadata(arg1,(char const *)arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_needsPass(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document_needsPass",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_needsPass" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_needsPass(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_resolveLink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:Document_resolveLink",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_resolveLink" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (obj1) {
    res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_resolveLink" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  result = (PyObject *)fz_document_s_resolveLink(arg1,arg2);
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_layout(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  float arg3 = (float) 0 ;
  float arg4 = (float) 0 ;
  float arg5 = (float) 11 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|OOOO:Document_layout",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_layout" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_float(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_layout" "', argument " "3"" of type '" "float""'");
    } 
    arg3 = (float)(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_float(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_layout" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_float(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_layout" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  {
    result = (PyObject *)fz_document_s_layout(arg1,arg2,arg3,arg4,arg5);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_makeBookmark(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:Document_makeBookmark",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_makeBookmark" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_makeBookmark" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (PyObject *)fz_document_s_makeBookmark(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_findBookmark(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  long long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document_findBookmark",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_findBookmark" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_findBookmark" "', argument " "2"" of type '" "long long""'");
  } 
  arg2 = (long long)(val2);
  result = (PyObject *)fz_document_s_findBookmark(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_isReflowable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document_isReflowable",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_isReflowable" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_isReflowable(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__deleteObject(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document__deleteObject",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__deleteObject" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__deleteObject" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__deleteObject(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getPDFroot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__getPDFroot",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getPDFroot" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__getPDFroot(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getPDFfileid(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__getPDFfileid",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getPDFfileid" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__getPDFfileid(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_isPDF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document_isPDF",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_isPDF" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_isPDF(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__hasXrefStream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__hasXrefStream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__hasXrefStream" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__hasXrefStream(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__hasXrefOldStyle(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__hasXrefOldStyle",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__hasXrefOldStyle" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__hasXrefOldStyle(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_isDirty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document_isDirty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_isDirty" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_isDirty(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getGCTXerrcode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__getGCTXerrcode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getGCTXerrcode" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__getGCTXerrcode(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getGCTXerrmsg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__getGCTXerrmsg",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getGCTXerrmsg" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__getGCTXerrmsg(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_authenticate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document_authenticate",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_authenticate" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_authenticate" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  result = (PyObject *)fz_document_s_authenticate(arg1,arg2);
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_save(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) 0 ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 0 ;
  int arg7 = (int) 0 ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 0 ;
  int arg10 = (int) 0 ;
  int arg11 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO|OOOOOOOOO:Document_save",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_save" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_save" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_save" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_save" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_save" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document_save" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document_save" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Document_save" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (obj8) {
    ecode9 = SWIG_AsVal_int(obj8, &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Document_save" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  if (obj9) {
    ecode10 = SWIG_AsVal_int(obj9, &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Document_save" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = (int)(val10);
  }
  if (obj10) {
    ecode11 = SWIG_AsVal_int(obj10, &val11);
    if (!SWIG_IsOK(ecode11)) {
      SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "Document_save" "', argument " "11"" of type '" "int""'");
    } 
    arg11 = (int)(val11);
  }
  {
    result = (PyObject *)fz_document_s_save(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_write(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) 0 ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 0 ;
  int arg7 = (int) 0 ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|OOOOOOOO:Document_write",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_write" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_write" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_write" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_write" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_write" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document_write" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document_write" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Document_write" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (obj8) {
    ecode9 = SWIG_AsVal_int(obj8, &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Document_write" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  {
    result = (PyObject *)fz_document_s_write(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_insertPDF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  struct fz_document_s *arg2 = (struct fz_document_s *) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO|OOOOO:Document_insertPDF",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_insertPDF" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_insertPDF" "', argument " "2"" of type '" "struct fz_document_s *""'"); 
  }
  arg2 = (struct fz_document_s *)(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_insertPDF" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_insertPDF" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_insertPDF" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document_insertPDF" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document_insertPDF" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    result = (PyObject *)fz_document_s_insertPDF(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_insertPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) -1 ;
  PyObject *arg3 = (PyObject *) NULL ;
  float arg4 = (float) 11 ;
  float arg5 = (float) 595 ;
  float arg6 = (float) 842 ;
  int arg7 = (int) 0 ;
  char *arg8 = (char *) NULL ;
  char *arg9 = (char *) NULL ;
  int arg10 = (int) 0 ;
  PyObject *arg11 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  int alloc9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O|OOOOOOOOOO:Document_insertPage",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_insertPage" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_insertPage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_float(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_insertPage" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_float(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_insertPage" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_float(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document_insertPage" "', argument " "6"" of type '" "float""'");
    } 
    arg6 = (float)(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document_insertPage" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (obj7) {
    res8 = SWIG_AsCharPtrAndSize(obj7, &buf8, NULL, &alloc8);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "Document_insertPage" "', argument " "8"" of type '" "char *""'");
    }
    arg8 = (char *)(buf8);
  }
  if (obj8) {
    res9 = SWIG_AsCharPtrAndSize(obj8, &buf9, NULL, &alloc9);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "Document_insertPage" "', argument " "9"" of type '" "char *""'");
    }
    arg9 = (char *)(buf9);
  }
  if (obj9) {
    ecode10 = SWIG_AsVal_int(obj9, &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Document_insertPage" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = (int)(val10);
  }
  if (obj10) {
    arg11 = obj10;
  }
  {
    result = (int)fz_document_s_insertPage(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if(result<0)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_From_int((int)(result));
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return resultobj;
fail:
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_select(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document_select",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_select" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  arg2 = obj1;
  {
    result = (PyObject *)fz_document_s_select(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_permissions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document_permissions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_permissions" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_permissions(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getCharWidths(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO|O:Document__getCharWidths",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getCharWidths" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getCharWidths" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document__getCharWidths" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document__getCharWidths" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document__getCharWidths" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document__getCharWidths" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document__getCharWidths" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    result = (PyObject *)fz_document_s__getCharWidths(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getPageObjNumber(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document__getPageObjNumber",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getPageObjNumber" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getPageObjNumber" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__getPageObjNumber(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getPageInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Document__getPageInfo",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getPageInfo" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getPageInfo" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document__getPageInfo" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)fz_document_s__getPageInfo(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_extractFont(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|OO:Document_extractFont",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_extractFont" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_extractFont" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_extractFont" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)fz_document_s_extractFont(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_extractImage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:Document_extractImage",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_extractImage" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_extractImage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)fz_document_s_extractImage(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__delToC(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__delToC",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__delToC" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__delToC(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_isFormPDF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document_isFormPDF",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_isFormPDF" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_isFormPDF(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_FormFonts(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document_FormFonts",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_FormFonts" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_FormFonts(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__addFormFont(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Document__addFormFont",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__addFormFont" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__addFormFont" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document__addFormFont" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  {
    result = (PyObject *)fz_document_s__addFormFont(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getOLRootNumber(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__getOLRootNumber",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getOLRootNumber" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  {
    result = (PyObject *)fz_document_s__getOLRootNumber(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getNewXref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__getNewXref",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getNewXref" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  {
    result = (PyObject *)fz_document_s__getNewXref(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getXrefLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__getXrefLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getXrefLength" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__getXrefLength(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getXmlMetadataXref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__getXmlMetadataXref",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getXmlMetadataXref" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__getXmlMetadataXref(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__delXmlMetadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Document__delXmlMetadata",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__delXmlMetadata" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  {
    result = (PyObject *)fz_document_s__delXmlMetadata(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getXrefString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document__getXrefString",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getXrefString" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getXrefString" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__getXrefString(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getXrefStream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document__getXrefStream",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getXrefStream" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getXrefStream" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__getXrefStream(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__updateObject(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  struct fz_page_s *arg4 = (struct fz_page_s *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO|O:Document__updateObject",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__updateObject" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__updateObject" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document__updateObject" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_fz_page_s, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document__updateObject" "', argument " "4"" of type '" "struct fz_page_s *""'"); 
    }
    arg4 = (struct fz_page_s *)(argp4);
  }
  {
    result = (PyObject *)fz_document_s__updateObject(arg1,arg2,arg3,arg4);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__updateStream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|OOO:Document__updateStream",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__updateStream" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__updateStream" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document__updateStream" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)fz_document_s__updateStream(arg1,arg2,arg3,arg4);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__setMetadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Document__setMetadata",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__setMetadata" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__setMetadata" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    result = (PyObject *)fz_document_s__setMetadata(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *Document_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_document_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Page",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Page" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  delete_fz_page_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_bound(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page_bound",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_bound" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s_bound(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_run(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  struct DeviceWrapper *arg2 = (struct DeviceWrapper *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Page_run",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_run" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_DeviceWrapper, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page_run" "', argument " "2"" of type '" "struct DeviceWrapper *""'"); 
  }
  arg2 = (struct DeviceWrapper *)(argp2);
  arg3 = obj2;
  {
    result = (PyObject *)fz_page_s_run(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_getSVGimage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:Page_getSVGimage",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_getSVGimage" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  if (obj1) {
    arg2 = obj1;
  }
  {
    result = (PyObject *)fz_page_s_getSVGimage(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addLineAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Page_addLineAnnot",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addLineAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  {
    result = (struct fz_annot_s *)fz_page_s_addLineAnnot(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addTextAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Page_addTextAnnot",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addTextAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page_addTextAnnot" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  {
    result = (struct fz_annot_s *)fz_page_s_addTextAnnot(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addInkAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_addInkAnnot",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addInkAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct fz_annot_s *)fz_page_s_addInkAnnot(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addStampAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO|O:Page_addStampAnnot",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addStampAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page_addStampAnnot" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (struct fz_annot_s *)fz_page_s_addStampAnnot(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addFileAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO|OO:Page_addFileAnnot",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addFileAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page_addFileAnnot" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  if (obj4) {
    res5 = SWIG_AsCharPtrAndSize(obj4, &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Page_addFileAnnot" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (obj5) {
    res6 = SWIG_AsCharPtrAndSize(obj5, &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Page_addFileAnnot" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  {
    result = (struct fz_annot_s *)fz_page_s_addFileAnnot(arg1,arg2,arg3,arg4,arg5,arg6);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addStrikeoutAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_addStrikeoutAnnot",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addStrikeoutAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct fz_annot_s *)fz_page_s_addStrikeoutAnnot(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addUnderlineAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_addUnderlineAnnot",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addUnderlineAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct fz_annot_s *)fz_page_s_addUnderlineAnnot(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addSquigglyAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_addSquigglyAnnot",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addSquigglyAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct fz_annot_s *)fz_page_s_addSquigglyAnnot(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addHighlightAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_addHighlightAnnot",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addHighlightAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct fz_annot_s *)fz_page_s_addHighlightAnnot(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addRectAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_addRectAnnot",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addRectAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct fz_annot_s *)fz_page_s_addRectAnnot(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addCircleAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_addCircleAnnot",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addCircleAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct fz_annot_s *)fz_page_s_addCircleAnnot(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addPolylineAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_addPolylineAnnot",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addPolylineAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct fz_annot_s *)fz_page_s_addPolylineAnnot(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addPolygonAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_addPolygonAnnot",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addPolygonAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct fz_annot_s *)fz_page_s_addPolygonAnnot(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addFreetextAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  char *arg3 = (char *) 0 ;
  float arg4 = (float) 12 ;
  char *arg5 = (char *) NULL ;
  PyObject *arg6 = (PyObject *) NULL ;
  int arg7 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO|OOOO:Page_addFreetextAnnot",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addFreetextAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page_addFreetextAnnot" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  if (obj3) {
    ecode4 = SWIG_AsVal_float(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Page_addFreetextAnnot" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (obj4) {
    res5 = SWIG_AsCharPtrAndSize(obj4, &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Page_addFreetextAnnot" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (obj5) {
    arg6 = obj5;
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Page_addFreetextAnnot" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    result = (struct fz_annot_s *)fz_page_s_addFreetextAnnot(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__addWidget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page__addWidget",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__addWidget" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct fz_annot_s *)fz_page_s__addWidget(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_getDisplayList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_display_list_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page_getDisplayList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_getDisplayList" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  {
    result = (struct fz_display_list_s *)fz_page_s_getDisplayList(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_setCropBox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_setCropBox",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_setCropBox" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (PyObject *)fz_page_s_setCropBox(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_loadLinks(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_link_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page_loadLinks",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_loadLinks" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (struct fz_link_s *)fz_page_s_loadLinks(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_link_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_firstAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page_firstAnnot",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_firstAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (struct fz_annot_s *)fz_page_s_firstAnnot(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_deleteLink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_deleteLink",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_deleteLink" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  fz_page_s_deleteLink(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_deleteAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  struct fz_annot_s *arg2 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_deleteAnnot",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_deleteAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page_deleteAnnot" "', argument " "2"" of type '" "struct fz_annot_s *""'"); 
  }
  arg2 = (struct fz_annot_s *)(argp2);
  result = (struct fz_annot_s *)fz_page_s_deleteAnnot(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_MediaBoxSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page_MediaBoxSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_MediaBoxSize" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s_MediaBoxSize(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_CropBoxPosition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page_CropBoxPosition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_CropBoxPosition" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s_CropBoxPosition(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_rotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page_rotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_rotation" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (int)fz_page_s_rotation(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_setRotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page_setRotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_setRotation" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page_setRotation" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_page_s_setRotation(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__addAnnot_FromString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Page__addAnnot_FromString",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__addAnnot_FromString" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  {
    result = (PyObject *)fz_page_s__addAnnot_FromString(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__getLinkXrefs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page__getLinkXrefs",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__getLinkXrefs" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s__getLinkXrefs(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__cleanContents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page__cleanContents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__cleanContents" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  {
    result = (PyObject *)fz_page_s__cleanContents(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__showPDFpage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  struct fz_document_s *arg3 = (struct fz_document_s *) 0 ;
  int arg4 = (int) 0 ;
  int arg5 = (int) 1 ;
  int arg6 = (int) 1 ;
  int arg7 = (int) 0 ;
  PyObject *arg8 = (PyObject *) NULL ;
  struct pdf_graft_map_s *arg9 = (struct pdf_graft_map_s *) NULL ;
  char *arg10 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  int res10 ;
  char *buf10 = 0 ;
  int alloc10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO|OOOOOOO:Page__showPDFpage",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__showPDFpage" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page__showPDFpage" "', argument " "3"" of type '" "struct fz_document_s *""'"); 
  }
  arg3 = (struct fz_document_s *)(argp3);
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Page__showPDFpage" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Page__showPDFpage" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Page__showPDFpage" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Page__showPDFpage" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (obj7) {
    arg8 = obj7;
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9,SWIGTYPE_p_pdf_graft_map_s, 0 |  0 );
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "Page__showPDFpage" "', argument " "9"" of type '" "struct pdf_graft_map_s *""'"); 
    }
    arg9 = (struct pdf_graft_map_s *)(argp9);
  }
  if (obj9) {
    res10 = SWIG_AsCharPtrAndSize(obj9, &buf10, NULL, &alloc10);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "Page__showPDFpage" "', argument " "10"" of type '" "char *""'");
    }
    arg10 = (char *)(buf10);
  }
  {
    result = (PyObject *)fz_page_s__showPDFpage(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc10 == SWIG_NEWOBJ) free((char*)buf10);
  return resultobj;
fail:
  if (alloc10 == SWIG_NEWOBJ) free((char*)buf10);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_insertImage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  char *arg3 = (char *) NULL ;
  struct fz_pixmap_s *arg4 = (struct fz_pixmap_s *) NULL ;
  PyObject *arg5 = (PyObject *) NULL ;
  int arg6 = (int) 1 ;
  char *arg7 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO|OOOOO:Page_insertImage",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_insertImage" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = obj1;
  if (obj2) {
    res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page_insertImage" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page_insertImage" "', argument " "4"" of type '" "struct fz_pixmap_s *""'"); 
    }
    arg4 = (struct fz_pixmap_s *)(argp4);
  }
  if (obj4) {
    arg5 = obj4;
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Page_insertImage" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (obj6) {
    res7 = SWIG_AsCharPtrAndSize(obj6, &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "Page_insertImage" "', argument " "7"" of type '" "char *""'");
    }
    arg7 = (char *)(buf7);
  }
  {
    result = (PyObject *)fz_page_s_insertImage(arg1,arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__insertFont(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  PyObject *arg5 = (PyObject *) 0 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  int arg10 ;
  int arg11 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:Page__insertFont",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__insertFont" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__insertFont" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page__insertFont" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page__insertFont" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = obj4;
  ecode6 = SWIG_AsVal_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Page__insertFont" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Page__insertFont" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Page__insertFont" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Page__insertFont" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  ecode10 = SWIG_AsVal_int(obj9, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Page__insertFont" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  ecode11 = SWIG_AsVal_int(obj10, &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "Page__insertFont" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  {
    result = (PyObject *)fz_page_s__insertFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__getTransformation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page__getTransformation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__getTransformation" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s__getTransformation(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__getContents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Page__getContents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__getContents" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  {
    result = (PyObject *)fz_page_s__getContents(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__setContents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:Page__setContents",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__setContents" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page__setContents" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)fz_page_s__setContents(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Page_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_page_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_Pixmap_x_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap_x_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_x_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_x_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->x = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_x_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_x_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_x_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->x);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_y_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap_y_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_y_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_y_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->y = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_y_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_y_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_y_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->y);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_w_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap_w_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_w_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_w_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->w = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_w_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_w_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_w_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->w);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_h_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap_h_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_h_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_h_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->h = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_h_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_h_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_h_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->h);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_n_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap_n_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_n_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_n_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->n = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_n_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_n_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_n_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->n);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_xres_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap_xres_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_xres_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_xres_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->xres = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_xres_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_xres_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_xres_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->xres);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_yres_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap_yres_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_yres_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_yres_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->yres = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_yres_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_yres_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_yres_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->yres);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Pixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Pixmap",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Pixmap" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  delete_fz_pixmap_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO|O:new_Pixmap",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  arg2 = obj1;
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Pixmap" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_0(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  struct fz_pixmap_s *arg2 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Pixmap",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg2 = (struct fz_pixmap_s *)(argp2);
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_1(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  float arg2 ;
  float arg3 ;
  PyObject *arg4 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO|O:new_Pixmap",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_float(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  ecode3 = SWIG_AsVal_float(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Pixmap" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = (float)(val3);
  if (obj3) {
    arg4 = obj3;
  }
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_2(arg1,arg2,arg3,arg4);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:new_Pixmap",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_3(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  int arg2 ;
  int arg3 ;
  PyObject *arg4 = (PyObject *) 0 ;
  int arg5 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO|O:new_Pixmap",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Pixmap" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  arg4 = obj3;
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Pixmap" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_4(arg1,arg2,arg3,arg4,arg5);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Pixmap",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = (char *)(buf1);
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_5(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Pixmap",&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_6(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Pixmap",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_7(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 5) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      if (argc <= 1) {
        return _wrap_new_Pixmap__SWIG_3(self, args);
      }
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Pixmap__SWIG_3(self, args);
      }
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Pixmap__SWIG_5(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      return _wrap_new_Pixmap__SWIG_6(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_colorspace_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_Pixmap__SWIG_1(self, args);
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_colorspace_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        if (argc <= 2) {
          return _wrap_new_Pixmap__SWIG_0(self, args);
        }
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Pixmap__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_document_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Pixmap__SWIG_7(self, args);
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_float(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_float(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          if (argc <= 3) {
            return _wrap_new_Pixmap__SWIG_2(self, args);
          }
          _v = (argv[3] != 0);
          if (_v) {
            return _wrap_new_Pixmap__SWIG_2(self, args);
          }
        }
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_colorspace_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          _v = (argv[3] != 0);
          if (_v) {
            if (argc <= 4) {
              return _wrap_new_Pixmap__SWIG_4(self, args);
            }
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_Pixmap__SWIG_4(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_Pixmap'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_colorspace_s *,PyObject *,int)\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_colorspace_s *,struct fz_pixmap_s *)\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_pixmap_s *,float,float,PyObject *)\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_pixmap_s *,int)\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_colorspace_s *,int,int,PyObject *,int)\n"
    "    fz_pixmap_s::fz_pixmap_s(char *)\n"
    "    fz_pixmap_s::fz_pixmap_s(PyObject *)\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_document_s *,int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Pixmap_shrink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap_shrink",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_shrink" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_shrink" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  fz_pixmap_s_shrink(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_gammaWith(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap_gammaWith",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_gammaWith" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_float(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_gammaWith" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  fz_pixmap_s_gammaWith(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_tintWith(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:Pixmap_tintWith",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_tintWith" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_tintWith" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_tintWith" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Pixmap_tintWith" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  fz_pixmap_s_tintWith(arg1,arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clearWith__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_clearWith",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_clearWith" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  fz_pixmap_s_clearWith__SWIG_0(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clearWith__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap_clearWith",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_clearWith" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_clearWith" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  fz_pixmap_s_clearWith__SWIG_1(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clearWith__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Pixmap_clearWith",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_clearWith" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_clearWith" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  arg3 = obj2;
  fz_pixmap_s_clearWith__SWIG_2(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clearWith(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Pixmap_clearWith__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Pixmap_clearWith__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          return _wrap_Pixmap_clearWith__SWIG_2(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'Pixmap_clearWith'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    fz_pixmap_s::clearWith()\n"
    "    fz_pixmap_s::clearWith(int)\n"
    "    fz_pixmap_s::clearWith(int,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Pixmap_copyPixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  struct fz_pixmap_s *arg2 = (struct fz_pixmap_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Pixmap_copyPixmap",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_copyPixmap" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pixmap_copyPixmap" "', argument " "2"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg2 = (struct fz_pixmap_s *)(argp2);
  arg3 = obj2;
  {
    result = (PyObject *)fz_pixmap_s_copyPixmap(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_setAlpha(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:Pixmap_setAlpha",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_setAlpha" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  if (obj1) {
    arg2 = obj1;
  }
  {
    result = (PyObject *)fz_pixmap_s_setAlpha(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap__getImageData(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Pixmap__getImageData",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap__getImageData" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap__getImageData" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_pixmap_s__getImageData(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap__writeIMG(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Pixmap__writeIMG",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap__writeIMG" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pixmap__writeIMG" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap__writeIMG" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)fz_pixmap_s__writeIMG(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_invertIRect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:Pixmap_invertIRect",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_invertIRect" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  if (obj1) {
    arg2 = obj1;
  }
  fz_pixmap_s_invertIRect(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_pixel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Pixmap_pixel",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_pixel" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_pixel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_pixel" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)fz_pixmap_s_pixel(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_setPixel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  int arg3 ;
  PyObject *arg4 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:Pixmap_setPixel",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_setPixel" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_setPixel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_setPixel" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  arg4 = obj3;
  {
    result = (PyObject *)fz_pixmap_s_setPixel(arg1,arg2,arg3,arg4);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_stride(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_stride",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_stride" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int)fz_pixmap_s_stride(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_alpha(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_alpha",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_alpha" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int)fz_pixmap_s_alpha(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_colorspace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_colorspace_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_colorspace",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_colorspace" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (struct fz_colorspace_s *)fz_pixmap_s_colorspace(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_irect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_irect",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_irect" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (PyObject *)fz_pixmap_s_irect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_size",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_size" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int)fz_pixmap_s_size(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_samples(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Pixmap_samples",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_samples" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (PyObject *)fz_pixmap_s_samples(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Pixmap_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_pixmap_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Colorspace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Colorspace",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_colorspace_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Colorspace" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  delete_fz_colorspace_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Colorspace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_colorspace_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Colorspace",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Colorspace" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (struct fz_colorspace_s *)new_fz_colorspace_s(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_colorspace_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Colorspace_n(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Colorspace_n",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Colorspace_n" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  result = (PyObject *)fz_colorspace_s_n(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Colorspace__name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Colorspace__name",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Colorspace__name" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  result = (PyObject *)fz_colorspace_s__name(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Colorspace_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_colorspace_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Device__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct DeviceWrapper *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Device",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Device" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  arg2 = obj1;
  {
    result = (struct DeviceWrapper *)new_DeviceWrapper__SWIG_0(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Device__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct DeviceWrapper *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Device",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Device" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  {
    result = (struct DeviceWrapper *)new_DeviceWrapper__SWIG_1(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Device__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct DeviceWrapper *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:new_Device",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Device" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Device" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct DeviceWrapper *)new_DeviceWrapper__SWIG_2(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Device(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_display_list_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Device__SWIG_1(self, args);
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_stext_page_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      if (argc <= 1) {
        return _wrap_new_Device__SWIG_2(self, args);
      }
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Device__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_new_Device__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_Device'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    DeviceWrapper::DeviceWrapper(struct fz_pixmap_s *,PyObject *)\n"
    "    DeviceWrapper::DeviceWrapper(struct fz_display_list_s *)\n"
    "    DeviceWrapper::DeviceWrapper(struct fz_stext_page_s *,int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Device(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct DeviceWrapper *arg1 = (struct DeviceWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Device",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Device" "', argument " "1"" of type '" "struct DeviceWrapper *""'"); 
  }
  arg1 = (struct DeviceWrapper *)(argp1);
  delete_DeviceWrapper(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Device_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_DeviceWrapper, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_Outline_title_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Outline_title_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_title_get" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (char *) ((arg1)->title);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_page_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Outline_page_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_page_get" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (int) ((arg1)->page);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_next_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_outline_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Outline_next_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_next_get" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (struct fz_outline_s *) ((arg1)->next);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_outline_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_down_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_outline_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Outline_down_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_down_get" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (struct fz_outline_s *) ((arg1)->down);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_outline_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_is_open_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Outline_is_open_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_is_open_get" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (int) ((arg1)->is_open);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_uri(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Outline_uri",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_uri" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (PyObject *)fz_outline_s_uri(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_isExternal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Outline_isExternal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_isExternal" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (PyObject *)fz_outline_s_isExternal(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Outline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Outline",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_outline_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Outline" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  free((char *) arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Outline_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_outline_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Annot",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Annot" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  delete_fz_annot_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_rect",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_rect" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_xref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_xref",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_xref" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_xref(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__getAP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot__getAP",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__getAP" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  {
    result = (PyObject *)fz_annot_s__getAP(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__setAP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO|O:Annot__setAP",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__setAP" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  arg2 = obj1;
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Annot__setAP" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)fz_annot_s__setAP(arg1,arg2,arg3);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setRect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Annot_setRect",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setRect" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  arg2 = obj1;
  fz_annot_s_setRect(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_vertices(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_vertices",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_vertices" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_vertices(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_colors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_colors",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_colors" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_colors(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_update(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  float arg2 = (float) 0.0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  PyObject *arg5 = (PyObject *) NULL ;
  int arg6 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|OOOOO:Annot_update",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_update" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_float(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_update" "', argument " "2"" of type '" "float""'");
    } 
    arg2 = (float)(val2);
  }
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    arg4 = obj3;
  }
  if (obj4) {
    arg5 = obj4;
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Annot_update" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  result = (PyObject *)fz_annot_s_update(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setColors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Annot_setColors",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setColors" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  arg2 = obj1;
  fz_annot_s_setColors(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_lineEnds(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_lineEnds",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_lineEnds" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_lineEnds(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setLineEnds(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Annot_setLineEnds",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setLineEnds" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_setLineEnds" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Annot_setLineEnds" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  fz_annot_s_setLineEnds(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_type",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_type" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_type(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_opacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_opacity",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_opacity" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_opacity(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setOpacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Annot_setOpacity",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setOpacity" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  ecode2 = SWIG_AsVal_float(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_setOpacity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  fz_annot_s_setOpacity(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_widget_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_widget_type",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_widget_type" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_widget_type(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_widget_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_widget_value",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_widget_value" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_widget_value(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_widget_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_widget_name",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_widget_name" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_widget_name(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_widget_choices(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_widget_choices",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_widget_choices" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_widget_choices(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_fileInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_fileInfo",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_fileInfo" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  {
    result = (PyObject *)fz_annot_s_fileInfo(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_fileGet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_fileGet",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_fileGet" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  {
    result = (PyObject *)fz_annot_s_fileGet(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_fileUpd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  char *arg3 = (char *) NULL ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|OOOO:Annot_fileUpd",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_fileUpd" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Annot_fileUpd" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (obj3) {
    res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Annot_fileUpd" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (obj4) {
    res5 = SWIG_AsCharPtrAndSize(obj4, &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Annot_fileUpd" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  {
    result = (PyObject *)fz_annot_s_fileUpd(arg1,arg2,arg3,arg4,arg5);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_info",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_info" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_info(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Annot_setInfo",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setInfo" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  arg2 = obj1;
  {
    result = (PyObject *)fz_annot_s_setInfo(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_border(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_border",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_border" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (PyObject *)fz_annot_s_border(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setBorder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Annot_setBorder",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setBorder" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  arg2 = obj1;
  result = (PyObject *)fz_annot_s_setBorder(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_flags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_flags",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_flags" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (int)fz_annot_s_flags(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__cleanContents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot__cleanContents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__cleanContents" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  {
    result = (PyObject *)fz_annot_s__cleanContents(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setFlags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Annot_setFlags",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setFlags" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_setFlags" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  fz_annot_s_setFlags(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_annot_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Annot_next",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_next" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  result = (struct fz_annot_s *)fz_annot_s_next(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_getPixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  struct fz_colorspace_s *arg3 = (struct fz_colorspace_s *) NULL ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|OOO:Annot_getPixmap",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_getPixmap" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Annot_getPixmap" "', argument " "3"" of type '" "struct fz_colorspace_s *""'"); 
    }
    arg3 = (struct fz_colorspace_s *)(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Annot_getPixmap" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (struct fz_pixmap_s *)fz_annot_s_getPixmap(arg1,arg2,arg3,arg4);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__updateWidget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Annot__updateWidget",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__updateWidget" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  arg2 = obj1;
  {
    result = (PyObject *)fz_annot_s__updateWidget(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__getWidget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_annot_s *arg1 = (struct fz_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Annot__getWidget",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__getWidget" "', argument " "1"" of type '" "struct fz_annot_s *""'"); 
  }
  arg1 = (struct fz_annot_s *)(argp1);
  arg2 = obj1;
  {
    result = (PyObject *)fz_annot_s__getWidget(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Annot_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_annot_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Link(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Link",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_link_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Link" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  delete_fz_link_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__border(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  struct fz_document_s *arg2 = (struct fz_document_s *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Link__border",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__border" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Link__border" "', argument " "2"" of type '" "struct fz_document_s *""'"); 
  }
  arg2 = (struct fz_document_s *)(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Link__border" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (PyObject *)fz_link_s__border(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__setBorder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  struct fz_document_s *arg3 = (struct fz_document_s *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:Link__setBorder",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__setBorder" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  arg2 = obj1;
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Link__setBorder" "', argument " "3"" of type '" "struct fz_document_s *""'"); 
  }
  arg3 = (struct fz_document_s *)(argp3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Link__setBorder" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  result = (PyObject *)fz_link_s__setBorder(arg1,arg2,arg3,arg4);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__colors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  struct fz_document_s *arg2 = (struct fz_document_s *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Link__colors",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__colors" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Link__colors" "', argument " "2"" of type '" "struct fz_document_s *""'"); 
  }
  arg2 = (struct fz_document_s *)(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Link__colors" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (PyObject *)fz_link_s__colors(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__setColors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  struct fz_document_s *arg3 = (struct fz_document_s *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:Link__setColors",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__setColors" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  arg2 = obj1;
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Link__setColors" "', argument " "3"" of type '" "struct fz_document_s *""'"); 
  }
  arg3 = (struct fz_document_s *)(argp3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Link__setColors" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  result = (PyObject *)fz_link_s__setColors(arg1,arg2,arg3,arg4);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_uri(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Link_uri",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_uri" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  result = (PyObject *)fz_link_s_uri(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_isExternal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Link_isExternal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_isExternal" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  result = (PyObject *)fz_link_s_isExternal(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Link_rect",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_rect" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  result = (PyObject *)fz_link_s_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct fz_link_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Link_next",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_next" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  result = (struct fz_link_s *)fz_link_s_next(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_link_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Link_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_link_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_DisplayList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_DisplayList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_display_list_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DisplayList" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  delete_fz_display_list_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DisplayList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  struct fz_display_list_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_DisplayList",&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    result = (struct fz_display_list_s *)new_fz_display_list_s(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_display_list_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_run(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  struct DeviceWrapper *arg2 = (struct DeviceWrapper *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:DisplayList_run",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_run" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_DeviceWrapper, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DisplayList_run" "', argument " "2"" of type '" "struct DeviceWrapper *""'"); 
  }
  arg2 = (struct DeviceWrapper *)(argp2);
  arg3 = obj2;
  arg4 = obj3;
  {
    result = (PyObject *)fz_display_list_s_run(arg1,arg2,arg3,arg4);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DisplayList_rect",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_rect" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  result = (PyObject *)fz_display_list_s_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_getPixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  struct fz_colorspace_s *arg3 = (struct fz_colorspace_s *) NULL ;
  int arg4 = (int) 0 ;
  PyObject *arg5 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|OOOO:DisplayList_getPixmap",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_getPixmap" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DisplayList_getPixmap" "', argument " "3"" of type '" "struct fz_colorspace_s *""'"); 
    }
    arg3 = (struct fz_colorspace_s *)(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DisplayList_getPixmap" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (obj4) {
    arg5 = obj4;
  }
  {
    result = (struct fz_pixmap_s *)fz_display_list_s_getPixmap(arg1,arg2,arg3,arg4,arg5);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_getTextPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  int arg2 = (int) 3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  struct fz_stext_page_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O|O:DisplayList_getTextPage",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_getTextPage" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DisplayList_getTextPage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct fz_stext_page_s *)fz_display_list_s_getTextPage(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *DisplayList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_display_list_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_TextPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  struct fz_stext_page_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_TextPage",&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    result = (struct fz_stext_page_s *)new_fz_stext_page_s(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_stext_page_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_TextPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_TextPage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_stext_page_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TextPage" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  delete_fz_stext_page_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_search(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 = (int) 16 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO|OO:TextPage_search",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_search" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TextPage_search" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextPage_search" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TextPage_search" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  result = (PyObject *)fz_stext_page_s_search(arg1,(char const *)arg2,arg3,arg4);
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage__extractTextBlocks_AsList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:TextPage__extractTextBlocks_AsList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage__extractTextBlocks_AsList" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  {
    result = (PyObject *)fz_stext_page_s__extractTextBlocks_AsList(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage__extractTextWords_AsList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:TextPage__extractTextWords_AsList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage__extractTextWords_AsList" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  {
    result = (PyObject *)fz_stext_page_s__extractTextWords_AsList(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage__extractText(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:TextPage__extractText",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage__extractText" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TextPage__extractText" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_stext_page_s__extractText(arg1,arg2);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *TextPage_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_stext_page_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Graftmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_graft_map_s *arg1 = (struct pdf_graft_map_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Graftmap",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_pdf_graft_map_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Graftmap" "', argument " "1"" of type '" "struct pdf_graft_map_s *""'"); 
  }
  arg1 = (struct pdf_graft_map_s *)(argp1);
  delete_pdf_graft_map_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Graftmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  struct pdf_graft_map_s *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Graftmap",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Graftmap" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  {
    result = (struct pdf_graft_map_s *)new_pdf_graft_map_s(arg1);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_graft_map_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Graftmap_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_pdf_graft_map_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_Tools_gen_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tools_gen_id",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_gen_id" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_gen_id(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_store_shrink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Tools_store_shrink",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_store_shrink" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_store_shrink" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = (PyObject *)Tools_store_shrink(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_store_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tools_store_size",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_store_size" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_store_size(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_store_maxsize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tools_store_maxsize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_store_maxsize" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_store_maxsize(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_fitz_config(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tools_fitz_config",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_fitz_config" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_fitz_config(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_glyph_cache_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tools_glyph_cache_empty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_glyph_cache_empty" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  Tools_glyph_cache_empty(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__insert_contents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct fz_page_s *arg2 = (struct fz_page_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:Tools__insert_contents",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__insert_contents" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__insert_contents" "', argument " "2"" of type '" "struct fz_page_s *""'"); 
  }
  arg2 = (struct fz_page_s *)(argp2);
  arg3 = obj2;
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Tools__insert_contents" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    result = (PyObject *)Tools__insert_contents(arg1,arg2,arg3,arg4);
    if(!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_fitz_stdout(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tools_fitz_stdout",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_fitz_stdout" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_fitz_stdout(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_fitz_stdout_reset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tools_fitz_stdout_reset",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_fitz_stdout_reset" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  Tools_fitz_stdout_reset(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_fitz_stderr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tools_fitz_stderr",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_fitz_stderr" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_fitz_stderr(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_fitz_stderr_reset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tools_fitz_stderr_reset",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_fitz_stderr_reset" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  Tools_fitz_stderr_reset(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_mupdf_version(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tools_mupdf_version",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_mupdf_version" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_mupdf_version(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__transform_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Tools__transform_rect",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__transform_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  result = (PyObject *)Tools__transform_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__intersect_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Tools__intersect_rect",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__intersect_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  result = (PyObject *)Tools__intersect_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__include_point_in_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Tools__include_point_in_rect",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__include_point_in_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  result = (PyObject *)Tools__include_point_in_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__union_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Tools__union_rect",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__union_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  result = (PyObject *)Tools__union_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__concat_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Tools__concat_matrix",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__concat_matrix" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = obj1;
  arg3 = obj2;
  result = (PyObject *)Tools__concat_matrix(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__invert_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Tools__invert_matrix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__invert_matrix" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = obj1;
  result = (PyObject *)Tools__invert_matrix(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_measure_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  float result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:Tools_measure_string",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_measure_string" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools_measure_string" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Tools_measure_string" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_float(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Tools_measure_string" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = (float)(val4);
  result = (float)Tools_measure_string(arg1,(char const *)arg2,(char const *)arg3,arg4);
  resultobj = SWIG_From_float((float)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Tools(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_Tools")) SWIG_fail;
  result = (struct Tools *)calloc(1, sizeof(struct Tools));
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Tools, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Tools(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Tools",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Tools, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Tools" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  free((char *) arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Tools_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char *)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Tools, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

static PyMethodDef SwigMethods[] = {
	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { (char *)"delete_Document", _wrap_delete_Document, METH_VARARGS, (char *)"delete_Document(self)"},
	 { (char *)"new_Document", _wrap_new_Document, METH_VARARGS, (char *)"new_Document(filename=None, stream=None, filetype=None, rect=None, width=0, height=0, fontsize=11) -> Document"},
	 { (char *)"Document_close", _wrap_Document_close, METH_VARARGS, (char *)"Document_close(self)"},
	 { (char *)"Document_loadPage", _wrap_Document_loadPage, METH_VARARGS, (char *)"Document_loadPage(self, number=0) -> Page"},
	 { (char *)"Document__loadOutline", _wrap_Document__loadOutline, METH_VARARGS, (char *)"Document__loadOutline(self) -> Outline"},
	 { (char *)"Document__dropOutline", _wrap_Document__dropOutline, METH_VARARGS, (char *)"Document__dropOutline(self, ol)"},
	 { (char *)"Document_embeddedFileCount", _wrap_Document_embeddedFileCount, METH_VARARGS, (char *)"Return number of embedded files."},
	 { (char *)"Document_embeddedFileDel", _wrap_Document_embeddedFileDel, METH_VARARGS, (char *)"Delete embedded file by name."},
	 { (char *)"Document_embeddedFileInfo", _wrap_Document_embeddedFileInfo, METH_VARARGS, (char *)"Retrieve embedded file information given its entry number or name."},
	 { (char *)"Document_embeddedFileUpd", _wrap_Document_embeddedFileUpd, METH_VARARGS, (char *)"Change an embedded file given its entry number or name."},
	 { (char *)"Document_embeddedFileGet", _wrap_Document_embeddedFileGet, METH_VARARGS, (char *)"Retrieve embedded file content by name or by number."},
	 { (char *)"Document_embeddedFileAdd", _wrap_Document_embeddedFileAdd, METH_VARARGS, (char *)"Embed a new file."},
	 { (char *)"Document_convertToPDF", _wrap_Document_convertToPDF, METH_VARARGS, (char *)"Convert document to PDF selecting page range and optional rotation. Output bytes object."},
	 { (char *)"Document_pageCount", _wrap_Document_pageCount, METH_VARARGS, (char *)"Document_pageCount(self) -> PyObject *"},
	 { (char *)"Document__getMetadata", _wrap_Document__getMetadata, METH_VARARGS, (char *)"Document__getMetadata(self, key) -> char *"},
	 { (char *)"Document_needsPass", _wrap_Document_needsPass, METH_VARARGS, (char *)"Document_needsPass(self) -> PyObject *"},
	 { (char *)"Document_resolveLink", _wrap_Document_resolveLink, METH_VARARGS, (char *)"Calculate internal link destination."},
	 { (char *)"Document_layout", _wrap_Document_layout, METH_VARARGS, (char *)"Re-layout a reflowable document."},
	 { (char *)"Document_makeBookmark", _wrap_Document_makeBookmark, METH_VARARGS, (char *)"Make page bookmark in a reflowable document."},
	 { (char *)"Document_findBookmark", _wrap_Document_findBookmark, METH_VARARGS, (char *)"Find page number after layouting a document."},
	 { (char *)"Document_isReflowable", _wrap_Document_isReflowable, METH_VARARGS, (char *)"Document_isReflowable(self) -> PyObject *"},
	 { (char *)"Document__deleteObject", _wrap_Document__deleteObject, METH_VARARGS, (char *)"Delete an object given its xref."},
	 { (char *)"Document__getPDFroot", _wrap_Document__getPDFroot, METH_VARARGS, (char *)"Get XREF number of PDF catalog."},
	 { (char *)"Document__getPDFfileid", _wrap_Document__getPDFfileid, METH_VARARGS, (char *)"Return PDF file /ID strings (hexadecimal)."},
	 { (char *)"Document_isPDF", _wrap_Document_isPDF, METH_VARARGS, (char *)"Document_isPDF(self) -> PyObject *"},
	 { (char *)"Document__hasXrefStream", _wrap_Document__hasXrefStream, METH_VARARGS, (char *)"Document__hasXrefStream(self) -> PyObject *"},
	 { (char *)"Document__hasXrefOldStyle", _wrap_Document__hasXrefOldStyle, METH_VARARGS, (char *)"Document__hasXrefOldStyle(self) -> PyObject *"},
	 { (char *)"Document_isDirty", _wrap_Document_isDirty, METH_VARARGS, (char *)"Document_isDirty(self) -> PyObject *"},
	 { (char *)"Document__getGCTXerrcode", _wrap_Document__getGCTXerrcode, METH_VARARGS, (char *)"Retrieve last MuPDF error code."},
	 { (char *)"Document__getGCTXerrmsg", _wrap_Document__getGCTXerrmsg, METH_VARARGS, (char *)"Retrieve last MuPDF error message."},
	 { (char *)"Document_authenticate", _wrap_Document_authenticate, METH_VARARGS, (char *)"Decrypt document with a password."},
	 { (char *)"Document_save", _wrap_Document_save, METH_VARARGS, (char *)"Document_save(self, filename, garbage=0, clean=0, deflate=0, incremental=0, ascii=0, expand=0, linear=0, pretty=0, decrypt=1) -> PyObject *"},
	 { (char *)"Document_write", _wrap_Document_write, METH_VARARGS, (char *)"Write document to a bytes object."},
	 { (char *)"Document_insertPDF", _wrap_Document_insertPDF, METH_VARARGS, (char *)"Copy page range ['from', 'to'] of source PDF, starting as page number 'start_at'."},
	 { (char *)"Document_insertPage", _wrap_Document_insertPage, METH_VARARGS, (char *)"Insert a new page in front of 'pno'. Use arguments 'width', 'height' to specify a non-default page size, and optionally text insertion arguments."},
	 { (char *)"Document_select", _wrap_Document_select, METH_VARARGS, (char *)"Build sub-pdf with page numbers in 'list'."},
	 { (char *)"Document_permissions", _wrap_Document_permissions, METH_VARARGS, (char *)"Get permissions dictionary."},
	 { (char *)"Document__getCharWidths", _wrap_Document__getCharWidths, METH_VARARGS, (char *)"Return list of glyphs and glyph widths of a font."},
	 { (char *)"Document__getPageObjNumber", _wrap_Document__getPageObjNumber, METH_VARARGS, (char *)"Document__getPageObjNumber(self, pno) -> PyObject *"},
	 { (char *)"Document__getPageInfo", _wrap_Document__getPageInfo, METH_VARARGS, (char *)"Show fonts or images used on a page."},
	 { (char *)"Document_extractFont", _wrap_Document_extractFont, METH_VARARGS, (char *)"Document_extractFont(self, xref=0, info_only=0) -> PyObject *"},
	 { (char *)"Document_extractImage", _wrap_Document_extractImage, METH_VARARGS, (char *)"Extract image which 'xref' is pointing to."},
	 { (char *)"Document__delToC", _wrap_Document__delToC, METH_VARARGS, (char *)"Document__delToC(self) -> PyObject *"},
	 { (char *)"Document_isFormPDF", _wrap_Document_isFormPDF, METH_VARARGS, (char *)"Document_isFormPDF(self) -> PyObject *"},
	 { (char *)"Document_FormFonts", _wrap_Document_FormFonts, METH_VARARGS, (char *)"Document_FormFonts(self) -> PyObject *"},
	 { (char *)"Document__addFormFont", _wrap_Document__addFormFont, METH_VARARGS, (char *)"Document__addFormFont(self, name, font) -> PyObject *"},
	 { (char *)"Document__getOLRootNumber", _wrap_Document__getOLRootNumber, METH_VARARGS, (char *)"Document__getOLRootNumber(self) -> PyObject *"},
	 { (char *)"Document__getNewXref", _wrap_Document__getNewXref, METH_VARARGS, (char *)"Document__getNewXref(self) -> PyObject *"},
	 { (char *)"Document__getXrefLength", _wrap_Document__getXrefLength, METH_VARARGS, (char *)"Document__getXrefLength(self) -> PyObject *"},
	 { (char *)"Document__getXmlMetadataXref", _wrap_Document__getXmlMetadataXref, METH_VARARGS, (char *)"Document__getXmlMetadataXref(self) -> PyObject *"},
	 { (char *)"Document__delXmlMetadata", _wrap_Document__delXmlMetadata, METH_VARARGS, (char *)"Document__delXmlMetadata(self) -> PyObject *"},
	 { (char *)"Document__getXrefString", _wrap_Document__getXrefString, METH_VARARGS, (char *)"Document__getXrefString(self, xref) -> PyObject *"},
	 { (char *)"Document__getXrefStream", _wrap_Document__getXrefStream, METH_VARARGS, (char *)"Document__getXrefStream(self, xref) -> PyObject *"},
	 { (char *)"Document__updateObject", _wrap_Document__updateObject, METH_VARARGS, (char *)"Document__updateObject(self, xref, text, page=None) -> PyObject *"},
	 { (char *)"Document__updateStream", _wrap_Document__updateStream, METH_VARARGS, (char *)"Document__updateStream(self, xref=0, stream=None, new=0) -> PyObject *"},
	 { (char *)"Document__setMetadata", _wrap_Document__setMetadata, METH_VARARGS, (char *)"Document__setMetadata(self, text) -> PyObject *"},
	 { (char *)"Document_swigregister", Document_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Page", _wrap_delete_Page, METH_VARARGS, (char *)"delete_Page(self)"},
	 { (char *)"Page_bound", _wrap_Page_bound, METH_VARARGS, (char *)"Page_bound(self) -> PyObject *"},
	 { (char *)"Page_run", _wrap_Page_run, METH_VARARGS, (char *)"Page_run(self, dw, m) -> PyObject *"},
	 { (char *)"Page_getSVGimage", _wrap_Page_getSVGimage, METH_VARARGS, (char *)"Create an SVG image from the page as a string."},
	 { (char *)"Page_addLineAnnot", _wrap_Page_addLineAnnot, METH_VARARGS, (char *)"Add 'Line' annot for points p1 and p2."},
	 { (char *)"Page_addTextAnnot", _wrap_Page_addTextAnnot, METH_VARARGS, (char *)"Add a 'sticky note' at position 'point'."},
	 { (char *)"Page_addInkAnnot", _wrap_Page_addInkAnnot, METH_VARARGS, (char *)"Add a 'handwriting' as a list of list of point-likes. Each sublist forms an independent stroke."},
	 { (char *)"Page_addStampAnnot", _wrap_Page_addStampAnnot, METH_VARARGS, (char *)"Add a 'rubber stamp' in a rectangle."},
	 { (char *)"Page_addFileAnnot", _wrap_Page_addFileAnnot, METH_VARARGS, (char *)"Add a 'FileAttachment' annotation at location 'point'."},
	 { (char *)"Page_addStrikeoutAnnot", _wrap_Page_addStrikeoutAnnot, METH_VARARGS, (char *)"Strike out content in a rectangle or quadrilateral."},
	 { (char *)"Page_addUnderlineAnnot", _wrap_Page_addUnderlineAnnot, METH_VARARGS, (char *)"Underline content in a rectangle or quadrilateral."},
	 { (char *)"Page_addSquigglyAnnot", _wrap_Page_addSquigglyAnnot, METH_VARARGS, (char *)"Wavy underline content in a rectangle or quadrilateral."},
	 { (char *)"Page_addHighlightAnnot", _wrap_Page_addHighlightAnnot, METH_VARARGS, (char *)"Highlight content in a rectangle or quadrilateral."},
	 { (char *)"Page_addRectAnnot", _wrap_Page_addRectAnnot, METH_VARARGS, (char *)"Add a 'Rectangle' annotation."},
	 { (char *)"Page_addCircleAnnot", _wrap_Page_addCircleAnnot, METH_VARARGS, (char *)"Add a 'Circle' annotation."},
	 { (char *)"Page_addPolylineAnnot", _wrap_Page_addPolylineAnnot, METH_VARARGS, (char *)"Add a 'Polyline' annotation for a sequence of points."},
	 { (char *)"Page_addPolygonAnnot", _wrap_Page_addPolygonAnnot, METH_VARARGS, (char *)"Add a 'Polygon' annotation for a sequence of points."},
	 { (char *)"Page_addFreetextAnnot", _wrap_Page_addFreetextAnnot, METH_VARARGS, (char *)"Add a 'FreeText' annotation in rectangle 'rect'."},
	 { (char *)"Page__addWidget", _wrap_Page__addWidget, METH_VARARGS, (char *)"Page__addWidget(self, Widget) -> Annot"},
	 { (char *)"Page_getDisplayList", _wrap_Page_getDisplayList, METH_VARARGS, (char *)"Page_getDisplayList(self) -> DisplayList"},
	 { (char *)"Page_setCropBox", _wrap_Page_setCropBox, METH_VARARGS, (char *)"Page_setCropBox(self, rect) -> PyObject *"},
	 { (char *)"Page_loadLinks", _wrap_Page_loadLinks, METH_VARARGS, (char *)"Page_loadLinks(self) -> Link"},
	 { (char *)"Page_firstAnnot", _wrap_Page_firstAnnot, METH_VARARGS, (char *)"Points to first annotation on page"},
	 { (char *)"Page_deleteLink", _wrap_Page_deleteLink, METH_VARARGS, (char *)"Delete link if PDF"},
	 { (char *)"Page_deleteAnnot", _wrap_Page_deleteAnnot, METH_VARARGS, (char *)"Delete annot if PDF and return next one"},
	 { (char *)"Page_MediaBoxSize", _wrap_Page_MediaBoxSize, METH_VARARGS, (char *)"Retrieve width, height of /MediaBox."},
	 { (char *)"Page_CropBoxPosition", _wrap_Page_CropBoxPosition, METH_VARARGS, (char *)"Retrieve position of /CropBox. Return (0,0) for non-PDF, or no /CropBox."},
	 { (char *)"Page_rotation", _wrap_Page_rotation, METH_VARARGS, (char *)"Retrieve page rotation."},
	 { (char *)"Page_setRotation", _wrap_Page_setRotation, METH_VARARGS, (char *)"Set page rotation to 'rot' degrees."},
	 { (char *)"Page__addAnnot_FromString", _wrap_Page__addAnnot_FromString, METH_VARARGS, (char *)"Page__addAnnot_FromString(self, linklist) -> PyObject *"},
	 { (char *)"Page__getLinkXrefs", _wrap_Page__getLinkXrefs, METH_VARARGS, (char *)"Page__getLinkXrefs(self) -> PyObject *"},
	 { (char *)"Page__cleanContents", _wrap_Page__cleanContents, METH_VARARGS, (char *)"Page__cleanContents(self) -> PyObject *"},
	 { (char *)"Page__showPDFpage", _wrap_Page__showPDFpage, METH_VARARGS, (char *)"Page__showPDFpage(self, rect, docsrc, pno=0, overlay=1, keep_proportion=1, reuse_xref=0, clip=None, graftmap=None, _imgname=None) -> PyObject *"},
	 { (char *)"Page_insertImage", _wrap_Page_insertImage, METH_VARARGS, (char *)"Insert a new image into a rectangle."},
	 { (char *)"Page__insertFont", _wrap_Page__insertFont, METH_VARARGS, (char *)"Page__insertFont(self, fontname, bfname, fontfile, fontbuffer, set_simple, idx, wmode, serif, encoding, ordering) -> PyObject *"},
	 { (char *)"Page__getTransformation", _wrap_Page__getTransformation, METH_VARARGS, (char *)"Page__getTransformation(self) -> PyObject *"},
	 { (char *)"Page__getContents", _wrap_Page__getContents, METH_VARARGS, (char *)"Return list of /Contents objects as xref integers."},
	 { (char *)"Page__setContents", _wrap_Page__setContents, METH_VARARGS, (char *)"Set the /Contents object in page definition"},
	 { (char *)"Page_swigregister", Page_swigregister, METH_VARARGS, NULL},
	 { (char *)"Pixmap_x_set", _wrap_Pixmap_x_set, METH_VARARGS, (char *)"Pixmap_x_set(self, x)"},
	 { (char *)"Pixmap_x_get", _wrap_Pixmap_x_get, METH_VARARGS, (char *)"Pixmap_x_get(self) -> int"},
	 { (char *)"Pixmap_y_set", _wrap_Pixmap_y_set, METH_VARARGS, (char *)"Pixmap_y_set(self, y)"},
	 { (char *)"Pixmap_y_get", _wrap_Pixmap_y_get, METH_VARARGS, (char *)"Pixmap_y_get(self) -> int"},
	 { (char *)"Pixmap_w_set", _wrap_Pixmap_w_set, METH_VARARGS, (char *)"Pixmap_w_set(self, w)"},
	 { (char *)"Pixmap_w_get", _wrap_Pixmap_w_get, METH_VARARGS, (char *)"Pixmap_w_get(self) -> int"},
	 { (char *)"Pixmap_h_set", _wrap_Pixmap_h_set, METH_VARARGS, (char *)"Pixmap_h_set(self, h)"},
	 { (char *)"Pixmap_h_get", _wrap_Pixmap_h_get, METH_VARARGS, (char *)"Pixmap_h_get(self) -> int"},
	 { (char *)"Pixmap_n_set", _wrap_Pixmap_n_set, METH_VARARGS, (char *)"Pixmap_n_set(self, n)"},
	 { (char *)"Pixmap_n_get", _wrap_Pixmap_n_get, METH_VARARGS, (char *)"Pixmap_n_get(self) -> int"},
	 { (char *)"Pixmap_xres_set", _wrap_Pixmap_xres_set, METH_VARARGS, (char *)"Pixmap_xres_set(self, xres)"},
	 { (char *)"Pixmap_xres_get", _wrap_Pixmap_xres_get, METH_VARARGS, (char *)"Pixmap_xres_get(self) -> int"},
	 { (char *)"Pixmap_yres_set", _wrap_Pixmap_yres_set, METH_VARARGS, (char *)"Pixmap_yres_set(self, yres)"},
	 { (char *)"Pixmap_yres_get", _wrap_Pixmap_yres_get, METH_VARARGS, (char *)"Pixmap_yres_get(self) -> int"},
	 { (char *)"delete_Pixmap", _wrap_delete_Pixmap, METH_VARARGS, (char *)"delete_Pixmap(self)"},
	 { (char *)"new_Pixmap", _wrap_new_Pixmap, METH_VARARGS, (char *)"\n"
		"Pixmap(cs, bbox, alpha=0)\n"
		"Pixmap(cs, spix)\n"
		"Pixmap(spix, w, h, clip=None)\n"
		"Pixmap(spix, alpha=1)\n"
		"Pixmap(cs, w, h, samples, alpha=0)\n"
		"Pixmap(filename)\n"
		"Pixmap(imagedata)\n"
		"new_Pixmap(doc, xref) -> Pixmap\n"
		""},
	 { (char *)"Pixmap_shrink", _wrap_Pixmap_shrink, METH_VARARGS, (char *)"Pixmap_shrink(self, factor)"},
	 { (char *)"Pixmap_gammaWith", _wrap_Pixmap_gammaWith, METH_VARARGS, (char *)"Pixmap_gammaWith(self, gamma)"},
	 { (char *)"Pixmap_tintWith", _wrap_Pixmap_tintWith, METH_VARARGS, (char *)"Pixmap_tintWith(self, red, green, blue)"},
	 { (char *)"Pixmap_clearWith", _wrap_Pixmap_clearWith, METH_VARARGS, (char *)"\n"
		"clearWith()\n"
		"clearWith(value)\n"
		"Pixmap_clearWith(self, value, bbox)\n"
		""},
	 { (char *)"Pixmap_copyPixmap", _wrap_Pixmap_copyPixmap, METH_VARARGS, (char *)"Pixmap_copyPixmap(self, src, bbox) -> PyObject *"},
	 { (char *)"Pixmap_setAlpha", _wrap_Pixmap_setAlpha, METH_VARARGS, (char *)"Pixmap_setAlpha(self, alphavalues=None) -> PyObject *"},
	 { (char *)"Pixmap__getImageData", _wrap_Pixmap__getImageData, METH_VARARGS, (char *)"Pixmap__getImageData(self, format) -> PyObject *"},
	 { (char *)"Pixmap__writeIMG", _wrap_Pixmap__writeIMG, METH_VARARGS, (char *)"Pixmap__writeIMG(self, filename, format) -> PyObject *"},
	 { (char *)"Pixmap_invertIRect", _wrap_Pixmap_invertIRect, METH_VARARGS, (char *)"Pixmap_invertIRect(self, irect=None)"},
	 { (char *)"Pixmap_pixel", _wrap_Pixmap_pixel, METH_VARARGS, (char *)"Return the pixel at (x,y) as a list. Last item is the alpha if Pixmap.alpha is true."},
	 { (char *)"Pixmap_setPixel", _wrap_Pixmap_setPixel, METH_VARARGS, (char *)"Set the pixel at (x,y) to the integers in sequence 'value'."},
	 { (char *)"Pixmap_stride", _wrap_Pixmap_stride, METH_VARARGS, (char *)"Pixmap_stride(self) -> int"},
	 { (char *)"Pixmap_alpha", _wrap_Pixmap_alpha, METH_VARARGS, (char *)"Pixmap_alpha(self) -> int"},
	 { (char *)"Pixmap_colorspace", _wrap_Pixmap_colorspace, METH_VARARGS, (char *)"Pixmap_colorspace(self) -> Colorspace"},
	 { (char *)"Pixmap_irect", _wrap_Pixmap_irect, METH_VARARGS, (char *)"Pixmap_irect(self) -> PyObject *"},
	 { (char *)"Pixmap_size", _wrap_Pixmap_size, METH_VARARGS, (char *)"Pixmap_size(self) -> int"},
	 { (char *)"Pixmap_samples", _wrap_Pixmap_samples, METH_VARARGS, (char *)"Pixmap_samples(self) -> PyObject *"},
	 { (char *)"Pixmap_swigregister", Pixmap_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Colorspace", _wrap_delete_Colorspace, METH_VARARGS, (char *)"delete_Colorspace(self)"},
	 { (char *)"new_Colorspace", _wrap_new_Colorspace, METH_VARARGS, (char *)"new_Colorspace(type) -> Colorspace"},
	 { (char *)"Colorspace_n", _wrap_Colorspace_n, METH_VARARGS, (char *)"Colorspace_n(self) -> PyObject *"},
	 { (char *)"Colorspace__name", _wrap_Colorspace__name, METH_VARARGS, (char *)"Colorspace__name(self) -> PyObject *"},
	 { (char *)"Colorspace_swigregister", Colorspace_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_Device", _wrap_new_Device, METH_VARARGS, (char *)"\n"
		"Device(pm, clip)\n"
		"Device(dl)\n"
		"new_Device(tp, flags=0) -> Device\n"
		""},
	 { (char *)"delete_Device", _wrap_delete_Device, METH_VARARGS, (char *)"delete_Device(self)"},
	 { (char *)"Device_swigregister", Device_swigregister, METH_VARARGS, NULL},
	 { (char *)"Outline_title_get", _wrap_Outline_title_get, METH_VARARGS, (char *)"Outline_title_get(self) -> char *"},
	 { (char *)"Outline_page_get", _wrap_Outline_page_get, METH_VARARGS, (char *)"Outline_page_get(self) -> int"},
	 { (char *)"Outline_next_get", _wrap_Outline_next_get, METH_VARARGS, (char *)"Outline_next_get(self) -> Outline"},
	 { (char *)"Outline_down_get", _wrap_Outline_down_get, METH_VARARGS, (char *)"Outline_down_get(self) -> Outline"},
	 { (char *)"Outline_is_open_get", _wrap_Outline_is_open_get, METH_VARARGS, (char *)"Outline_is_open_get(self) -> int"},
	 { (char *)"Outline_uri", _wrap_Outline_uri, METH_VARARGS, (char *)"Outline_uri(self) -> PyObject *"},
	 { (char *)"Outline_isExternal", _wrap_Outline_isExternal, METH_VARARGS, (char *)"Outline_isExternal(self) -> PyObject *"},
	 { (char *)"delete_Outline", _wrap_delete_Outline, METH_VARARGS, (char *)"delete_Outline(self)"},
	 { (char *)"Outline_swigregister", Outline_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Annot", _wrap_delete_Annot, METH_VARARGS, (char *)"delete_Annot(self)"},
	 { (char *)"Annot_rect", _wrap_Annot_rect, METH_VARARGS, (char *)"Rectangle containing the annot"},
	 { (char *)"Annot_xref", _wrap_Annot_xref, METH_VARARGS, (char *)"Annot_xref(self) -> PyObject *"},
	 { (char *)"Annot__getAP", _wrap_Annot__getAP, METH_VARARGS, (char *)"Get contents source of a PDF annot"},
	 { (char *)"Annot__setAP", _wrap_Annot__setAP, METH_VARARGS, (char *)"Update contents source of a PDF annot"},
	 { (char *)"Annot_setRect", _wrap_Annot_setRect, METH_VARARGS, (char *)"Annot_setRect(self, rect)"},
	 { (char *)"Annot_vertices", _wrap_Annot_vertices, METH_VARARGS, (char *)"Point coordinates for various annot types"},
	 { (char *)"Annot_colors", _wrap_Annot_colors, METH_VARARGS, (char *)"dictionary of the annot's colors"},
	 { (char *)"Annot_update", _wrap_Annot_update, METH_VARARGS, (char *)"Update the appearance of an annotation."},
	 { (char *)"Annot_setColors", _wrap_Annot_setColors, METH_VARARGS, (char *)"\n"
		"setColors(dict)\n"
		"Changes the 'stroke' and 'fill' colors of an annotation. If provided, values must be lists of up to 4 floats.\n"
		""},
	 { (char *)"Annot_lineEnds", _wrap_Annot_lineEnds, METH_VARARGS, (char *)"Annot_lineEnds(self) -> PyObject *"},
	 { (char *)"Annot_setLineEnds", _wrap_Annot_setLineEnds, METH_VARARGS, (char *)"Annot_setLineEnds(self, start, end)"},
	 { (char *)"Annot_type", _wrap_Annot_type, METH_VARARGS, (char *)"Annot_type(self) -> PyObject *"},
	 { (char *)"Annot_opacity", _wrap_Annot_opacity, METH_VARARGS, (char *)"Annot_opacity(self) -> PyObject *"},
	 { (char *)"Annot_setOpacity", _wrap_Annot_setOpacity, METH_VARARGS, (char *)"Annot_setOpacity(self, opacity)"},
	 { (char *)"Annot_widget_type", _wrap_Annot_widget_type, METH_VARARGS, (char *)"Annot_widget_type(self) -> PyObject *"},
	 { (char *)"Annot_widget_value", _wrap_Annot_widget_value, METH_VARARGS, (char *)"Annot_widget_value(self) -> PyObject *"},
	 { (char *)"Annot_widget_name", _wrap_Annot_widget_name, METH_VARARGS, (char *)"Annot_widget_name(self) -> PyObject *"},
	 { (char *)"Annot_widget_choices", _wrap_Annot_widget_choices, METH_VARARGS, (char *)"Annot_widget_choices(self) -> PyObject *"},
	 { (char *)"Annot_fileInfo", _wrap_Annot_fileInfo, METH_VARARGS, (char *)"Retrieve attached file information."},
	 { (char *)"Annot_fileGet", _wrap_Annot_fileGet, METH_VARARGS, (char *)"Retrieve annotation attached file content."},
	 { (char *)"Annot_fileUpd", _wrap_Annot_fileUpd, METH_VARARGS, (char *)"Update annotation attached file content."},
	 { (char *)"Annot_info", _wrap_Annot_info, METH_VARARGS, (char *)"Annot_info(self) -> PyObject *"},
	 { (char *)"Annot_setInfo", _wrap_Annot_setInfo, METH_VARARGS, (char *)"Annot_setInfo(self, info) -> PyObject *"},
	 { (char *)"Annot_border", _wrap_Annot_border, METH_VARARGS, (char *)"Annot_border(self) -> PyObject *"},
	 { (char *)"Annot_setBorder", _wrap_Annot_setBorder, METH_VARARGS, (char *)"Annot_setBorder(self, border) -> PyObject *"},
	 { (char *)"Annot_flags", _wrap_Annot_flags, METH_VARARGS, (char *)"Annot_flags(self) -> int"},
	 { (char *)"Annot__cleanContents", _wrap_Annot__cleanContents, METH_VARARGS, (char *)"Annot__cleanContents(self) -> PyObject *"},
	 { (char *)"Annot_setFlags", _wrap_Annot_setFlags, METH_VARARGS, (char *)"Annot_setFlags(self, flags)"},
	 { (char *)"Annot_next", _wrap_Annot_next, METH_VARARGS, (char *)"Annot_next(self) -> Annot"},
	 { (char *)"Annot_getPixmap", _wrap_Annot_getPixmap, METH_VARARGS, (char *)"Annot_getPixmap(self, matrix=None, colorspace=None, alpha=0) -> Pixmap"},
	 { (char *)"Annot__updateWidget", _wrap_Annot__updateWidget, METH_VARARGS, (char *)"Annot__updateWidget(self, Widget) -> PyObject *"},
	 { (char *)"Annot__getWidget", _wrap_Annot__getWidget, METH_VARARGS, (char *)"Annot__getWidget(self, Widget) -> PyObject *"},
	 { (char *)"Annot_swigregister", Annot_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Link", _wrap_delete_Link, METH_VARARGS, (char *)"delete_Link(self)"},
	 { (char *)"Link__border", _wrap_Link__border, METH_VARARGS, (char *)"Link__border(self, doc, xref) -> PyObject *"},
	 { (char *)"Link__setBorder", _wrap_Link__setBorder, METH_VARARGS, (char *)"Link__setBorder(self, border, doc, xref) -> PyObject *"},
	 { (char *)"Link__colors", _wrap_Link__colors, METH_VARARGS, (char *)"Link__colors(self, doc, xref) -> PyObject *"},
	 { (char *)"Link__setColors", _wrap_Link__setColors, METH_VARARGS, (char *)"Link__setColors(self, colors, doc, xref) -> PyObject *"},
	 { (char *)"Link_uri", _wrap_Link_uri, METH_VARARGS, (char *)"Link_uri(self) -> PyObject *"},
	 { (char *)"Link_isExternal", _wrap_Link_isExternal, METH_VARARGS, (char *)"Link_isExternal(self) -> PyObject *"},
	 { (char *)"Link_rect", _wrap_Link_rect, METH_VARARGS, (char *)"Link_rect(self) -> PyObject *"},
	 { (char *)"Link_next", _wrap_Link_next, METH_VARARGS, (char *)"Link_next(self) -> Link"},
	 { (char *)"Link_swigregister", Link_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_DisplayList", _wrap_delete_DisplayList, METH_VARARGS, (char *)"delete_DisplayList(self)"},
	 { (char *)"new_DisplayList", _wrap_new_DisplayList, METH_VARARGS, (char *)"new_DisplayList(mediabox) -> DisplayList"},
	 { (char *)"DisplayList_run", _wrap_DisplayList_run, METH_VARARGS, (char *)"DisplayList_run(self, dw, m, area) -> PyObject *"},
	 { (char *)"DisplayList_rect", _wrap_DisplayList_rect, METH_VARARGS, (char *)"DisplayList_rect(self) -> PyObject *"},
	 { (char *)"DisplayList_getPixmap", _wrap_DisplayList_getPixmap, METH_VARARGS, (char *)"DisplayList_getPixmap(self, matrix=None, colorspace=None, alpha=0, clip=None) -> Pixmap"},
	 { (char *)"DisplayList_getTextPage", _wrap_DisplayList_getTextPage, METH_VARARGS, (char *)"DisplayList_getTextPage(self, flags=3) -> TextPage"},
	 { (char *)"DisplayList_swigregister", DisplayList_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_TextPage", _wrap_new_TextPage, METH_VARARGS, (char *)"new_TextPage(mediabox) -> TextPage"},
	 { (char *)"delete_TextPage", _wrap_delete_TextPage, METH_VARARGS, (char *)"delete_TextPage(self)"},
	 { (char *)"TextPage_search", _wrap_TextPage_search, METH_VARARGS, (char *)"TextPage_search(self, needle, hit_max=16, quads=0) -> PyObject *"},
	 { (char *)"TextPage__extractTextBlocks_AsList", _wrap_TextPage__extractTextBlocks_AsList, METH_VARARGS, (char *)"TextPage__extractTextBlocks_AsList(self) -> PyObject *"},
	 { (char *)"TextPage__extractTextWords_AsList", _wrap_TextPage__extractTextWords_AsList, METH_VARARGS, (char *)"TextPage__extractTextWords_AsList(self) -> PyObject *"},
	 { (char *)"TextPage__extractText", _wrap_TextPage__extractText, METH_VARARGS, (char *)"TextPage__extractText(self, format) -> PyObject *"},
	 { (char *)"TextPage_swigregister", TextPage_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Graftmap", _wrap_delete_Graftmap, METH_VARARGS, (char *)"delete_Graftmap(self)"},
	 { (char *)"new_Graftmap", _wrap_new_Graftmap, METH_VARARGS, (char *)"new_Graftmap(doc) -> Graftmap"},
	 { (char *)"Graftmap_swigregister", Graftmap_swigregister, METH_VARARGS, NULL},
	 { (char *)"Tools_gen_id", _wrap_Tools_gen_id, METH_VARARGS, (char *)"Return a unique positive integer."},
	 { (char *)"Tools_store_shrink", _wrap_Tools_store_shrink, METH_VARARGS, (char *)"Free 'percent' of current store size."},
	 { (char *)"Tools_store_size", _wrap_Tools_store_size, METH_VARARGS, (char *)"Current store size."},
	 { (char *)"Tools_store_maxsize", _wrap_Tools_store_maxsize, METH_VARARGS, (char *)"Maximum store size."},
	 { (char *)"Tools_fitz_config", _wrap_Tools_fitz_config, METH_VARARGS, (char *)"Show configuration data."},
	 { (char *)"Tools_glyph_cache_empty", _wrap_Tools_glyph_cache_empty, METH_VARARGS, (char *)"Empty the glyph cache."},
	 { (char *)"Tools__insert_contents", _wrap_Tools__insert_contents, METH_VARARGS, (char *)"Tools__insert_contents(self, fzpage, newcont, overlay) -> PyObject *"},
	 { (char *)"Tools_fitz_stdout", _wrap_Tools_fitz_stdout, METH_VARARGS, (char *)"Tools_fitz_stdout(self) -> PyObject *"},
	 { (char *)"Tools_fitz_stdout_reset", _wrap_Tools_fitz_stdout_reset, METH_VARARGS, (char *)"Empty fitz output log."},
	 { (char *)"Tools_fitz_stderr", _wrap_Tools_fitz_stderr, METH_VARARGS, (char *)"Tools_fitz_stderr(self) -> PyObject *"},
	 { (char *)"Tools_fitz_stderr_reset", _wrap_Tools_fitz_stderr_reset, METH_VARARGS, (char *)"Empty fitz error log."},
	 { (char *)"Tools_mupdf_version", _wrap_Tools_mupdf_version, METH_VARARGS, (char *)"Return compiled MuPDF version."},
	 { (char *)"Tools__transform_rect", _wrap_Tools__transform_rect, METH_VARARGS, (char *)"Transform rectangle with matrix."},
	 { (char *)"Tools__intersect_rect", _wrap_Tools__intersect_rect, METH_VARARGS, (char *)"Intersect two rectangles."},
	 { (char *)"Tools__include_point_in_rect", _wrap_Tools__include_point_in_rect, METH_VARARGS, (char *)"Include point in a rect."},
	 { (char *)"Tools__union_rect", _wrap_Tools__union_rect, METH_VARARGS, (char *)"Replace r1 with smallest rect containing both."},
	 { (char *)"Tools__concat_matrix", _wrap_Tools__concat_matrix, METH_VARARGS, (char *)"Concatenate matrices m1, m2."},
	 { (char *)"Tools__invert_matrix", _wrap_Tools__invert_matrix, METH_VARARGS, (char *)"Invert a matrix."},
	 { (char *)"Tools_measure_string", _wrap_Tools_measure_string, METH_VARARGS, (char *)"Measure length of a string for a Base14 font."},
	 { (char *)"new_Tools", _wrap_new_Tools, METH_VARARGS, (char *)"new_Tools() -> Tools"},
	 { (char *)"delete_Tools", _wrap_delete_Tools, METH_VARARGS, (char *)"delete_Tools(self)"},
	 { (char *)"Tools_swigregister", Tools_swigregister, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_DeviceWrapper = {"_p_DeviceWrapper", "struct DeviceWrapper *|DeviceWrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Tools = {"_p_Tools", "struct Tools *|Tools *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_annot_s = {"_p_fz_annot_s", "struct fz_annot_s *|fz_annot_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_colorspace_s = {"_p_fz_colorspace_s", "struct fz_colorspace_s *|fz_colorspace_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_display_list_s = {"_p_fz_display_list_s", "struct fz_display_list_s *|fz_display_list_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_document_s = {"_p_fz_document_s", "struct fz_document_s *|fz_document_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_link_s = {"_p_fz_link_s", "struct fz_link_s *|fz_link_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_outline_s = {"_p_fz_outline_s", "struct fz_outline_s *|fz_outline_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_page_s = {"_p_fz_page_s", "struct fz_page_s *|fz_page_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_pixmap_s = {"_p_fz_pixmap_s", "struct fz_pixmap_s *|fz_pixmap_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_stext_page_s = {"_p_fz_stext_page_s", "struct fz_stext_page_s *|fz_stext_page_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdf_graft_map_s = {"_p_pdf_graft_map_s", "struct pdf_graft_map_s *|pdf_graft_map_s *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_DeviceWrapper,
  &_swigt__p_Tools,
  &_swigt__p_char,
  &_swigt__p_fz_annot_s,
  &_swigt__p_fz_colorspace_s,
  &_swigt__p_fz_display_list_s,
  &_swigt__p_fz_document_s,
  &_swigt__p_fz_link_s,
  &_swigt__p_fz_outline_s,
  &_swigt__p_fz_page_s,
  &_swigt__p_fz_pixmap_s,
  &_swigt__p_fz_stext_page_s,
  &_swigt__p_pdf_graft_map_s,
};

static swig_cast_info _swigc__p_DeviceWrapper[] = {  {&_swigt__p_DeviceWrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Tools[] = {  {&_swigt__p_Tools, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_annot_s[] = {  {&_swigt__p_fz_annot_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_colorspace_s[] = {  {&_swigt__p_fz_colorspace_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_display_list_s[] = {  {&_swigt__p_fz_display_list_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_document_s[] = {  {&_swigt__p_fz_document_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_link_s[] = {  {&_swigt__p_fz_link_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_outline_s[] = {  {&_swigt__p_fz_outline_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_page_s[] = {  {&_swigt__p_fz_page_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_pixmap_s[] = {  {&_swigt__p_fz_pixmap_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_stext_page_s[] = {  {&_swigt__p_fz_stext_page_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdf_graft_map_s[] = {  {&_swigt__p_pdf_graft_map_s, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_DeviceWrapper,
  _swigc__p_Tools,
  _swigc__p_char,
  _swigc__p_fz_annot_s,
  _swigc__p_fz_colorspace_s,
  _swigc__p_fz_display_list_s,
  _swigc__p_fz_document_s,
  _swigc__p_fz_link_s,
  _swigc__p_fz_outline_s,
  _swigc__p_fz_page_s,
  _swigc__p_fz_pixmap_s,
  _swigc__p_fz_stext_page_s,
  _swigc__p_pdf_graft_map_s,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN int
  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
    char *tmp;
    PyObject *str = swig_varlink_str(v);
    fprintf(fp,"Swig global variables ");
    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(str);
    return 0;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(NULL, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* ob_size */
#endif
        (char *)"swigvarlink",              /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        (printfunc) swig_varlink_print,     /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
        0,                                  /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
        0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
        0,                                  /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
        0,                                  /* tp_allocs */
        0,                                  /* tp_frees */
        0,                                  /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
        0,                                  /* tp_prev */
#endif
        0                                   /* tp_next */
#endif
      };
      varlink_type = tmp;
      type_init = 1;
#if PY_VERSION_HEX < 0x02020000
      varlink_type.ob_type = &PyType_Type;
#else
      if (PyType_Ready(&varlink_type) < 0)
      return NULL;
#endif
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        strncpy(gv->name,name,size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *_SWIG_globals = 0; 
    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
    return _SWIG_globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              strncpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              strncpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md;
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
# if PY_VERSION_HEX >= 0x03020000
    PyModuleDef_HEAD_INIT,
# else
    {
      PyObject_HEAD_INIT(NULL)
      NULL, /* m_init */
      0,    /* m_index */
      NULL, /* m_copy */
    },
# endif
    (char *) SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    (PyCFunction) SwigPyObject_own,
    (PyCFunction) SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule((char *) SWIG_name, SwigMethods);
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();
  
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  
#if JM_MEMORY == 1
  gctx = fz_new_context(&JM_Alloc_Context, NULL, FZ_STORE_DEFAULT);
#else
  gctx = fz_new_context(NULL, NULL, FZ_STORE_DEFAULT);
#endif
  if(!gctx)
  {
    PyErr_SetString(PyExc_RuntimeError, "Fatal error: could not create global context.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  fz_register_document_handlers(gctx);
  
  //-----------------------------------------------------------------------------
  // START redirect stdout/stderr
  //-----------------------------------------------------------------------------
  
  JM_output_log = PyByteArray_FromStringAndSize("", 0);
  fz_output *JM_fitz_stdout = JM_OutFromBarray(gctx, JM_output_log);
  fz_set_stdout(gctx, JM_fitz_stdout);
  
  JM_error_log  = PyByteArray_FromStringAndSize("", 0);
  fz_output *JM_fitz_stderr = JM_OutFromBarray(gctx, JM_error_log);
  fz_set_stderr(gctx, JM_fitz_stderr);
  
  if (JM_fitz_stderr && JM_fitz_stdout)
  {
    ;
  }
  else
  PySys_WriteStderr("error redirecting stdout/stderr!\n");
  
  //-----------------------------------------------------------------------------
  // STOP redirect stdout/stderr
  //-----------------------------------------------------------------------------
  
  SWIG_Python_SetConstant(d, "CS_RGB",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "CS_GRAY",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "CS_CMYK",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "ANNOT_TEXT",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "ANNOT_LINK",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "ANNOT_FREETEXT",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "ANNOT_LINE",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "ANNOT_SQUARE",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "ANNOT_CIRCLE",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "ANNOT_POLYGON",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "ANNOT_POLYLINE",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "ANNOT_HIGHLIGHT",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "ANNOT_UNDERLINE",SWIG_From_int((int)(9)));
  SWIG_Python_SetConstant(d, "ANNOT_SQUIGGLY",SWIG_From_int((int)(10)));
  SWIG_Python_SetConstant(d, "ANNOT_STRIKEOUT",SWIG_From_int((int)(11)));
  SWIG_Python_SetConstant(d, "ANNOT_STAMP",SWIG_From_int((int)(12)));
  SWIG_Python_SetConstant(d, "ANNOT_CARET",SWIG_From_int((int)(13)));
  SWIG_Python_SetConstant(d, "ANNOT_INK",SWIG_From_int((int)(14)));
  SWIG_Python_SetConstant(d, "ANNOT_POPUP",SWIG_From_int((int)(15)));
  SWIG_Python_SetConstant(d, "ANNOT_FILEATTACHMENT",SWIG_From_int((int)(16)));
  SWIG_Python_SetConstant(d, "ANNOT_SOUND",SWIG_From_int((int)(17)));
  SWIG_Python_SetConstant(d, "ANNOT_MOVIE",SWIG_From_int((int)(18)));
  SWIG_Python_SetConstant(d, "ANNOT_WIDGET",SWIG_From_int((int)(19)));
  SWIG_Python_SetConstant(d, "ANNOT_SCREEN",SWIG_From_int((int)(20)));
  SWIG_Python_SetConstant(d, "ANNOT_PRINTERMARK",SWIG_From_int((int)(21)));
  SWIG_Python_SetConstant(d, "ANNOT_TRAPNET",SWIG_From_int((int)(22)));
  SWIG_Python_SetConstant(d, "ANNOT_WATERMARK",SWIG_From_int((int)(23)));
  SWIG_Python_SetConstant(d, "ANNOT_3D",SWIG_From_int((int)(24)));
  SWIG_Python_SetConstant(d, "ANNOT_XF_Invisible",SWIG_From_int((int)(1 << (1-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_Hidden",SWIG_From_int((int)(1 << (2-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_Print",SWIG_From_int((int)(1 << (3-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_NoZoom",SWIG_From_int((int)(1 << (4-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_NoRotate",SWIG_From_int((int)(1 << (5-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_NoView",SWIG_From_int((int)(1 << (6-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_ReadOnly",SWIG_From_int((int)(1 << (7-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_Locked",SWIG_From_int((int)(1 << (8-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_ToggleNoView",SWIG_From_int((int)(1 << (9-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_LockedContents",SWIG_From_int((int)(1 << (10-1))));
  SWIG_Python_SetConstant(d, "ANNOT_LE_None",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_Square",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_Circle",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_Diamond",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_OpenArrow",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_ClosedArrow",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_Butt",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_ROpenArrow",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_RClosedArrow",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_Slash",SWIG_From_int((int)(9)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_NOT_WIDGET",SWIG_From_int((int)(-1)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_PUSHBUTTON",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_CHECKBOX",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_RADIOBUTTON",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_LISTBOX",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_COMBOBOX",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_SIGNATURE",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT_UNRESTRAINED",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT_NUMBER",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT_SPECIAL",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT_DATE",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT_TIME",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_ReadOnly",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Required",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_NoExport",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Multiline",SWIG_From_int((int)(4096)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Password",SWIG_From_int((int)(8192)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_FileSelect",SWIG_From_int((int)(1048576)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_DoNotSpellCheck",SWIG_From_int((int)(4194304)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_DoNotScroll",SWIG_From_int((int)(8388608)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Comb",SWIG_From_int((int)(16777216)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_RichText",SWIG_From_int((int)(33554432)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_NoToggleToOff",SWIG_From_int((int)(16384)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Radio",SWIG_From_int((int)(32768)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Pushbutton",SWIG_From_int((int)(65536)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_RadioInUnison",SWIG_From_int((int)(33554432)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Combo",SWIG_From_int((int)(131072)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Edit",SWIG_From_int((int)(262144)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Sort",SWIG_From_int((int)(524288)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_MultiSelect",SWIG_From_int((int)(2097152)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_CommitOnSelCHange",SWIG_From_int((int)(67108864)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

